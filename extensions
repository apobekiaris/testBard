using System; using System.Collections.Concurrent; using System.Diagnostics.CodeAnalysis; using System.Reflection; using Fasterflect;  namespace Xpand.Extensions.AppDomainExtensions{     public static partial class AppDomainExtensions {         private static readonly ConcurrentDictionary<string,string> StringCache = new();         [SuppressMessage("ReSharper", "HeapView.CanAvoidClosure")]         public static string GetOrAdd(this string key) => StringCache.GetOrAdd(key, _ => key);          public static string ApplicationName(this AppDomain appDomain){             if (appDomain.UseNetFramework()){                 var setupInformation = AppDomain.CurrentDomain.GetPropertyValue("SetupInformation");                 return (string) (setupInformation.GetPropertyValue("ApplicationName")) ;             }              return Assembly.GetEntryAssembly()?.GetName().Name??"ApplicationName";         }     } }using System; using Fasterflect;   namespace Xpand.Extensions.AppDomainExtensions{          public static partial class AppDomainExtensions{         public static string ApplicationPath(this AppDomain appDomain){             if (appDomain.UseNetFramework()){                 var setupInformation = AppDomain.CurrentDomain.GetPropertyValue("SetupInformation");                 return (string) (setupInformation.GetPropertyValue("PrivateBinPath")??setupInformation.GetPropertyValue("ApplicationBase"));             }             return appDomain.BaseDirectory;          }     } }using System.Linq; using System.Reflection;  namespace Xpand.Extensions.AppDomainExtensions{     public static partial class AppDomainExtensions{ 	    public static Assembly SystemWebAssembly(this IAppDomainWeb appDomain)              => appDomain.AppDomain.GetAssemblies().FirstOrDefault(_ => _.GetName().Name == "System.Web");     }       }using System; using System.Net; using System.Threading;  namespace Xpand.Extensions.AppDomainExtensions {          public static partial class AppDomainExtensions {         public static void ConfigureNetwork(this AppDomain appDomain, int connectionLimit = 100, int workerThreads = 100, int asyncThreads = 4) {             ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls | SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11;             ServicePointManager.DefaultConnectionLimit = connectionLimit;             ThreadPool.SetMinThreads(workerThreads, asyncThreads);         }     } }using System; using Fasterflect;  namespace Xpand.Extensions.AppDomainExtensions {     public static partial class AppDomainExtensions {         public static object CreateTypeInstance(this AppDomain domain, string fullName, params object[] parameters)             => domain.GetAssemblyType(fullName).CreateInstance(parameters);     } }using System; using System.Linq; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.AppDomainExtensions{     public static partial class AppDomainExtensions {         public static Type GetAssemblyType(this AppDomain domain, string fullName,bool ignoreCase=false)              => fullName==null?null:domain.GetAssemblies().Select(assembly => assembly.GetType(fullName,ignoreCase)).WhereNotDefault().FirstOrDefault();     } }using Fasterflect;  namespace Xpand.Extensions.AppDomainExtensions{ 	public static partial class AppDomainExtensions{         public static object HttpContext(this IAppDomainWeb domainWeb)              => domainWeb.SystemWebAssembly()?.GetType("System.Web.HttpContext")?.GetPropertyValue("Current"); 	} }using Fasterflect;  namespace Xpand.Extensions.AppDomainExtensions{ 	public static partial class AppDomainExtensions{ 		public static object WriteHttpResponse(this IAppDomainWeb domainWeb,string text, bool end=false) => 			domainWeb.HttpResponse().CallMethod("Write", text);  		public static object HttpResponse(this IAppDomainWeb domainWeb) => 			domainWeb.HttpContext()?.GetPropertyValue("Response"); 	} } using System; using System.Linq;  namespace Xpand.Extensions.AppDomainExtensions{ 	public static partial class AppDomainExtensions { 		private static bool? _isHosted;  		public static void SetIsHosted(this AppDomain domain,bool value) 			=> _isHosted = value;  		public static bool IsHosted(this AppDomain domain)              => _isHosted ?? domain.Web().HttpContext() != null || domain.GetAssemblies() 	            .Any(assembly => assembly.GetName().Name == "Microsoft.AspNetCore.Hosting"); 	} }using System; using System.IO; using System.Reflection; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.AppDomainExtensions{     public static partial class AppDomainExtensions{         public static Assembly LoadAssembly(this AppDomain appDomain, string assemblyPath)  	        => Assembly.LoadFrom(Path.GetFullPath(assemblyPath));          public static Assembly LoadAssembly(this AppDomain appDomain, Stream stream)  	        => Assembly.Load(stream.Bytes());                  public static Assembly LoadAssembly(this AppDomain appDomain, byte[] bytes)  	        => Assembly.Load(bytes);     } }using System; using System.Linq; using System.Reflection; using Fasterflect;  namespace Xpand.Extensions.AppDomainExtensions{ 	public static partial class AppDomainExtensions{ 		public static MethodInvoker TypeUnitPercentage(this IAppDomainWeb appDomainWeb){ 			return appDomainWeb.TypeUnit().GetMethods(BindingFlags.Public|BindingFlags.Instance|BindingFlags.Static).First(info => info.Name=="Percentage").DelegateForCallMethod(); 		}  		public static Type TypeUnit(this IAppDomainWeb domainWeb) => 			domainWeb.SystemWebAssembly().GetType("System.Web.UI.WebControls.Unit"); 	} }using System;  namespace Xpand.Extensions.AppDomainExtensions {     public static partial class AppDomainExtensions {         public static void UseClipboard(this AppDomain domain, Action action) {             var currentText = TextCopy.ClipboardService.GetText();             TextCopy.ClipboardService.SetText("");             action();             TextCopy.ClipboardService.SetText($"{currentText}");         }     } }using System; using System.Runtime.InteropServices;  namespace Xpand.Extensions.AppDomainExtensions{     public static partial class AppDomainExtensions{         public static bool UseNetFramework(this AppDomain appDomain)              => RuntimeInformation.FrameworkDescription.StartsWith(".NET Framework");     } }using System;  namespace Xpand.Extensions.AppDomainExtensions{ 	public static partial class AppDomainExtensions{ 		public static IAppDomainWeb Web(this AppDomain appDomain) => new AppDomainWeb(appDomain); 	} 	class AppDomainWeb:IAppDomainWeb{ 		public AppDomain AppDomain{ get; }  		public AppDomainWeb(AppDomain appDomain) => AppDomain = appDomain; 	} 	public interface IAppDomainWeb{ 		AppDomain AppDomain{ get; } 	} }using System.Reflection; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.AssemblyExtensions {     public static partial class AssemblyExtensions {         public static Assembly EntryAssembly { get; set; } = Assembly.GetEntryAssembly();     } }using System; using System.IO; using System.Linq; using System.Reflection;  namespace Xpand.Extensions.AssemblyExtensions {     public static partial class AssemblyExtensions {         public static Stream GetManifestResourceStream(this Assembly assembly, Func<string, bool> nameMatch)             => assembly.GetManifestResourceStream(assembly.GetManifestResourceNames().First(nameMatch));     } }using System.Reflection; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.AssemblyExtensions {     public static partial class AssemblyExtensions {         public static string GetResourceString(this Assembly assembly, string name)              => assembly.GetManifestResourceStream(name).ReadToEndAsString();     } }using System; using System.Collections.Generic; using System.Linq; using System.Reflection;  namespace Xpand.Extensions.AssemblyExtensions {     public static partial class AssemblyExtensions {         public static IEnumerable<Type> GetTypesFromAssembly(this Assembly assembly) {             try {                 return assembly.GetTypes();             }             catch (ReflectionTypeLoadException e) {                 return e.Types.Where(type => type != null && type.IsVisible);             }         }     } }using System; using System.CodeDom.Compiler; using System.Collections.Generic; using System.Linq; using System.Reflection;  using Microsoft.CSharp;  namespace Xpand.Extensions.AssemblyExtensions{          public static partial class AssemblyExtensions {         public static Lazy<CSharpCodeProvider> CodeProvider { get; } = new Lazy<CSharpCodeProvider>(() => {             var csc = new CSharpCodeProvider();             var settings = csc                 .GetType()                 .GetField("_compilerSettings", BindingFlags.Instance | BindingFlags.NonPublic)                 ?.GetValue(csc);              var path = settings?.GetType()                 .GetField("_compilerFullPath", BindingFlags.Instance | BindingFlags.NonPublic);              path?.SetValue(settings, ((string)path.GetValue(settings)).Replace(@"bin\roslyn\", @"roslyn\"));              return csc;         });          public static Assembly NewAssembly(this AssemblyMetadata assemblyMetadata,params TypeMetadata[] typeParameters){                          var compilerParameters = new CompilerParameters{                 CompilerOptions = "/t:library",                 OutputAssembly = assemblyMetadata.OutputAssembly             };                          var codeProvider = CodeProvider.Value;             compilerParameters.ReferencedAssemblies.Add(typeof(object).Assembly.Location);             compilerParameters.ReferencedAssemblies.Add(typeof(AssemblyVersionAttribute).Assembly.Location);             var references = typeParameters.SelectMany(_ =>                 _.Properties.Select(parameter => parameter.Type.Assembly.Location).Concat(                     _.Properties.SelectMany(parameter =>                         parameter.Attributes.Select(attribute => attribute.GetType().Assembly.Location)))).Distinct();             compilerParameters.ReferencedAssemblies.AddRange(references.ToArray());             var code = $"{assemblyMetadata.AssemblyCode()}{Environment.NewLine}{typeParameters.TypesCode()}";              var compilerResults = codeProvider.CompileAssemblyFromSource(compilerParameters, code);             if (compilerResults.Errors.Count > 0){                 var message = string.Join(Environment.NewLine,                     compilerResults.Errors.Cast<CompilerError>().Select(error => error.ToString()));                 throw new Exception(message);             }             return compilerResults.CompiledAssembly;         }          private static string AssemblyCode(this AssemblyMetadata assemblyMetadata){             var version = assemblyMetadata.Version??new Version("1.0.0.0");             var versionCode = $@" [assembly:{typeof(AssemblyVersionAttribute).FullName}(""{version}"")] [assembly:{typeof(AssemblyFileVersionAttribute).FullName}(""{version}"")] ";             return $"{versionCode}{assemblyMetadata.Attributes.AttributesCode()}";         }          private static string TypesCode(this IEnumerable<TypeMetadata> typeParameters){             return string.Join(Environment.NewLine, typeParameters.Select(_ => _.TypeCode()));         }          private static string AttributesCode(this IEnumerable<Attribute> attributes){             return string.Join(Environment.NewLine, attributes.Select(AttributeCode));         }          private static string TypeCode(this TypeMetadata metadata){             return $@" public class {metadata.Name}{{     {metadata.Properties.PropertiesCode()} }} ";         }          private static string AttributeCode(this Attribute attribute){             return null;         }          private static string PropertiesCode(this IEnumerable<PropertyMetadata> parameters){             return string.Join(Environment.NewLine, parameters.Select(parameter => parameter.PropertyCode()));         }          private static string PropertyCode(this PropertyMetadata metadata){             return $"{metadata.Attributes.AttributesCode()}{Environment.NewLine}public {metadata.Type.FullName} {metadata.Name} {{get;{(metadata.CanWrite ? "set;" : null)}}}";         }     }          public class AssemblyMetadata{         public AssemblyMetadata(){             Attributes=new List<Attribute>();         }          public string OutputAssembly{ get; set; }         public Version Version{ get; set; }         public List<Attribute> Attributes{ get;  }     }          public class TypeMetadata{         public TypeMetadata(string name,params PropertyMetadata[] propertyParameters){             Name = name;             Properties=new List<PropertyMetadata>();             Properties.AddRange(propertyParameters);         }          public string Name{ get; set; }         public List<PropertyMetadata> Properties{ get; }     }          public class PropertyMetadata{         public PropertyMetadata(string name, Type type, bool canWrite, params Attribute[] attributes){             Name = name;             Type = type;             CanWrite = canWrite;             Attributes = new List<Attribute>(attributes);         }          public string Name{ get; set; }         public Type Type{ get; set; }         public bool CanWrite{ get; set; }         public List<Attribute> Attributes{ get;  }     }  }using System.Linq;   namespace Xpand.Extensions.AssemblyExtensions{     public static partial class AssemblyExtensions{                  public static string PublicKeyToken(this System.Reflection.AssemblyName assemblyName) => string.Join("", assemblyName.GetPublicKeyToken().Select(b => b.ToString("x2")));     } }using System;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {                  public static string BitConvert(this Byte[] bytes)              => BitConverter.ToString(bytes);     } }using System; using System.Security.Cryptography; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {         public static byte[] ComputeHash(this byte[] secret, string message, HashAlgorithm algorithm = null) {             algorithm ??= new HMACSHA256(secret);             return algorithm.ComputeHash(message.Bytes());         }     } }using System.Linq; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {         public static string GetHexString(this byte[] buff)              => buff.Select(b => b.ToString("X2")).Join("");     } }using System.Security.Cryptography; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {         public static string CryptoSign(this byte[] secret, string message,HashAlgorithm algorithm=null) => secret.ComputeHash(message,algorithm).GetHexString();     } }using System.IO;  namespace Xpand.Extensions.BytesExtensions{     public static partial class BytesExtensions{         public static void Save(this byte[] bytes, string path)              => File.WriteAllBytes(path, bytes);     } }using System;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {         public static string ToBase64String(this byte[] bytes) => Convert.ToBase64String(bytes);     } }using System.Text;  namespace Xpand.Extensions.BytesExtensions{ 	public static partial class BytesExtensions{ 		public static string GetString(this byte[] bytes, Encoding encoding = null){ 			if (bytes == null) { 				return null; 			} 			encoding ??= Encoding.UTF8; 			return encoding.GetString(bytes); 		} 		 	} }using System; using System.Collections.Generic; using System.Diagnostics.CodeAnalysis; using System.IO; using System.Net; using System.Runtime.InteropServices; using System.Security; using System.Security.Cryptography; using System.Text; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.BytesExtensions {     public static partial class BytesExtensions {         [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public static byte[] UnProtect(this DataProtectionScope? scope,byte[] bytes) {             if (scope!=null) {                 try { return bytes.UnProtect(scope.Value);}                 catch (CryptographicException) { }             }             return bytes;         }                  public static byte[] ToByteArray(this SecureString secureString)              => new NetworkCredential("", secureString).Password.Bytes();          public static T Process<T>(this SecureString secureString, Func<byte[], T> func) {             var bstr = IntPtr.Zero;             byte[] workArray = null;             GCHandle? handle = null;              try {                 bstr = Marshal.SecureStringToBSTR(secureString);                 unsafe {                     var bstrBytes = (byte*)bstr;                     workArray = new byte[secureString.Length * 2];                     handle = GCHandle.Alloc(workArray, GCHandleType.Pinned);                     for (var i = 0; i < workArray.Length; i++)                         workArray[i] = *bstrBytes++;                 }                 return func(workArray);             }             finally {                 if (workArray != null)                     for (var i = 0; i < workArray.Length; i++)                         workArray[i] = 0;                 handle?.Free();                 if (bstr != IntPtr.Zero)                     Marshal.ZeroFreeBSTR(bstr);             }         }           [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public static SecureString[] UnProtectSecuredString(this byte[] bytes,             DataProtectionScope scope = DataProtectionScope.LocalMachine) {             var strings = new List<SecureString>();             var unprotectedBytes = UnProtect(bytes, scope);             using var memory = new MemoryStream(unprotectedBytes);             using var reader = new BinaryReader(memory, Encoding.UTF8);              while (memory.Position != memory.Length) {                 var current = new SecureString();                 strings.Add(current);                 var len = reader.ReadInt32();                 while (len-- > 0) {                     current.AppendChar(reader.ReadChar());                 }             }              Array.Clear(bytes, 0, bytes.Length);             Array.Clear(unprotectedBytes, 0, unprotectedBytes.Length);             return strings.ToArray();         }          [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public static byte[] UnProtect(this byte[] bytes, DataProtectionScope scope=DataProtectionScope.LocalMachine)              => ProtectedData.Unprotect(bytes, null, scope);     }             }using System.IO; using System.Threading.Tasks; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.BytesExtensions{     public static partial class BytesExtensions{ 	    public static string Unzip(this byte[] bytes){             using var mso = new MemoryStream(bytes);             return mso.UnGzip();         }         public static Task<string> UnzipAsync(this byte[] bytes){             using var mso = new MemoryStream(bytes);             return mso.UnGzipAsync();         }     } }using System; using System.CodeDom.Compiler; using System.Linq;  namespace Xpand.Extensions.Compiler{     public static class CompilerExtensions{         public static void ReferenceNetStandard(this CompilerParameters parameters){             var netStandard = AppDomain.CurrentDomain.GetAssemblies()                 .FirstOrDefault(assembly => assembly.GetName().Name.Contains("netstandard"))?.Location;             if (netStandard != null){                 parameters.ReferencedAssemblies.Add(netStandard);             }         }     } }using System; using System.IO; using System.Linq; using Microsoft.CodeAnalysis; using Microsoft.CodeAnalysis.CSharp; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.Compiler{     public static class CodeCompiler {         public static MemoryStream Compile(this SyntaxTree syntaxTree, params string[] references){             var assemblies = AppDomain.CurrentDomain.GetAssemblies().Where(assembly =>                 new[]{"mscorlib", "netstandard", "System.Collections", "System.Runtime","System.Drawing","System.Private.CoreLib"}.Contains(assembly.GetName().Name));             var metadataReferences = assemblies.Select(assembly => assembly.Location).Concat(references)                 .Select(path => MetadataReference.CreateFromFile(path))                 .ToArray();             var memoryStream = new MemoryStream();             var cSharpCompilation = CSharpCompilation.Create(Guid.NewGuid().ToString(), new[]{syntaxTree},                 metadataReferences, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));             var emitResult = cSharpCompilation.Emit(memoryStream);             if(!emitResult.Success) {                 throw new InvalidOperationException(emitResult.Diagnostics.Select(diagnostic => diagnostic).Join(Environment.NewLine));             }             return memoryStream;         }     }  }using System; using System.Collections.Specialized; using System.Net; using System.Net.Mail;  namespace Xpand.Extensions.ConfigurationExtensions{     public static class ConfigurationExtensions{         public static SmtpClient NewSmtpClient(this NameValueCollection appSettings, string reportEnableSsl = "reportEnableSsl", string reportEmailPass = "reportEmailPass",             string reportEmail = "reportEmail", string reportEmailPort = "reportEmailPort", string reportEmailserver = "reportEmailserver"){             var smtpClient = new SmtpClient(appSettings[reportEmailserver]){                 Port = Convert.ToInt32(appSettings[reportEmailPort]),                 DeliveryMethod = SmtpDeliveryMethod.Network,                 UseDefaultCredentials = false,                 Credentials = new NetworkCredential(appSettings[reportEmail],                     appSettings[reportEmailPass]),                 EnableSsl = Convert.ToBoolean(appSettings[reportEnableSsl])             };             return smtpClient;         }      } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static IEnumerable<DateTime> Dates()              => Dates(DateTime.Today.Year);          public static IEnumerable<DateTime> Dates(this int year)              => Enumerable.Range(1, 12).SelectMany(month => Dates(year, month)).ToList();          public static IEnumerable<DateTime> Dates(int year, int month)              => Enumerable.Range(1, DateTime.DaysInMonth(year, month))                 .Select(day => new DateTime(year, month, day));     } }using System; using System.Threading; using System.Threading.Tasks;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static Task Delay(this TimeSpan timeSpan,CancellationToken token=default)              => Task.Delay(timeSpan, token);         public static Task Delay(this int millisec,CancellationToken token=default)              => Task.Delay(millisec, token);     } }using System;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static int Months(this TimeSpan timespan)             => (int) (timespan.Days / 30.436875);     } }using System;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static string RelativeDate(this DateTime theDate) {             var ts = new TimeSpan(DateTime.UtcNow.Ticks - theDate.Ticks);             double delta = Math.Abs(ts.TotalSeconds);              if (delta < 60) {                 return ts.Seconds == 1                     ? "one second ago"                     : ts.Seconds                       + " seconds ago";             }              if (delta < 120) {                 return "a minute ago";             }              if (delta < 2700) // 45 * 60             {                 return ts.Minutes + " minutes ago";             }              if (delta < 5400) // 90 * 60             {                 return "an hour ago";             }              if (delta < 86400) {                 // 24 * 60 * 60                 return ts.Hours + " hours ago";             }              if (delta < 172800) {                 // 48 * 60 * 60                 return "yesterday";             }              if (delta < 2592000) {                 // 30 * 24 * 60 * 60                 return ts.Days + " days ago";             }              if (delta < 31104000) {                 // 12 * 30 * 24 * 60 * 60                 int months = System.Convert.ToInt32(Math.Floor((double) ts.Days / 30));                 return months <= 1 ? "one month ago" : months + " months ago";             }              int years = System.Convert.ToInt32(Math.Floor((double) ts.Days / 365));             return years <= 1 ? "one year ago" : years + " years ago";         }     } }using System; using System.Globalization;  namespace Xpand.Extensions.DateTimeExtensions{     public static partial class DateTimeExtensions{         public static string ToRfc3339String(this DateTime dateTime)              => dateTime.ToString("yyyy-MM-dd'T'HH:mm:ss.fffzzz", DateTimeFormatInfo.InvariantInfo);     } }using System;  namespace Xpand.Extensions.DateTimeExtensions{     public static partial class DateTimeExtensions{         public static TimeSpan Abs(this TimeSpan timeSpan) =>timeSpan>System.TimeSpan.Zero?timeSpan:System.TimeSpan.Zero ;         public static DateTime UnixTimestampToDateTimeMilliSecond(this double unixTime) => UnixTimestampToDateTime(unixTime, System.TimeSpan.TicksPerMillisecond);          private static DateTime UnixTimestampToDateTime(double unixTime, long ticks){             var unixStart = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);             var unixTimeStampInTicks = (long) (unixTime * ticks);             return new DateTime(unixStart.Ticks + unixTimeStampInTicks, DateTimeKind.Utc);         }          public static double UnixTimestampFromDateTimeMilliseconds(this DateTime dateTime) {             var milliseconds = (dateTime - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalMilliseconds;             return milliseconds<0?0:milliseconds;         }     } }using System;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static TimeSpan TimeSpan(this long ticks)              => System.TimeSpan.FromTicks(ticks);                  public static DateTime UnixTimeStampToDateTime(this long unixTimeStamp)              => DateTimeOffset.FromUnixTimeMilliseconds(unixTimeStamp).UtcDateTime;                  private const decimal TicksPerNanosecond = System.TimeSpan.TicksPerMillisecond / 1000m / 1000;         public static DateTime UnixNanoSecondsTimeStampToDateTime(this long unixTimeStamp)              => new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc).AddTicks((long)Math.Round(unixTimeStamp * TicksPerNanosecond));     } }using System;  namespace Xpand.Extensions.DateTimeExtensions {     public static partial class DateTimeExtensions {         public static int Years(this TimeSpan timespan)              => (int) (timespan.Days / 365.2425);     } }using System; using System.ComponentModel;  namespace Xpand.Extensions.EventArgExtensions{     public class GenericEventArgs<T> : HandledEventArgs{         public GenericEventArgs(T instance) => Instance = instance;          public GenericEventArgs(){         }          public T Instance { get; private set; }          public bool SetInstance(Func<T,T> apply) {             Instance = apply(Instance);             return true;         }          // public void SetInstance(Action<T> apply) => apply(Instance);     } }using System; using System.Linq; using System.Reflection; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.ExceptionExtensions{     public static partial class ExceptionExtensions{         public static string GetAllInfo(this Exception exception){             if (exception is AggregateException aex){                 var flatten = aex.Flatten();                 return flatten.ToString();             }             var messages = exception.FromHierarchy(ex => ex.InnerException).Select(ex => {                 var s = ex.ToString();                 if (ex is ReflectionTypeLoadException reflectionTypeLoadException){                     s+=$"{Environment.NewLine}{string.Join(Environment.NewLine,reflectionTypeLoadException.LoaderExceptions.Select(_ => _.GetAllInfo()))}";                 }                 return s;             });             return string.Join(Environment.NewLine, messages);         }     } }using System; using System.Linq; using System.Net.Mail;  namespace Xpand.Extensions.ExceptionExtensions{     public static partial class ExceptionExtensions{         public static MailMessage ToMailMessage(this Exception exception, string email) => new MailMessage{                 From = new MailAddress(email), To = {email}, Body = exception.GetAllInfo(),                 Subject =                     $"{exception.GetType().Name}:{exception.Message.Split(Environment.NewLine.ToCharArray()).First()}"             };     } }using System; using System.Linq.Expressions;  namespace Xpand.Extensions.ExpressionExtensions {     public static partial class ExpressionExtensions {         public static Expression<Func<T, bool>> AndAlso<T>(             this Expression<Func<T, bool>> expr1,             Expression<Func<T, bool>> expr2) {             var parameter = Expression.Parameter(typeof(T));              var leftVisitor = new ReplaceExpressionVisitor(expr1.Parameters[0], parameter);             var left = leftVisitor.Visit(expr1.Body);              var rightVisitor = new ReplaceExpressionVisitor(expr2.Parameters[0], parameter);             var right = rightVisitor.Visit(expr2.Body);              return Expression.Lambda<Func<T, bool>>(Expression.AndAlso(left!, right!), parameter);         }          private class ReplaceExpressionVisitor             : ExpressionVisitor {             private readonly Expression _oldValue;             private readonly Expression _newValue;              public ReplaceExpressionVisitor(Expression oldValue, Expression newValue) {                 _oldValue = oldValue;                 _newValue = newValue;             }              public override Expression Visit(Expression node) {                 if (node == _oldValue)                     return _newValue;                 return base.Visit(node);             }         }     } }using System; using System.Linq.Expressions;  namespace Xpand.Extensions.ExpressionExtensions{     public static partial class ExpressionExtensions{         public static string MemberExpressionName<TObject>(this Expression<Func<TObject, object>> memberName) =>             memberName.Body is UnaryExpression unaryExpression                 ? ((MemberExpression) unaryExpression.Operand).Member.Name                 : ((MemberExpression) memberName.Body).Member.Name;                  public static string MemberExpressionName<TObject,TMemberValue>(this Expression<Func<TObject, TMemberValue>> memberName) =>             memberName.Body is UnaryExpression unaryExpression                 ? ((MemberExpression) unaryExpression.Operand).Member.Name                 : ((MemberExpression) memberName.Body).Member.Name;     } }using System; using System.Linq; using Fasterflect;  namespace Xpand.Extensions.Fasterflect {     public static class FasterflectExtensions {         public static T CreateInstance<T>(this Type type,params object[] parameters) {             if (type.IsArray&&!parameters.Any()) {                 parameters = new object[]{0};             }             return (T)type.CreateInstance(parameters);         }     } }using System; using System.IO;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static FileInfo EnsurePath(this FileInfo fileInfo,bool randomizeAlways=false)             => !fileInfo.IsFileLocked()&&!randomizeAlways ? fileInfo                 : new FileInfo($"{fileInfo.DirectoryName}/{fileInfo.Name}_{Guid.NewGuid():N}{fileInfo.Extension}");     } }using System.IO; using System.Linq;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static string GetParentFolder(this DirectoryInfo directoryInfo, string folderName) {             folderName = folderName.ToLower();             while (directoryInfo != null &&                    directoryInfo.GetDirectories().All(info => info.Name.ToLower() != folderName)) {                 directoryInfo = directoryInfo.Parent;             }              return directoryInfo?.GetDirectories().First(info => info.Name.ToLower() == folderName).FullName;         }     } }using System.IO;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static bool IsFileLocked(this FileInfo file) {             FileStream stream = null;             if (!file.Exists) {                 return false;             }             try {                 stream = file.Open(FileMode.Open, FileAccess.Read, FileShare.None);             }             catch (IOException) {                 return true;             }             finally {                 stream?.Close();             }              return false;         }     } }using System.Diagnostics; using System.IO;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static Process SelectInExplorer(this FileInfo file)              => Process.Start("explorer.exe", "/select, \"" + file.FullName + "\"");     } }using System.IO;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static DirectoryInfo ParentExists(this DirectoryInfo directoryInfo) {             do {                 directoryInfo = directoryInfo?.Parent;             } while (!Directory.Exists(directoryInfo?.Parent?.FullName));              return directoryInfo;         }     } }using System.IO;  namespace Xpand.Extensions.FileExtensions {     public static partial class FileExtensions {         public static string ReadAllText(this FileInfo info)              => File.ReadAllText(info.FullName);         public static byte[] ReadAllBytes(this FileInfo info)              => File.ReadAllBytes(info.FullName);     } }using System.Reflection; using HarmonyLib;  namespace Xpand.Extensions.Harmony {     public static partial class HarmonyExtensions {         public static void Finalize(this HarmonyMethod harmonyMethod, MethodInfo method)             => method.PatchWith(finalizer: harmonyMethod);     } }using System.Collections.Concurrent; using System.Reflection; using HarmonyLib;  namespace Xpand.Extensions.Harmony {     public static partial class HarmonyExtensions { 	    private static HarmonyLib.Harmony _harmony; 	    private static readonly ConcurrentDictionary<string,MethodInfo> PatchedMethods = new(); 	    public static void PatchWith(this MethodInfo method, HarmonyMethod prefix = null, 		    HarmonyMethod postFix = null, HarmonyMethod transpiler = null,HarmonyMethod finalizer = null) {             _harmony ??= new HarmonyLib.Harmony("XAF"); 		    var methodName = $"{method.DeclaringType?.FullName}{method.Name}"; 		    if (!PatchedMethods.TryGetValue(methodName, out _)) { 			    PatchedMethods.TryAdd(methodName, method); 			    _harmony.Patch(method, prefix, postFix, transpiler,finalizer); 		    } 	    }     } }using System.Reflection; using HarmonyLib;  namespace Xpand.Extensions.Harmony {     public static partial class HarmonyExtensions {         public static void PostFix(this HarmonyMethod harmonyMethod, MethodInfo method)             => method.PatchWith(postFix: harmonyMethod);     } }using System.Reflection; using HarmonyLib;  namespace Xpand.Extensions.Harmony {     public static partial class HarmonyExtensions {         public static void PreFix(this HarmonyMethod harmonyMethod, MethodInfo method)              => method.PatchWith(harmonyMethod);     } }using System.Reflection; using HarmonyLib;  namespace Xpand.Extensions.Harmony {     public static partial class HarmonyExtensions {         public static void Transpile(this HarmonyMethod harmonyMethod, MethodInfo method)             => method.PatchWith(transpiler: harmonyMethod);     } }using System; using System.Runtime.InteropServices;  namespace Xpand.Extensions.IntPtrExtensions {     public static partial class IntPtrExtensions {         [DllImport("user32.dll")]         private static extern IntPtr GetForegroundWindow();         [DllImport("user32.dll")]         static extern uint GetWindowThreadProcessId(IntPtr hWnd, IntPtr processId);         [DllImport("user32.dll")]         static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, bool fAttach);         public static void ForceWindowToForeGround(this IntPtr handle) {             var activeWindowHandle = GetForegroundWindow();             var activeWindowThread = GetWindowThreadProcessId(activeWindowHandle, IntPtr.Zero);             var thisWindowThread = GetWindowThreadProcessId(handle, IntPtr.Zero);             AttachThreadInput(activeWindowThread, thisWindowThread, true);             AttachThreadInput(activeWindowThread, thisWindowThread, false);         }     } }using System; using System.ComponentModel; using System.Diagnostics; using System.Runtime.InteropServices;  namespace Xpand.Extensions.IntPtrExtensions{     public static partial class IntPtrExtensions{         public static Process ParentProcess(this IntPtr handle){             var pbi = new ProcessInformation();             var status = NtQueryInformationProcess(handle, 0, ref pbi, Marshal.SizeOf(pbi), out _);             if (status != 0) throw new Win32Exception(status);             try{                 return Process.GetProcessById(pbi.InheritedFromUniqueProcessId.ToInt32());             }             catch (ArgumentException){                 return null;             }         }          [DllImport("ntdll.dll")]         private static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass,             ref ProcessInformation processInformation, int processInformationLength, out int returnLength);                  [StructLayout(LayoutKind.Sequential)]         public struct ProcessInformation{             internal IntPtr Reserved1;             internal IntPtr PebBaseAddress;             internal IntPtr Reserved2_0;             internal IntPtr Reserved2_1;             internal IntPtr UniqueProcessId;             internal IntPtr InheritedFromUniqueProcessId;         }     } }using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Text.Json.Nodes; using System.Threading.Tasks; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.StringExtensions; using JsonSerializer = System.Text.Json.JsonSerializer;  namespace Xpand.Extensions.JsonExtensions {     public static partial class JsonExtensions {         public static IEnumerable<JsonNode> Descendants(this JsonNode root) => root.DescendantsAndSelf(false);          public static IEnumerable<JsonNode> DescendantsAndSelf(this JsonNode root, bool includeSelf = true)              => root.DescendantItemsAndSelf(includeSelf).Select(i => i.node);                  public static IEnumerable<(JsonNode node, int? index, string name, JsonNode parent)> DescendantItemsAndSelf(this JsonNode root, bool includeSelf = true) =>              (node: root, index: (int?)null, name: (string)null, parent: (JsonNode)null).Traverse((i) => i.node switch {                     JsonObject o => o.AsDictionary().Select(p => (p.Value, (int?)null, p.Key.AsNullableReference(), i.node.AsNullableReference())),                     JsonArray a => a.Select((item, index) => (item, index.AsNullableValue(), (string)null, i.node.AsNullableReference())),                     _ => Enumerable.Empty<(JsonNode node, int? index, string name, JsonNode parent)>(),                 }, includeSelf);                  static T AsNullableReference<T>(this T item) where T : class => item;         static T? AsNullableValue<T>(this T item) where T : struct => item;         static IDictionary<string, JsonNode> AsDictionary(this JsonObject o) => o;         public static JsonNode ToJsonNode(this object instance) => instance==null?null:JsonSerializer.SerializeToNode(instance);         public static JsonDocument ToJsonDocument(this string json) => json.Bytes().ToJsonDocument();         public static JsonDocument ToJsonDocument(this byte[] bytes) => bytes==null?null:JsonDocument.Parse(bytes);         public static Task<JsonDocument> ToJsonDocumentAsync(this Stream stream)              => stream==null?null:JsonDocument.ParseAsync(stream);         public static async Task<T> DeserializeJson<T>(this HttpResponseMessage message)              => (await message.Content.ReadAsByteArrayAsync()).Deserialize<T>();                  public static async Task<object[]> DeserializeJson(this HttpResponseMessage message,Type returnType)              => (await message.Content.ReadAsByteArrayAsync()).DeserializeJson(returnType).ToArray();          public static JsonNode DeserializeJsonNode(this byte[] bytes,JsonSerializerOptions options=null) {             var utf8Reader = new Utf8JsonReader(bytes);             utf8Reader.Read();             var isArray = utf8Reader.TokenType == JsonTokenType.StartArray;             utf8Reader = new Utf8JsonReader(bytes);             return !isArray ? JsonSerializer.Deserialize<JsonObject>(ref utf8Reader, options)!                 : new JsonArray(JsonSerializer.Deserialize<JsonObject[]>(ref utf8Reader, options)!.Cast<JsonNode>().ToArray()!);         }          public static T Deserialize<T>(this byte[] bytes,JsonSerializerOptions options=null) {             var utf8Reader = new Utf8JsonReader(bytes);             return JsonSerializer.Deserialize<T>(ref utf8Reader,options);         }         public static IEnumerable<object> DeserializeJson(this byte[] bytes,Type objectType,JsonSerializerOptions options=null) {             var utf8Reader = new Utf8JsonReader(bytes);             utf8Reader.Read();             var needsFlatten = utf8Reader.TokenType == JsonTokenType.StartArray && !objectType.IsArray;             return needsFlatten ? JsonSerializer.Deserialize(ref utf8Reader, objectType.MakeArrayType(), options).Cast<IEnumerable<object>>()                 : JsonSerializer.Deserialize(ref utf8Reader, objectType, options).YieldItem();         }         public static string Serialize<T>(this T value,JsonSerializerOptions options=null)               => JsonSerializer.Serialize(value,options);         public static JsonNode SerializeToNode(this object value,JsonSerializerOptions options=null)               => JsonSerializer.SerializeToNode(value,options);                   public static T Deserialize<T>(this string source, JsonSerializerOptions options = null)             => source.Bytes().Deserialize<T>(options);          public static JsonNode DeserializeJsonNode(this string source, JsonSerializerOptions options = null)              => source.Bytes().DeserializeJsonNode(options);          public static bool IsJsonStartValid(this string source) {             if (source.Length <= 0) return false;             var substring = source.Substring(0,1);             return new[]{"{","["}.Any(s => s==substring);         }                  public static JsonArray ToJsonArray(this JsonNode node)              => node as JsonArray ?? new JsonArray(node);                  public static IEnumerable<JsonObject> ToJsonObjects(this JsonNode jsonNode)              => jsonNode.ToJsonArray().Cast<JsonObject>();               } }using System; using System.Collections.Generic; using System.Linq; using System.Runtime.CompilerServices; using System.Text.Json; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.JsonExtensions {     public static partial class JsonExtensions {          public static IEnumerable<JsonElement> SelectMany(this JsonDocument document,bool dispose=false)              => document.RootElement.SelectMany().Finally(() => {                  if (dispose) {                      document.Dispose();                  }              });          public static IEnumerable<JsonElement> SelectMany(this JsonElement jsonElement)               => jsonElement.ValueKind == JsonValueKind.Array ? jsonElement.EnumerateArrayUnboxed() : jsonElement.YieldItem();           public static IEnumerable<JsonElement> EnumerateArrayUnboxed(this JsonElement tokenOrArray) {              using var enumerator = tokenOrArray.EnumerateArray();              while (enumerator.MoveNext()) {                  yield return enumerator.Current;              }          }          public static IEnumerable<JsonElement> EnumerateArray(this JsonElement tokenOrArray,string propertyName)               => tokenOrArray.GetProperty(propertyName).EnumerateArrayUnboxed();           public static IEnumerable<JsonProperty> EnumerateObjectUnboxed(this JsonElement tokenOrArray,[CallerMemberName]string caller="") {              using var enumerator = tokenOrArray.EnumerateObject();              while (enumerator.MoveNext()) {                  yield return enumerator.Current;              }          }           public static IEnumerable<JsonProperty> GetProperties(this JsonElement element, string name) {              using var enumerator = element.GetProperty(name).EnumerateObject();              while (enumerator.MoveNext()) {                  yield return enumerator.Current;              }          }           public static T GetPropertyValue<T>(this JsonElement element, ReadOnlySpan<char> currentProperty,              ReadOnlySpan<char> remainingProperties = default,Func<T> defaultValue=default,[CallerMemberName]string caller="")               => element.GetPropertyValue(currentProperty,defaultValue,remainingProperties,caller);                           public static ReadOnlySpan<char> GetPropertyValueAsSpan(this JsonElement element, ReadOnlySpan<char> propertyName)               => element.TryGetProperty(propertyName, out JsonElement property) &&                 property.ValueKind == JsonValueKind.String ? property.GetString().AsSpan() : ReadOnlySpan<char>.Empty;                           public static ReadOnlyMemory<char> GetPropertyValueAsMemory(this JsonElement element, ReadOnlySpan<char> propertyName)              => element.TryGetProperty(propertyName, out JsonElement property) &&                 property.ValueKind == JsonValueKind.String ? property.GetString().AsMemory() : ReadOnlyMemory<char>.Empty;            public static T GetPropertyValue<T>(this JsonElement element, ReadOnlySpan<char> currentProperty,Func<T> defaultValue,              ReadOnlySpan<char> remainingProperties = default,[CallerMemberName]string caller="") {              defaultValue ??= () => default;              if (currentProperty.IsEmpty) return defaultValue();              var dotIndex = remainingProperties.IndexOf('.');              var nextProperty = dotIndex == -1 ? remainingProperties : remainingProperties.Slice(0, dotIndex);              var nextRemainingProperties = dotIndex == -1 ? ReadOnlySpan<char>.Empty : remainingProperties.Slice(dotIndex + 1);              if (!element.TryGetProperty(currentProperty, out var property)) return defaultValue();              if (nextProperty.IsEmpty) {                  switch (property.ValueKind){                      case JsonValueKind.Number when typeof(T) == typeof(int):                          return (T)(object)property.GetInt32();                      case JsonValueKind.Number when typeof(T) == typeof(decimal):                          return (T)(object)property.GetDecimal();                      case JsonValueKind.Number when typeof(T) == typeof(double):                          return (T)(object)property.GetDouble();                      case JsonValueKind.Number when typeof(T) == typeof(float):                          return (T)(object)property.GetSingle();                      case JsonValueKind.Number when typeof(T) == typeof(long):                          return (T)(object)property.GetInt64();                      case JsonValueKind.Number when typeof(T) == typeof(ushort):                          return (T)(object)property.GetUInt16();                      case JsonValueKind.Number when typeof(T) == typeof(uint):                          return (T)(object)property.GetUInt32();                      case JsonValueKind.Number when typeof(T) == typeof(ulong):                          return (T)(object)property.GetUInt64();                      case JsonValueKind.String when typeof(T) == typeof(string):                          return (T)(object)property.GetString();                      case JsonValueKind.True when typeof(T) == typeof(bool):                          return (T)(object)true;                      case JsonValueKind.False when typeof(T) == typeof(bool):                          return (T)(object)false;                  }              }              return property.GetPropertyValue<T>(nextProperty, remainingProperties:nextRemainingProperties);          }     } }using System.Collections.Generic; using System.Text.Json; using System.Text.Json.Nodes;  namespace Xpand.Extensions.JsonExtensions {     public static partial class JsonExtensions {         public static byte[] Utf8Bytes(this JsonArray array, JsonSerializerOptions options = null)             => JsonSerializer.SerializeToUtf8Bytes(array, options);     } }using System.Collections.Generic; using System.Text.Json; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.JsonExtensions {     public static partial class JsonExtensions {         public static IEnumerable<JsonElement> YieldJsonElementArray(this JsonElement jsonElement)              => jsonElement.ValueKind == JsonValueKind.Array ? jsonElement.EnumerateArrayUnboxed() : jsonElement.YieldItem();     } }using System; using System.Collections.Generic; using System.Linq; using System.Runtime.CompilerServices;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions {         public static TValue GetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, Func<TValue> valueCreator,[CallerMemberName]string caller="") {             if (!dictionary.TryGetValue(key, out var value)) {                 value = valueCreator();                 dictionary.Add(key, value);             }             return value;         }          public static TValue GetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key) where TValue : new()              => dictionary.GetOrAdd(key, () => new());          public static IEnumerable<T> DoWhen<T>(this IEnumerable<T> source, Func<T,bool> when,Action<T> action)              => source.Do(obj => {                 if (when(obj)) {                     action(obj);                 }             });         public static IEnumerable<T> DoWhenFirst<T>(this IEnumerable<T> source, Action<T> action)              => source.Select((arg1, i) => {                 if (i == 0) {                     action(arg1);                 }                  return arg1;             });         public static IEnumerable<T> DoWhen<T>(this IEnumerable<T> source, Func<T,int,bool> when,Action<T> action)              => source.Select((arg1, i) => {                 if (when(arg1,i)) {                     action(arg1);                 }                  return arg1;              });         public static IEnumerable<T> ExactType<T>(this IEnumerable<object> source)              => source.OfType<T>().Where(arg => arg.GetType()==typeof(T));                  public static IEnumerable<object> ExactType(this IEnumerable<object> source,Type objectType)              => source.Where(arg => arg.GetType()==objectType);                  public static IEnumerable<T> ExactType<T>(this IEnumerable<T> source,Type objectType)              => source.Where(arg => arg.GetType()==objectType);          public static T[] AddRange<T>(this IEnumerable<T> source,IEnumerable<T> enumerable,bool ignoreDuplicates=false)              => source is IList<T> list                     ? enumerable.Where(arg => !ignoreDuplicates || !source.Contains(arg)).Execute(list.Add).ToArray()                     : source.AddToArray(enumerable, ignoreDuplicates);                  public static T[] AddToArray<T>(this IEnumerable<T> source, T item, bool ignoreDuplicates = false) {             var enumerable = source as T[] ?? source.ToArray();             return !ignoreDuplicates && enumerable.Any(arg => arg.Equals(item))                 ? enumerable : enumerable.Concat(item.YieldItem()).ToArray();         }          public static T[] AddToArray<T>(this IEnumerable<T> source, IEnumerable<T> items, bool ignoreDuplicates = false)              => items.SelectMany(arg => source.AddToArray(arg, ignoreDuplicates)).ToArray();          public static T Add<T>(this IList<T> source, T item, bool ignoreDuplicates = false) {             if (!ignoreDuplicates || !source.Contains(item)) {                 source.Add(item);                 return item;             }              return default;         }                  } }using System.Collections; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerator<T> Cast<T>(this IEnumerator iterator) {             while (iterator.MoveNext()) {                 yield return (T) iterator.Current;             }         }     } }using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<(T current, T previous)> CombineWithPrevious<T>(this IEnumerable<T> source) {             var enumerable = source as T[] ?? source.ToArray();             return (enumerable.FirstOrDefault(), default(T)).YieldItem()                 .Concat(enumerable.Skip(1).Select((current, i) => (current, previous: enumerable[i])));         }     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<TSource> DistinctWith<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector){             var seenKeys = new HashSet<TKey>();             return source.Where(element => seenKeys.Add(keySelector(element)));         }      } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<TSource> Execute<TSource>(this IEnumerable<TSource> source, Action<TSource> action)             => source.Select(source1 => {                 action(source1);                 return source1;             });     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static T First<T>(this IEnumerable<T> source, Func<string> exceptionMessage)             => source.FirstOrDefault() ?? throw new InvalidOperationException(exceptionMessage());         public static T First<T>(this IEnumerable<T> source,Func<T,bool> predicate, Func<string> exceptionMessage)             => source.FirstOrDefault(predicate) ?? throw new InvalidOperationException(exceptionMessage());     } }using System; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<TSource> FromHierarchy<TSource>(this TSource source, Func<TSource, TSource> nextItem) where TSource : class              => source.FromHierarchy( nextItem, s => s != null);          public static IEnumerable<TSource> FromHierarchy<TSource>(this TSource source, Func<TSource, TSource> nextItem, Func<TSource, bool> canContinue){             for (var current = source; canContinue(current); current = nextItem(current)) yield return current;         }     } }using System; using System.Collections; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<T> GetItems<T>(this IEnumerable collection,Func<T, IEnumerable> selector,Func<T,object> distinctSelector=null) {             HashSet<object> hashSet=null;             if (distinctSelector!=null){                 hashSet=new HashSet<object>();             }             var stack = new Stack<IEnumerable<T>>();             stack.Push(collection.OfType<T>());              while (stack.Count > 0) {                 var items = stack.Pop();                 foreach (var item in items){                     var o = distinctSelector?.Invoke(item);                     if (hashSet != null ){                         if (!hashSet.Contains(o)){                             hashSet.Add(o);                             yield return item;                             var children = selector(item).OfType<T>();                             stack.Push(children);                         }                     }                     else{                         yield return item;                         var children = selector(item).OfType<T>();                         stack.Push(children);                     }                                      }             }         }     } }using System; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions{ 		public static int GetValidIndex<T>(this IList<T> array, int index){ 			return Math.Max(0, Math.Min(index, array.Count - 1)); 		} 	} }using System; using System.Collections; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IGrouping<TK, TV> AsGroup<TK, TV>(this IEnumerable<TV> source, TK key)              => Create(key, source);          private static IGrouping<TK, TV> Create<TK, TV>(TK key, IEnumerable<TV> source)              => new SimpleGroupWrapper<TK, TV>(key, source);          internal class SimpleGroupWrapper<TK, TV> : IGrouping<TK, TV>{             private readonly IEnumerable<TV> _source;              public SimpleGroupWrapper(TK key, IEnumerable<TV> source){                 _source = source ?? throw new NullReferenceException("source");                 Key = key;             }              public TK Key{ get; }              public IEnumerator<TV> GetEnumerator() => _source.GetEnumerator();              IEnumerator IEnumerable.GetEnumerator() => _source.GetEnumerator();         }     } }using System; using System.Collections.Generic; using System.Collections.Specialized;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         private class KeyValuesPair {             public string Name { get; set; }             public string[] Values { get; set; }         }          public static void Insert(this NameValueCollection col, int index, string name, string value) {             if (index < 0 || index > col.Count)                 throw new ArgumentOutOfRangeException();              if (col.GetKey(index) == value) {                 col.Add(name, value);             }             else {                 List<KeyValuesPair> items = new List<KeyValuesPair>();                 int size = col.Count;                 for (int i = index; i < size; i++) {                     string key = col.GetKey(index);                     items.Add(new KeyValuesPair {                         Name = key,                         Values = col.GetValues(index),                     });                     col.Remove(key);                 }                  col.Add(name, value);                  foreach (var item in items) {                     foreach (var v in item.Values) {                         col.Add(item.Name, v);                     }                 }             }         }     } } using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions{ 		public static bool IsValidIndex<T>(this IList<T> array, int index){ 			return array != null && index >= 0 && index < array.Count; 		} 	} }using System; using System.Collections; using System.Collections.Generic; using System.Linq; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions { 		public static string JoinString(this IEnumerable source)  			=> source is string s ? s.JoinString(null) : source.Join(null);  		public static string JoinString(this object source, params object[] objects)  			=> objects.Prepend(source).Join(null); 		public static string JoinString(this object source, params string[] objects)  			=> objects.Prepend(source).Join(null);  		public static string Join(this IEnumerable source, string separator)  			=> source is IEnumerable<string> strings ? strings.Join(separator) 				: source.Cast<object>().Select(o => o.EnsureString()).Join(separator); 		 		public static string Join(this IEnumerable source)  			=> source.Join(null);  		public static string JoinNewLine(this IEnumerable source) => source?.Join(Environment.NewLine); 		public static string JoinSpace(this IEnumerable source) => source?.Join(" "); 		public static string JoinComma(this IEnumerable source) => source?.Join(","); 		public static string JoinDot(this IEnumerable source) => source?.Join("."); 		public static string JoinCommaSpace(this IEnumerable source) => source?.Join(", "); 		public static string JoinDotSpace(this IEnumerable source) => source?.Join(". "); 		 		public static string Join(this IEnumerable<string> values, string separator) 			=> string.Join(separator, values);   	}  	 }using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<(TSource source, TValue other)> Pair<TSource, TValue>(             this IEnumerable<TSource> source, TValue value)             => source.Select(_ => (_, value));                  public static IEnumerable<(TSource source, TValue other)> Pairs<TSource, TValue>(             this Dictionary<TSource,TValue> source)             => source.Select(_ => (_.Key, _.Value));     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions{ 		public static IEnumerable<T> Repeat<T>(this IEnumerable<T> source){ 			for (;;) 				foreach (var item in source.ToArray()) 					yield return item; 		} 	} }using System; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<TU> Scan<T, TU>(this IEnumerable<T> input, Func<TU, T, TU> next, TU state) {             yield return state;             foreach (var item in input) {                 state = next(state, item);                 yield return state;             }         }     } }using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<TSource> SelectMany<TSource>(this IEnumerable<IEnumerable<TSource>> source)              => source.SelectMany(sources => sources);                       } }using System; using System.Collections.Generic; using System.Security.Cryptography;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {                  public static IList<T> Shuffle<T>(this IList<T> list) {             using var generator = RandomNumberGenerator.Create();             var n = list.Count;             while (n > 1) {                 var box = new byte[1];                 do generator.GetBytes(box);                 while (!(box[0] < n * (Byte.MaxValue / n)));                 var k = (box[0] % n);                 n--;                 (list[k], list[n]) = (list[n], list[k]);             }              return list;         }} }using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<T> SkipLastN<T>(this IEnumerable<T> source, int n) {             using var it = source.GetEnumerator();             bool hasRemainingItems;             var cache = new Queue<T>(n + 1);              do{                 var b = hasRemainingItems = it.MoveNext();                 if (b){                     cache.Enqueue(it.Current);                     if (cache.Count > n)                         yield return cache.Dequeue();                 }             } while (hasRemainingItems);         }     } }using System;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static T[] Slice<T>(this T[] source, int index, int length) {             var slice = new T[length];             Array.Copy(source, index, slice, 0, length);             return slice;         }         public static T[] Slice<T>(this T[] source, int length)              => source.Slice(0, length);     } }using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<IEnumerable<T>> Split<T>(this IEnumerable<T> list, int parts){             var i = 0;             return list.GroupBy(_ => i++ % parts).Select(part => part.AsEnumerable());         }     } }using System.Collections.Generic; using Swordfish.NET.Collections.Auxiliary;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static void Subscribe<T>(this IEnumerable<T> list)             => list.ForEach(_ => { });     } }using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static void Swap<T>(this IList<T> list, int i, int j) => (list[i], list[j]) = (list[j], list[i]);     } }using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{ 	    public static IEnumerable<T> TakeAllButLast<T>(this IEnumerable<T> source){             using (var it = source.GetEnumerator()){                 bool hasRemainingItems;                 var isFirst = true;                 T item = default;                 do{                     hasRemainingItems = it.MoveNext();                     if (hasRemainingItems){                         if (!isFirst) yield return item;                         item = it.Current;                         isFirst = false;                     }                 } while (hasRemainingItems);             }         }     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions{ 		public static IEnumerable<T> TakeLast<T>(this IEnumerable<T> source) => new []{source.Last()}; 		public static IEnumerable<T> TakeLast<T>(this T[] source, int n) => source.Skip(Math.Max(0, source.Length - n)); 	} }using System; using System.Collections.Generic; using System.Linq; using Fasterflect; using HarmonyLib;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<TValue> To<TSource,TValue>(this IEnumerable<TSource> source,TValue value)              => source.Select(_ => value);          public static IEnumerable<T> To<T>(this IEnumerable<object> source,bool newInstance=false)              => source.Select(_ =>!newInstance? default:(T)typeof(T).CreateInstance()).WhereNotDefault();          public static IEnumerable<T> To<TResult,T>(this IEnumerable<TResult> source)              => source.Select(_ => default(T)).WhereNotDefault();              } }using System; using System.Collections; using System.Collections.Generic; using System.ComponentModel; using System.Linq; using Fasterflect;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static BindingList<T> ToBindingList<T>(this IEnumerable<T> source)              => new((IList<T>) (source as IList ?? source.ToList()));          public static IBindingList ToBindingList(this IEnumerable<object> source,Type objectType) {             var bindingList = (IBindingList) typeof(BindingList<>).MakeGenericType(objectType).CreateInstance();             foreach (object o in source) {                 bindingList.Add(o);             }             return bindingList;         }     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static Dictionary<TKey, TValue> ToOrderedDictionary<TKey, TValue>(             this IEnumerable<(TKey key, TValue value)> source, Func<TKey, TValue, TValue> orderBySelector)             => source.OrderBy(t => orderBySelector(t.key, t.value)).ToDictionary(t => t.key, t => t.value);                  public static Dictionary<TKey, TValue> ToOrderedDictionary<TKey, TValue>(this IEnumerable<(TKey key, TValue value)> source)             => source.OrderBy(t => t.key).ToDictionary(t => t.key, t => t.value);                  public static Dictionary<TKey, TValue> ToDictionary<TKey, TValue>(this IEnumerable<(TKey key, TValue value)> source)              => source.ToDictionary(t => t.key, t => t.value);                  public static ConcurrentDictionary<TKey, TElement> ToConcurrentDictionary<TSource, TKey, TElement>(             this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector) where TKey : notnull              => source.ToConcurrentDictionary(keySelector, elementSelector, EqualityComparer<TKey>.Default);          public static ConcurrentDictionary<TKey, TElement> ToConcurrentDictionary<TSource, TKey, TElement>(             this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector,IEqualityComparer<TKey> comparer) where TKey : notnull {             var concurrentDictionary = new ConcurrentDictionary<TKey, TElement>(comparer);             foreach (var item in source.ToArray()) {                 concurrentDictionary.TryAdd(keySelector(item), elementSelector(item));             }             return concurrentDictionary;         }                  public static ConcurrentDictionary<TKey, TLink> ToConcurrentDictionary<TKey,TLink>(this IEnumerable<TLink> source,Func<TLink,TKey> key)               => source.ToConcurrentDictionary(key, link => link);                  public static ConcurrentDictionary<TKey, TLink> ToConcurrentDictionary<TKey,TLink>(this IEnumerable<TLink> source,Func<TLink,TKey> key,IEqualityComparer<TKey> comparer)               => source.ToConcurrentDictionary(key, link => link,comparer);                  public static Dictionary<TKey, TLink> ToDictionary<TKey,TLink>(this IEnumerable<TLink> source,Func<TLink,TKey> key)              => source.ToDictionary(key, link => link);                  public static Dictionary<TKey, TLink> ToDictionary<TKey,TLink>(this IEnumerable<TLink> source,Func<TLink,TKey> key,IEqualityComparer<TKey> comparer)              => source.ToDictionary(key, link => link,comparer);     } }using System; using System.Collections.Generic; using System.Collections.Specialized; using System.Linq;   namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static string ToQueryString(this NameValueCollection nvc) {             if (nvc == null) return string.Empty;             var queryParameters = new List<string>();             foreach (string key in nvc.Keys) {                 if (string.IsNullOrWhiteSpace(key)) continue;                 var values = nvc.GetValues(key);                 if (values == null) continue;                 queryParameters.AddRange(values.Select(value => Uri.EscapeDataString(key).JoinString("=", Uri.EscapeDataString(value))));             }             return queryParameters.Count == 0 ? string.Empty : queryParameters.Join("&");         }     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<List<T>> ToRuns<T, TKey>(this IEnumerable<T> source, Func<T, TKey> keySelector){             using (var enumerator = source.GetEnumerator()){                 if (!enumerator.MoveNext())                     yield break;                  var currentSet = new List<T>();                 var lastKey = keySelector(enumerator.Current);                 currentSet.Add(enumerator.Current);                  while (enumerator.MoveNext()){                     var newKey = keySelector(enumerator.Current);                     if (!Equals(newKey, lastKey)){                         yield return currentSet;                         lastKey = newKey;                         currentSet = new List<T>();                     }                      currentSet.Add(enumerator.Current);                 }                  yield return currentSet;             }         }      } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static SortedDictionary<TKey, TValue> ToSortedDictionary<TSource, TKey, TValue>(             this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TValue> elementSelector) where TKey : notnull             => new(source.ToDictionary(keySelector, elementSelector));     } }using System; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<T> Traverse<T>(this T root, Func<T, IEnumerable<T>> children, bool includeSelf = true) {             if (includeSelf)                 yield return root;             var stack = new Stack<IEnumerator<T>>();             try {                 stack.Push(children(root).GetEnumerator());                 while (stack.Count != 0) {                     var enumerator = stack.Peek();                     if (!enumerator.MoveNext()) {                         stack.Pop();                         enumerator.Dispose();                     }                     else {                         yield return enumerator.Current;                         stack.Push(children(enumerator.Current).GetEnumerator());                     }                 }             }             finally {                 foreach (var enumerator in stack)                     enumerator.Dispose();             }         }     } }using System; using System.Collections.Concurrent; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{ 	public static partial class LinqExtensions{ 		public static TValue TryUpdate<TKey, TValue>(this ConcurrentDictionary<TKey, TValue> dict, TKey key, Func<TValue, TValue> updateFactory) { 			while(dict.TryGetValue(key, out var curValue)) { 				if(dict.TryUpdate(key, updateFactory(curValue), curValue)) 					return curValue; 			} 			return default; 		}  		public static TValue Update<TKey, TValue>(this ConcurrentDictionary<TKey, TValue> dict, TKey key, Func<TValue, TValue> updateFactory) 			=> dict.TryUpdate(key, updateFactory);  		public static TValue Update<TKey, TValue>(this ConcurrentDictionary<TKey, TValue> dict, TKey key, Action<TValue> updateFactory) 			=> dict.TryUpdate(key, value => { 				updateFactory(value); 				return value; 			}); 		 		public static bool TryGetValue<T>(this IList<T> array, int index, out T value){ 			if (IsValidIndex(array, index)){ 				value = array[index]; 				return true; 			} 			value = default; 			return false; 		} 	} }using System; using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<T> TryDo<T>(this IEnumerable<T> source, Action<T> tryDo) => source.Execute(obj => {             try {                 tryDo(obj);             }             catch {                 // ignored             }         });     } }using System; using System.Collections.Generic; using System.Linq; using Fasterflect; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.LinqExtensions {     public static partial class LinqExtensions {         public static IEnumerable<T> WhereDefault<T>(this IEnumerable<T> source, Func<T,object> predicate) => source.Where(arg => predicate(arg).IsDefaultValue());          public static IEnumerable<TSource> WhereDefault<TSource>(this IEnumerable<TSource> source) {             var type = typeof(TSource);             if (type.IsClass || type.IsInterface){                 return source.Where(source1 => source1==null);                }             var instance = type.CreateInstance();             return source.Where(source1 => source1.Equals(instance));         }      } }using System; using System.Collections.Generic; using System.Linq; using Fasterflect; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<T> WhereNotDefault<T,T2>(this IEnumerable<T> source, Func<T,T2> predicate)              => source.Where(arg => !predicate(arg).IsDefaultValue());          public static IEnumerable<TSource> WhereNotDefault<TSource>(this IEnumerable<TSource> source) {             var type = typeof(TSource);             if (type.IsClass || type.IsInterface){                 return source.Where(source1 => source1!=null);                }             var instance = type.CreateInstance();             return source.Where(source1 => !source1.Equals(instance));         }         public static IEnumerable<string> WhereNotNullOrEmpty(this IEnumerable<string> source)              => source.Where(s => s.IsNotNullOrEmpty());                  public static IEnumerable<string> WhereNotNull(this IEnumerable<string> source)              => source.Where(s => s!=null);                  public static IEnumerable<string> WhereNotEmpty(this IEnumerable<string> source)              => source.Where(s => s!=String.Empty);     } }using System.Collections.Generic;  namespace Xpand.Extensions.LinqExtensions{     public static partial class LinqExtensions{         public static IEnumerable<TSource> YieldItem<TSource>(this TSource source){             yield return source;         }     } }using System; using System.Collections.Concurrent; using System.Linq; using System.Net; using System.Net.Http; using System.Threading; using System.Threading.Tasks; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.Network{     public class ETagHandler : DelegatingHandler {         private static readonly ConcurrentDictionary<Uri, string> ETagCache = new();          protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) {             if (request.Method == HttpMethod.Get && ETagCache.TryGetValue(request.RequestUri!, out var eTag))                 request.Headers.TryAddWithoutValidation("If-None-Match", eTag);             var response = await base.SendAsync(request, cancellationToken);             switch (response.StatusCode){                 case HttpStatusCode.OK when response.Headers.TryGetValues("ETag", out var eTags):{                     var eTagValue = eTags.FirstOrDefault();                     ETagCache.AddOrUpdate(request.RequestUri, eTagValue, (_, _) => eTagValue);                     break;                 }                 case HttpStatusCode.NotModified:                     response.Content = new ByteArrayContent(EmptyContent);                     response.StatusCode = HttpStatusCode.OK;                     break;             }             return response;         }          public static byte[] EmptyContent { get; } = "[]".Bytes();     } }using System.Net.Http; using Fasterflect; using HarmonyLib; using Microsoft.AspNetCore.Http; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.Network {     public static partial class NetworkExtensions {          public static bool IsJsonResponse(this HttpResponseMessage message) => message.Content.Headers.ContentType?.MediaType == "application/json";          public static string GetFullUrl(this HttpRequest httpRequest) {             var path = new[]{httpRequest.Scheme,"//",httpRequest.Host.ToUriComponent(),httpRequest.PathBase.ToUriComponent(),httpRequest.Path.ToUriComponent()};             return !httpRequest.QueryString.HasValue ? path.JoinString() : LinqExtensions.LinqExtensions.Join(path.AddItem(httpRequest.QueryString.Value));         }           public static DelegatingHandler Handler(this HttpClient client)             => (DelegatingHandler)HandlerAccessor(client);         public static T Handler<T>(this HttpClient client) where T:DelegatingHandler             => (T)client.Handler();                  private static readonly MemberGetter HandlerAccessor=typeof(HttpClient).DelegateForGetFieldValue("_handler");      }           }using System; using System.Net; using System.Net.Http; using Fasterflect;  namespace Xpand.Extensions.Network {     public static partial class NetworkExtensions {         public static IPAddress[] IPAddresses(this Uri uri)             => Dns.GetHostAddresses(uri.DnsSafeHost);      } }using System; using System.Net; using System.Net.Sockets; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.Network {     public static partial class NetworkExtensions {         static string _localIPAddress;         public static string LocalIPAddress(this AppDomain domain)              => _localIPAddress ??= Dns.GetHostEntry(Dns.GetHostName()).AddressList.First(                 address => address.AddressFamily == AddressFamily.InterNetwork,                 () => "No network adapters with an IPv4 address in the system!").ToString();     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal Abs(this decimal d) => Math.Abs(d);     } }namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static int Combine(this long a, long b)              => (int)(a >> 32) ^ (int)a ^ (int)(b >> 32) ^ (int)b;     } }using System; using System.Globalization;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal DecimalPart(this decimal d) {             var decimalPart = d - Math.Truncate(d);             var length = decimalPart.ToString(CultureInfo.InvariantCulture).Length-2;             return decimalPart.RoundToSignificantDigits(length);         }          public static int DecimalPartLength(this decimal d)             => d.DecimalPart().ToString(CultureInfo.InvariantCulture).Length-2;     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal ZeroWhenNative(this decimal d)             => Math.Max(0, d);     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal FloorNumber(this decimal d, int decimals = 0)             => Math.Floor(d);     } }namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static bool GreaterOrEqual(this double value1, double value2, double unimportantDifference = 0.0001)              => value1.NearlyEquals(value2) || value1 > value2;     } }namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static long MakeLong(this int left, int right) {             long res = left;             res = (res << 32);             res |= (uint)right;             return res;         }     } }using System.Numerics;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static BigInteger Max(this BigInteger _)             => BigInteger.Parse("115792089237316195423570985008687907853269984665640564039457584007913129639935");     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static long Ticks(this int milliSeconds) => milliSeconds.Milliseconds().Ticks;         public static TimeSpan Milliseconds(this int milliSeconds) => TimeSpan.FromMilliseconds(milliSeconds);     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static bool NearlyEquals(this double value1, double value2, double unimportantDifference = 0.0001)              => Math.Abs(value1 - value2) < unimportantDifference;     } }namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal Normalize(this decimal value)             => value / 1.000000000000000000000000000000000m;     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal PercentageDifference(this decimal d, decimal d2,int decimals=2)              => d>0? ((d - d2) / d.Abs() * 100).RoundNumber(decimals):0;         public static decimal PercentageDifference(this TimeSpan d, TimeSpan d2,int decimals=2)              => ((decimal)d.Ticks).PercentageDifference(d2.Ticks,decimals);                  public static decimal Percentage(this decimal d, decimal percentage,int decimals=2)              =>100==percentage?d: (percentage / 100 * d).RoundNumber(decimals);                  public static decimal Percentage(this decimal d, int percentage,int decimals=2)              => d.Percentage(Convert.ToDecimal(percentage),decimals);     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static double Round(this double d, int decimals = 0)              => Math.Round(d, decimals);                  public static double Round(this float d, int decimals = 0)              => Math.Round(d, decimals);     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static decimal RoundNumber(this decimal d, int decimals = 0)              => Math.Round(d, decimals);                  public static decimal RoundDown(this decimal number, int decimalPlaces) => Math.Floor(number * (decimal)Math.Pow(10, decimalPlaces)) / (decimal)Math.Pow(10, decimalPlaces);          public static decimal RoundUp(this decimal number, int decimalPlaces) => Math.Ceiling(number * (decimal)Math.Pow(10, decimalPlaces)) / (decimal)Math.Pow(10, decimalPlaces);     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static double RoundToSignificantDigits(this double d, int digits) {             if (d.NearlyEquals(0)) return d;             var scale = Math.Pow(10, Math.Floor(Math.Log10(Math.Abs(d))) + 1);             return scale * Math.Round(d / scale, digits);         }         public static decimal RoundToSignificantDigits(this decimal d, int digits) {             if (d==0) return d;             var scale = Math.Pow(10, Math.Floor(Math.Log10((double)Math.Abs(d))) + 1);             return (decimal)(scale * (double)Math.Round(d / (decimal)scale, digits));         }     } }using System;  namespace Xpand.Extensions.Numeric {     public static partial class NumericExtensions {         public static TimeSpan Seconds(this int seconds) => TimeSpan.FromSeconds(seconds);     } }using System; using System.Linq; using System.Text; using System.Text.Json; using Xpand.Extensions.StringExtensions; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.ObjectExtensions {      public static partial class ObjectExtensions {                  public static string EnsureString(this object o)             => o?.ToString().EnsureEndWith(String.Empty)??String.Empty;         public static string EnsureStringEndWith(this object o, string end)             => o?.ToString().EnsureEndWith(end)??end;         public static T As<T>(this object obj)              => obj is T variable ? variable : default;         public static T As<T>(this T obj,string typeName) {             var type = obj?.GetType();             return type == null ? default : type.IsInterface ? type.Implements(typeName) ? obj : default :                 type.InheritsFrom(typeName) ? obj : default;         }     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static IEnumerable<TSource> Do<TSource>(             this IEnumerable<TSource> source, Action<TSource> selector, Action<Exception> error = null)             => source.Select(source1 => {                 try {                     selector(source1);                  }                 catch (Exception e) {                     error?.Invoke(e);                     throw;                 }                  return source1;             });     } }using System; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.ObjectExtensions{ 	public static partial class ObjectExtensions{         public static bool IsDefaultValue<TSource>(this TSource source) { 	        var def = default(TSource); 	        return def != null ? def.Equals(source) : typeof(TSource) == typeof(object) 			        ? source == null || source.Equals(source.GetType().DefaultValue()) : source == null;         }  		public static bool IsDefaultValue(this object source)              => source == null || source.Equals(source.GetType().DefaultValue()); 		 		public static bool IsDefaultValue(this object source,Type objectType)              => objectType.DefaultValue()==source;     } }using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.ObjectExtensions{     public static partial class ObjectExtensions{         public static bool IsInstanceOf<TSource>(this TSource source, string typeName) where TSource : class{             return source != null && source.GetType().InheritsFrom(typeName);         }     } }using System.IO; using System.Linq; using System.Text; using System.Text.Json; using Xpand.Extensions.JsonExtensions;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static bool IsSmallObject(this object obj, int thresholdInBytes = 85000) {             if (obj == null) return true;             var jsonString = obj.Serialize();             return Encoding.UTF8.GetByteCount(jsonString) - EstimateJsonOverhead(jsonString) < thresholdInBytes;         }          public static bool IsSmallObject(this JsonDocument document, int thresholdInBytes = 85000) {             if (document == null) return true;             using var memoryStream = new MemoryStream();             using (var writer = new Utf8JsonWriter(memoryStream)) {                 document.WriteTo(writer);             }             return (int)memoryStream.Length < thresholdInBytes;         }          private static int EstimateJsonOverhead(string jsonString) {             var bracesCount = jsonString.Count(c => c is '{' or '}');             var quotesCount = jsonString.Count(c => c == '\"');             var colonsCount = jsonString.Count(c => c == ':');             var commasCount = jsonString.Count(c => c == ',');             return bracesCount + quotesCount + colonsCount + commasCount;         }     } }using System;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static bool IsValueNull(this object value)             => value == null || value == DBNull.Value;     } }namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static T Cast<T>(this object obj)             => (T)obj;              } }using System.Collections; using System.Collections.Generic; using System.ComponentModel; using System.Linq; using System.Text.Json.Serialization;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static Dictionary<object, object> ToPropertyValueDictionary(this object source,bool skipDefaultValues=false,bool includeReadOnly=false)              => source is IDictionary dictionary ? Enumerable.Cast<object>(dictionary.Keys).ToDictionary(o => o, o => dictionary[o])                 : source.GetType().GetProperties().Where(info => !info.GetCustomAttributes(typeof(JsonIgnoreAttribute), false).Any())                     .Where(info => Enumerable.Cast<BrowsableAttribute>(info.GetCustomAttributes(typeof(BrowsableAttribute), false))                         .All(attribute => attribute.Browsable))                     .Where(info => !skipDefaultValues || !info.GetValue(source, null).IsDefaultValue())                     .Where(info => includeReadOnly || info.CanWrite)                     .ToDictionary(info => (object)info.Name, info => info.GetValue(source, null));     } }using System.Collections; using System.Linq; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static string ToQueryString(this object source)              => LinqExtensions.LinqExtensions.Join((IEnumerable)source.ToPropertyValueDictionary(true)                 .Select(key => key.Key.JoinString("=",key.Value?.ToString().UrlEncode()))                 .ToArray(), "&");     } }using System; using System.Collections.Generic;  namespace Xpand.Extensions.ObjectExtensions {     public static partial class ObjectExtensions {         public static object[] ValueTupleItems(this object obj) {             var type = obj.GetType();             return type.IsGenericType && GetItems.TryGetValue(type.GetGenericTypeDefinition(), out var itemGetter)                 ? itemGetter(obj) : Array.Empty<object>();         }          static readonly IDictionary<Type,Func<object,object[]>> GetItems = new Dictionary<Type,Func<object,object[]>> {             [typeof(ValueTuple<>)] = o => new object[] {((dynamic)o).Item1}             ,   [typeof(ValueTuple<,>)] = o => new object[] {((dynamic)o).Item1, ((dynamic)o).Item2}             ,   [typeof(ValueTuple<,,>)] = o => new object[] {((dynamic)o).Item1, ((dynamic)o).Item2, ((dynamic)o).Item3}             ,   [typeof(ValueTuple<,,,>)] = o => new object[] {((dynamic)o).Item1, ((dynamic)o).Item2, ((dynamic)o).Item3,((dynamic)o).Item4}                      };      } }using System; using System.Diagnostics; using System.Linq;  namespace Xpand.Extensions.ProcessExtensions {     public static partial class ProcessExtensions {         [System.Runtime.InteropServices.DllImport("user32.dll")]         private static extern int GetWindowThreadProcessId(IntPtr hWnd, IntPtr procId);          public static ProcessThread GetUIThread(this Process proc) {             int id = GetWindowThreadProcessId(proc.MainWindowHandle, IntPtr.Zero);             return proc.Threads.Cast<ProcessThread>().FirstOrDefault(pt => pt.Id == id);         }     } }using System.ComponentModel; using System.Diagnostics;  namespace Xpand.Extensions.ProcessExtensions{     public static partial class ProcessExtensions{         public static bool IsUnderIISExpress(this Process currentProcess){             try{                 if (string.CompareOrdinal(currentProcess.ProcessName, "iisexpress") == 0) return true;                 var parentProcess = currentProcess.Parent();                 return string.CompareOrdinal(parentProcess.ProcessName, "iisexpress") == 0                        || string.CompareOrdinal(parentProcess.ProcessName, "VSIISExeLauncher") == 0;             }             catch (Win32Exception){                 if (!Debugger.IsAttached){                     return Process.GetCurrentProcess().ProcessName != "iisexpress";                 }                  throw;             }         }     } }using System; using System.Diagnostics; using System.Threading.Tasks; using Xpand.Extensions.IntPtrExtensions;  namespace Xpand.Extensions.ProcessExtensions{     public static partial class ProcessExtensions{         public static Process Parent(this Process process) => process.Handle.ParentProcess();              } }using System.Diagnostics; using System.Threading.Tasks;  namespace Xpand.Extensions.ProcessExtensions {     public static partial class ProcessExtensions {         public static Task<int> RunProcessAsync(this Process process) {             process.EnableRaisingEvents = true;             var tcs = new TaskCompletionSource<int>();             process.Exited += (_, _) => {                 tcs.SetResult(process.ExitCode);                 process.Dispose();             };             process.Start();             return tcs.Task;         }     } }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System; using System.Linq; using System.Reflection; using System.Reflection.Emit;  namespace Xpand.Extensions.ReflectionExtensions{     public partial class ReflectionExtensions{ 	    private static readonly ModuleBuilder MModule;          static ReflectionExtensions(){             var assembly = AssemblyBuilder.DefineDynamicAssembly(                 new AssemblyName("DelegateTypeFactory"), AssemblyBuilderAccess.RunAndCollect);             MModule = assembly.DefineDynamicModule("DelegateTypeFactory");         }          public static Type CreateDelegateType(this MethodInfo method){             var nameBase = $"{method.DeclaringType?.Name}{method.Name}";             var name = GetUniqueName(nameBase);              var typeBuilder = MModule.DefineType(                 name, TypeAttributes.Sealed | TypeAttributes.Public, typeof(MulticastDelegate));              var constructor = typeBuilder.DefineConstructor(                 MethodAttributes.RTSpecialName | MethodAttributes.HideBySig | MethodAttributes.Public,                 CallingConventions.Standard, new[]{typeof(object), typeof(IntPtr)});             constructor.SetImplementationFlags(MethodImplAttributes.CodeTypeMask);              var parameters = method.GetParameters();              var invokeMethod = typeBuilder.DefineMethod(                 "Invoke", MethodAttributes.HideBySig | MethodAttributes.Virtual | MethodAttributes.Public,                 method.ReturnType, parameters.Select(p => p.ParameterType).ToArray());             invokeMethod.SetImplementationFlags(MethodImplAttributes.CodeTypeMask);              for (var i = 0; i < parameters.Length; i++){                 var parameter = parameters[i];                 invokeMethod.DefineParameter(i + 1, ParameterAttributes.None, parameter.Name);             }              return typeBuilder.CreateTypeInfo();         }          private static string GetUniqueName(string nameBase){             var number = 2;             var name = nameBase;             while (MModule.GetType(name) != null)                 name = nameBase + number++;             return name;         }     } }using System; using System.Linq.Expressions; using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{     public static partial class ReflectionExtensions{         public static MemberInfo GetMemberInfo(this LambdaExpression lambda) {             if (lambda == null) throw new ArgumentException("Not a lambda expression", nameof(lambda));             MemberExpression memberExpr = null;             switch (lambda.Body.NodeType){                 case ExpressionType.Convert:                     memberExpr = ((UnaryExpression)lambda.Body).Operand as MemberExpression;                     break;                 case ExpressionType.MemberAccess:                     memberExpr = lambda.Body as MemberExpression;                     break;             }             if (memberExpr == null) throw new ArgumentException("Not a member access", nameof(lambda));             return memberExpr.Member;         }      } }using System; using System.Linq; using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{ 	public partial class ReflectionExtensions{ 		public static MethodInfo GetOverridingMethod(this Type type, MethodInfo baseMethod) => 			type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.InvokeMethod) 				.FirstOrDefault(baseMethod.IsBaseMethodOf); 	} }using System; using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{ 	public partial class ReflectionExtensions{ 		public static bool HasOverridingMethod(this Type type, MethodInfo baseMethod) => type.GetOverridingMethod(baseMethod) != null; 	} }using System.Linq; using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{     public partial class ReflectionExtensions{         public static bool HasSameSignature(this MethodInfo a, MethodInfo b){             bool sameParams = a.GetParameters().All(x => b.GetParameters().Any(y => x == y));             bool sameReturnType = a.ReturnType == b.ReturnType;             return sameParams && sameReturnType;         }     } }using System.Reflection; using System.Threading.Tasks;  namespace Xpand.Extensions.ReflectionExtensions{     public partial class ReflectionExtensions{         public static async Task<object> InvokeAsync(this MethodInfo methodInfo, object obj, params object[] parameters){             dynamic awaitable = methodInfo.Invoke(obj, parameters);             await (Task)awaitable;             return awaitable.GetAwaiter().GetResult();         }     } }using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{ 	public partial class ReflectionExtensions{ 		public static bool IsBaseMethodOf(this MethodInfo baseMethod, MethodInfo method) => baseMethod.DeclaringType != method.DeclaringType && baseMethod == method.GetBaseDefinition(); 	} }using System;  namespace Xpand.Extensions.ReflectionExtensions{     public static partial class ReflectionExtensions{         public static bool IsNullableType(this Type theType) => theType.IsGenericType && theType.GetGenericTypeDefinition() == typeof(Nullable<>);     } }using System; using System.Collections.Generic; using System.Reflection;  namespace Xpand.Extensions.ReflectionExtensions{     public static partial class ReflectionExtensions{         public static readonly List<AccessModifier> AccessModifiers = new List<AccessModifier> {             Extensions.ReflectionExtensions.AccessModifier.Private,             Extensions.ReflectionExtensions.AccessModifier.Protected,             Extensions.ReflectionExtensions.AccessModifier.ProtectedInternal,             Extensions.ReflectionExtensions.AccessModifier.Internal,             Extensions.ReflectionExtensions.AccessModifier.Public         };          public static AccessModifier AccessModifier(this PropertyInfo propertyInfo){             if (propertyInfo.SetMethod == null)                 return propertyInfo.GetMethod.AccessModifier();             if (propertyInfo.GetMethod == null)                 return propertyInfo.SetMethod.AccessModifier();             var max = Math.Max(AccessModifiers.IndexOf(propertyInfo.GetMethod.AccessModifier()),                 AccessModifiers.IndexOf(propertyInfo.SetMethod.AccessModifier()));             return AccessModifiers[max];         }          public static AccessModifier AccessModifier(this MethodInfo methodInfo){             if (methodInfo.IsPrivate)                 return Extensions.ReflectionExtensions.AccessModifier.Private;             if (methodInfo.IsFamily)                 return Extensions.ReflectionExtensions.AccessModifier.Protected;             if (methodInfo.IsFamilyOrAssembly)                 return Extensions.ReflectionExtensions.AccessModifier.ProtectedInternal;             if (methodInfo.IsAssembly)                 return Extensions.ReflectionExtensions.AccessModifier.Internal;             if (methodInfo.IsPublic)                 return Extensions.ReflectionExtensions.AccessModifier.Public;             if (methodInfo.IsSpecialName&&methodInfo.IsHideBySig)                 return Extensions.ReflectionExtensions.AccessModifier.Private;             throw new ArgumentException("Did not find access modifier", nameof(methodInfo));         }     }      public enum AccessModifier{         Private,         Protected,         ProtectedInternal,         Internal,         Public     } }using System; using System.Linq.Expressions; using Fasterflect; using Xpand.Extensions.ExpressionExtensions; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.ReflectionExtensions {     public partial class ReflectionExtensions {         public static bool SetIfDefault<T, TValue>(this T obj, Expression<Func<T, TValue>> memberName, Func<TValue> value) {             var memberExpressionName = memberName.MemberExpressionName();             var propertyValue = obj.GetPropertyValue(memberExpressionName);             if (propertyValue.IsDefaultValue()) {                 obj.SetPropertyValue(memberExpressionName, value());                 return true;             }              return false;         }          public static bool SetIfDefault<T, TValue>(this T obj, Expression<Func<T, TValue>> memberName, TValue value)              => obj.SetIfDefault(memberName, () => value);     } }using System;  namespace Xpand.Extensions.SpanExtensions {     public static class SpanExtensions {         public static decimal ToDecimal(this ReadOnlySpan<char> span) {             decimal.TryParse(span, out var result);             return result;         }          public static int ToInt32(this ReadOnlySpan<char> span) {             int.TryParse(span, out var result);             return result;         }          public static long ToInt64(this ReadOnlySpan<char> span) {             long.TryParse(span, out var result);             return result;         }          public static float ToSingle(this ReadOnlySpan<char> span) {             float.TryParse(span, out var result);             return result;         }          public static double ToDouble(this ReadOnlySpan<char> span) {             double.TryParse(span, out var result);             return result;         }           public static ushort ToUInt16(this ReadOnlySpan<char> span) {             ushort.TryParse(span, out var result);             return result;         }          public static uint ToUInt32(this ReadOnlySpan<char> span) {             uint.TryParse(span, out var result);             return result;         }          public static ulong ToUInt64(this ReadOnlySpan<char> span) {             ulong.TryParse(span, out var result);             return result;         }                  public static bool ToBoolean(this ReadOnlySpan<char> span) {             bool.TryParse(span, out var result);             return result;         }                  public static DateTime? ToNullableDateTime(this ReadOnlySpan<char> span)              => span.IsEmpty ? null : DateTime.TryParse(span, out var result) ? result : null;         public static DateTime ToDateTime(this ReadOnlySpan<char> span) {             DateTime.TryParse(span, out var result);             return result;         }          public static DateTimeOffset ToDateTimeOffset(this ReadOnlySpan<char> span) {             DateTimeOffset.TryParse(span, out var result);             return result;         }                  public static Guid ToGuid(this ReadOnlySpan<char> span) {             Guid.TryParse(span, out var result);             return result;         }                  public static TimeSpan ToTimeSpan(this ReadOnlySpan<char> span) {             TimeSpan.TryParse(span, out var result);             return result;         }                                } }using System.IO;  namespace Xpand.Extensions.StreamExtensions{     public static partial class StreamExtensions{         public static byte[] Bytes(this Stream stream){             if (stream is MemoryStream memoryStream){                 return memoryStream.ToArray();             }              using MemoryStream ms = new MemoryStream();             stream.CopyTo(ms);             return ms.ToArray();         }     } }namespace Xpand.Extensions.StreamExtensions{     public static partial class StreamExtensions{         public static void CopyTo(this System.IO.Stream src, System.IO.Stream dest){             byte[] bytes = new byte[4096];             int cnt;             while ((cnt = src.Read(bytes, 0, bytes.Length)) != 0) {                 dest.Write(bytes, 0, cnt);             }         }      } }using System.IO; using System.IO.Compression;  namespace Xpand.Extensions.StreamExtensions{     public static partial class StreamExtensions{         public static byte[] GZip(this Stream decompressed,CompressionLevel compressionLevel=CompressionLevel.Optimal){             using var compressed = new MemoryStream();             using (var zip = new GZipStream(compressed, compressionLevel, true)){                 decompressed.CopyTo(zip);             }             compressed.Seek(0, SeekOrigin.Begin);             return compressed.ToArray();         }     } }using System.IO; using System.Threading.Tasks;  namespace Xpand.Extensions.StreamExtensions{     public static partial class StreamExtensions{         public static string ReadToEnd(this Stream stream){             using var streamReader = new StreamReader(stream);             return streamReader.ReadToEnd();         }         public static string ReadToEndAsString(this Stream stream){             using var streamReader = new StreamReader(stream);             return streamReader.ReadToEnd();         }          public static async Task<string> ReadToEndAsStringAsync(this Stream stream){             using var streamReader = new StreamReader(stream);             return await streamReader.ReadToEndAsync();         }     } }using System; using System.IO;  namespace Xpand.Extensions.StreamExtensions {     public static partial class StreamExtensions {         public static void SaveToFile(this Stream stream, string filePath) {             var directory = Path.GetDirectoryName(filePath) + "";             if (!Directory.Exists(directory)) {                 Directory.CreateDirectory(directory);             }              using var fileStream = File.OpenWrite(filePath);             stream.CopyTo(fileStream);         }     } }using System.IO; using System.IO.Compression; using System.Threading.Tasks;  namespace Xpand.Extensions.StreamExtensions{     public static partial class StreamExtensions{         public static string UnGzip(this Stream compressed){             using var decompressed = new MemoryStream();             using (var zip = new GZipStream(compressed, CompressionMode.Decompress, true)){                 zip.CopyTo(decompressed);             }             decompressed.Seek(0, SeekOrigin.Begin);             return decompressed.ReadToEndAsString();         }         public static async Task<string> UnGzipAsync(this Stream compressed){             using var decompressed = new MemoryStream();             using (var zip = new GZipStream(compressed, CompressionMode.Decompress, true)){                 await zip.CopyToAsync(decompressed);             }             decompressed.Seek(0, SeekOrigin.Begin);             return await decompressed.ReadToEndAsStringAsync();         }     } }using System; using System.Security.Cryptography; using System.Text;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static byte[] Combine(this string s, string other) {             using (var sha256 = SHA256.Create()) {                 var aBytes = Encoding.UTF8.GetBytes(s);                 var bBytes = Encoding.UTF8.GetBytes(other);                 var aBase64Length = (aBytes.Length + 2) / 3 * 4;                 var bBase64Length = (bBytes.Length + 2) / 3 * 4;                  char[] delimiterChars = { '|' };                 var combinedLength = aBase64Length + delimiterChars.Length + bBase64Length;                 var combinedChars = new char[combinedLength];                  Span<char> combinedSpan = combinedChars;                 if (!Convert.TryToBase64Chars(aBytes, combinedSpan, out var aEncodedChars))                     throw new InvalidOperationException("Failed to encode the first string to Base64.");                 combinedSpan = combinedSpan.Slice(aEncodedChars);                 delimiterChars.CopyTo(combinedSpan);                 combinedSpan = combinedSpan.Slice(delimiterChars.Length);                 if (!Convert.TryToBase64Chars(bBytes, combinedSpan, out _))                     throw new InvalidOperationException("Failed to encode the second string to Base64.");                  var combinedBytes = Encoding.UTF8.GetBytes(combinedChars);                 var hashBytes = sha256.ComputeHash(combinedBytes);                 return hashBytes;             }         }          public static byte[] Bytes(this string s, Encoding encoding = null)              => s == null ? Array.Empty<byte>() : (encoding ?? Encoding.UTF8).GetBytes(s);     } }using System;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static int LevenshteinDistance(this string source, string target) {             // degenerate cases             if (source == target) return 0;             if (source.Length == 0) return target.Length;             if (target.Length == 0) return source.Length;              // create two work vectors of integer distances             int[] v0 = new int[target.Length + 1];             int[] v1 = new int[target.Length + 1];              // initialize v0 (the previous row of distances)             // this row is A[0][i]: edit distance for an empty s             // the distance is just the number of characters to delete from t             for (int i = 0; i < v0.Length; i++)                 v0[i] = i;              for (int i = 0; i < source.Length; i++)             {                 // calculate v1 (current row distances) from the previous row v0                  // first element of v1 is A[i+1][0]                 //   edit distance is delete (i+1) chars from s to match empty t                 v1[0] = i + 1;                  // use formula to fill in the rest of the row                 for (int j = 0; j < target.Length; j++)                 {                     var cost = (source[i] == target[j]) ? 0 : 1;                     v1[j + 1] = Math.Min(v1[j] + 1, Math.Min(v0[j + 1] + 1, v0[j] + cost));                 }                  // copy v1 (current row) to v0 (previous row) for next iteration                 for (int j = 0; j < v0.Length; j++)                     v0[j] = v1[j];             }              return v1[target.Length];         }         /// <summary>         /// Calculate percentage similarity of two strings         /// <param name="source">Source String to Compare with</param>         /// <param name="target">Targeted String to Compare</param>         /// <returns>Return Similarity between two strings from 0 to 1.0</returns>         /// </summary>         public static double CalculateSimilarity(this string source, string target) {             if ((source == null) || (target == null)) return 0.0;             if ((source.Length == 0) || (target.Length == 0)) return 0.0;             if (source == target) return 1.0;              int stepsToSame = LevenshteinDistance(source, target);             return (1.0 - (stepsToSame / (double)Math.Max(source.Length, target.Length)));         }     } }using System; using System.CodeDom.Compiler; using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static string CleanCodeName(this string s) {             var regex = new Regex(@"[^\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Nl}\p{Mn}\p{Mc}\p{Cf}\p{Pc}\p{Lm}]");             string ret = regex.Replace(s + "", "");             if (!(string.IsNullOrEmpty(ret)) && !Char.IsLetter(ret, 0) && !CodeDomProvider.CreateProvider("C#").IsValidIdentifier(ret))                 ret = string.Concat("_", ret);             return ret;          }      } }using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string CommonStart(this IEnumerable<string> strings) {             var namespaces = strings.Where(s => s != null).ToArray();             return Enumerable.Range(0, namespaces.Min(s => s.Length))                 .Reverse()                 .Select(len => new {len, possibleMatch = namespaces.First().Substring(0, len)})                 .Where(t => namespaces.All(f => f.StartsWith(t.possibleMatch)))                 .Select(t => t.possibleMatch).First().Trim('.');         }     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string EnsureEmpty(this string source)             => source ?? string.Empty;     } }using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string EnsureEndWith(this string s, string end)             => !s.EndsWith(end) ? new[] { s, end }.JoinString() : s;     } }namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static string FirstCharacterToLower(this string str) =>             string.IsNullOrEmpty(str) || char.IsLower(str, 0) ? str : char.ToLowerInvariant(str[0]) + str.Substring(1);     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string FirstCharacterToUpper(this string str) =>             string.IsNullOrEmpty(str) || char.IsUpper(str, 0) ? str : char.ToUpperInvariant(str[0]) + str.Substring(1);     } }using System.IO; using System.IO.Compression; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static byte[] GZip(this string s,CompressionLevel compressionLevel=CompressionLevel.Optimal){             using var memoryStream = new MemoryStream(s.Bytes());             return memoryStream.GZip(compressionLevel);         }     } }using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string Inject(this string injectToString, int positionToInject, string stringToInject)              => new[] { injectToString.Substring(0, positionToInject), stringToInject,                 injectToString.Substring(positionToInject) }.JoinString();     } }using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string StringFormat(this object s, params object[] args) {             var value = $"{s}";             return string.IsNullOrEmpty(value)?args.Join(""):string.Format($"{s}",args);         }     } }using System;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static bool IsEqualIgnoreCase(this string s, string other)              => StringComparer.InvariantCultureIgnoreCase.Equals(s, other);          public static bool IsEqual(this string s, string other) {             return StringComparer.InvariantCulture.Equals(s, other);         }     } }using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         private static readonly Regex IsGuidRegex = new(@"^(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}$", RegexOptions.Compiled);         public static bool IsGuid(this string candidate)             => candidate != null && IsGuidRegex.IsMatch(candidate);     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static bool IsNullOrEmpty(this string strString)             => string.IsNullOrEmpty(strString);         public static bool IsNotNullOrEmpty(this string strString)             => !string.IsNullOrEmpty(strString);     } }using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static bool IsNumeric(this string strString)              => Regex.IsMatch(strString, "\\A\\b\\d+\\b\\z");     } }using System;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static bool IsWellFormedUri(this string address, UriKind uriKind = UriKind.RelativeOrAbsolute)              => Uri.IsWellFormedUriString(address, uriKind);     } }using System; using System.Linq;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static bool IsWhiteSpace(this string value) => value.All(Char.IsWhiteSpace);     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string Keep(this string s, int characters)              =>characters<s.Length? s.Remove(0, characters):s;     } }using System.IO; using System.Text;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static MemoryStream MemoryStream(this string s, Encoding encoding = null) => new(s.Bytes(encoding));     } }using System.Diagnostics.CodeAnalysis; using System.Security.Cryptography;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public static byte[] Protect(this byte[] bytes, DataProtectionScope scope = DataProtectionScope.LocalMachine)              => ProtectedData.Protect(bytes, null,scope);          [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public static byte[] Protect(this string s, DataProtectionScope scope = DataProtectionScope.LocalMachine)              => s.Bytes().Protect(scope);     } }using System; using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string RemoveComments(this string s) {             var blockComments = @"/\*(.*?)\*/";             var lineComments = @"//(.*?)\r?\n";             var strings = @"""((\\[^\n]|[^""\n])*)""";             var verbatimStrings = @"@(""[^""]*"")+";             return Regex.Replace(s, blockComments + "|" + lineComments + "|" + strings + "|" + verbatimStrings,                 me => me.Value.StartsWith("/*") || me.Value.StartsWith("//")                     ? me.Value.StartsWith("//") ? Environment.NewLine : "" : me.Value, RegexOptions.Singleline);         }     } }using System.Globalization; using System.Linq; using System.Text; using Xpand.Extensions.LinqExtensions;   namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string RemoveDiacritics(this string s)              => s.Normalize(NormalizationForm.FormD)                 .Where(c => CharUnicodeInfo.GetUnicodeCategory(c) != UnicodeCategory.NonSpacingMark)                 .JoinString();     } }using System.Linq;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static string Repeat(this string s, int nummber,string seperator="") => string.Join(seperator,Enumerable.Repeat(s, nummber));     } }using System.Net; using System.Security;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static SecureString ToSecureString(this string s)             => new NetworkCredential("", s).SecurePassword;                  public static string GetString(this SecureString secureString)             => new NetworkCredential("",secureString).Password;              } }using System;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static string[] Split(this string str, char separator)              => str.Split(new[] { separator }, StringSplitOptions.RemoveEmptyEntries);                  public static string SplitCamelCase(string input) => System.Text.RegularExpressions.Regex                 .Replace(input, "([A-Z])", " $1", System.Text.RegularExpressions.RegexOptions.Compiled).Trim();     } }using System; using System.Security.Cryptography; using System.Text;  namespace Xpand.Extensions.StringExtensions{ 	public static partial class StringExtensions{ 		public static Guid ToGuid(this string s){ 			if (!Guid.TryParse(s, out var guid)) {                 using var md5 = MD5.Create();                 var data = md5.ComputeHash(Encoding.Default.GetBytes(s));                 return new Guid(data);             }  			return guid; 		} 	} }using System.Collections.Generic;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static IEnumerable<string> ToLines(this string input) {             using System.IO.StringReader reader = new System.IO.StringReader($"{input}");             while (reader.ReadLine() is { } line) {                 yield return line;             }         }     } }using System.CodeDom; using System.CodeDom.Compiler; using System.IO;  namespace Xpand.Extensions.StringExtensions{     public static partial class StringExtensions{         public static string ToLiteral(this string input){             using (var writer = new StringWriter()){                 using (var codeDomProvider = CodeDomProvider.CreateProvider("CSharp")){                     codeDomProvider.GenerateCodeFromExpression(new CodePrimitiveExpression(input), writer, null);                     return writer.ToString();                 }             }         }     } }using System.Web;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string UrlEncode(this string s)              => HttpUtility.UrlEncode(s);     } }using System; using System.Globalization; using System.Linq; using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static long Val(this string value) {             string returnVal = String.Empty;             MatchCollection collection = Regex.Matches(value, "\\d+");             returnVal = collection.Cast<Match>().Aggregate(returnVal, (current, match) => current + match.ToString());             return Convert.ToInt64(returnVal);         }          public static int ValInt32(this string x) {             var regex = new Regex("[-+]?\\b\\d+\\b", RegexOptions.Compiled);             var match = regex.Match(x + "");             return match.Success ? int.Parse(match.Value, NumberFormatInfo.InvariantInfo) : 0;         }          public static double ValDouble(this string x) {             var regex = new Regex("[-+]?\\b(?:[0-9]*\\.)?[0-9]+\\b", RegexOptions.Compiled);             var match = regex.Match(x + "");             return match.Success ? double.Parse(match.Value, NumberFormatInfo.InvariantInfo) : 0;         }     } }using System; using System.Text.RegularExpressions;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static String WildCardToRegular(this String value)              => "^" + Regex.Escape(value).Replace("\\*", ".*") + "$";     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string XmlDecode(this string value)              => value.Replace("&amp;", "&").Replace("&apos;", "'").Replace("&quot;", "\"").Replace("&lt;", "<").Replace("&gt;", ">");     } }namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static string XmlEncode(this string value)             => value.TrimEnd((char) 1).Replace("&", "&amp;").Replace("'", "&apos;").Replace("\"", "&quot;")                 .Replace("<", "&lt;").Replace(">", "&gt;");     } }using System; using System.IO; using System.Text; using System.Xml;  namespace Xpand.Extensions.StringExtensions {     public static partial class StringExtensions {         public static String XmlPrint(this String xml) {             if (string.IsNullOrEmpty(xml))                 return xml;             String result = "";              var mStream = new MemoryStream();             var writer = new XmlTextWriter(mStream, Encoding.Unicode);             var document = new XmlDocument();              try {                 document.LoadXml(xml);                 writer.Formatting = Formatting.Indented;                 document.WriteContentTo(writer);                 writer.Flush();                 mStream.Flush();                 mStream.Position = 0;                 var sReader = new StreamReader(mStream);                 var formattedXml = sReader.ReadToEnd();                  result = formattedXml;             }             catch (XmlException) { }              mStream.Close();             writer.Close();              return result;         }     } }using System; using System.Threading; using System.Threading.Tasks;  namespace Xpand.Extensions.TaskExtensions{     public static partial class TaskExtensions{         public static Task<T> StartTask<T>(this Func<T> func,Action<Thread> configure){                          var tcs = new TaskCompletionSource<T>();             var thread = new Thread(() => {                 try{                     tcs.SetResult(func());                 }                 catch (Exception e){                     tcs.SetException(e);                 }             });             configure(thread);             thread.Start();             return tcs.Task;         }          public static Task<T> StartTask<T>(this TaskFactory taskFactory, Func<T> func,Action<Thread> configure) => func.StartTask(configure);     } }using System; using System.Threading; using System.Threading.Tasks;  namespace Xpand.Extensions.TaskExtensions{     public static partial class TaskExtensions{         public static async Task<TResult> Timeout<TResult>(this Task<TResult> task, TimeSpan timeout){             using (var timeoutCancellationTokenSource = new CancellationTokenSource()){                 var completedTask = await Task.WhenAny(task, Task.Delay(timeout, timeoutCancellationTokenSource.Token));                 if (completedTask == task){                     timeoutCancellationTokenSource.Cancel();                     return await task;                 }                  throw new TimeoutException("The operation has timed out.");             }         }     } }using System; using System.Collections.Concurrent; using System.Threading; using System.Threading.Tasks;  namespace Xpand.Extensions.Threading {     public static class SingleThreadedSynchronizationContextExtenions {         public static void AwaitTask(this Task invoker) => SingleThreadedSynchronizationContext.Await(() => invoker);     }     public sealed class SingleThreadedSynchronizationContext : SynchronizationContext {         private readonly BlockingCollection<(SendOrPostCallback d, object state)> _queue = new();          public override void Post(SendOrPostCallback d, object state) => _queue.Add((d, state));                    public static void Await(Func<Task> invoker) {             var originalContext = Current;             try {                 var context = new SingleThreadedSynchronizationContext();                 SetSynchronizationContext(context);                  var task = invoker.Invoke();                 task.ContinueWith(_ => context._queue.CompleteAdding());                  while (context._queue.TryTake(out var work, Timeout.Infinite))                     work.d.Invoke(work.state);                  task.GetAwaiter().GetResult();             }             finally {                 SetSynchronizationContext(originalContext);             }         }     } }using System.IO;  namespace Xpand.Extensions.Tracing {       /// <summary>     /// Interface facade representing the file system and the operations of System.IO.File and System.IO.Directory.     /// </summary>     public interface IFileSystem {         /// <summary>         /// Opens a System.IO.FileStream on the specified path,          /// having the specified mode with read, write, or read/write access         /// and the specified sharing option.         /// </summary>         /// <param name="path">The file to open.</param>         /// <param name="mode">A value that specifies whether a file is created if one does not exist, and determines whether the contents of existing files are retained or overwritten.</param>         /// <param name="access">A value that specifies the operations that can be performed on the file.</param>         /// <param name="share">A value specifying the type of access other threads have to the file.</param>         /// <returns></returns>         Stream Open(string path, FileMode mode, FileAccess access, FileShare share);     }      /// <summary>     /// Adapter that wraps System.IO.File and System.IO.Directory, allowing them to be substituted.     /// </summary>     public class FileSystem : IFileSystem {         /// <summary>         /// Opens a System.IO.FileStream on the specified path,          /// having the specified mode with read, write, or read/write access         /// and the specified sharing option.         /// </summary>         /// <param name="path">The file to open.</param>         /// <param name="mode">A value that specifies whether a file is created if one does not exist, and determines whether the contents of existing files are retained or overwritten.</param>         /// <param name="access">A value that specifies the operations that can be performed on the file.</param>         /// <param name="share">A value specifying the type of access other threads have to the file.</param>         /// <returns></returns>         public Stream Open(string path, FileMode mode, FileAccess access, FileShare share) {             return File.Open(path, mode, access, share);         }     } }using System; using System.Diagnostics; using System.Diagnostics.CodeAnalysis; using System.Globalization;  namespace Xpand.Extensions.Tracing {     /// <summary>     /// Trace listener that writes to a text file, rolling to a new file based on a filename template (usually including the date).     /// </summary>     /// <remarks>     /// <para>     /// A rolling log file is achieved by including the date in the filename, so that when the date changes     /// a different file is used.     /// </para>     /// <para>     /// Available tokens are DateTime (a UTC DateTimeOffset) and LocalDateTime (a local DateTimeOffset),      /// as well as ActivityId, AppData, AppDomain, ApplicationName, MachineName,      /// ProcessId, ProcessName, and User. These use standard .NET      /// format strings, e.g. "Trace{DateTime:yyyyMMddTHH}.log" would generate a different log name     /// each hour.     /// </para>     /// <para>     /// The default filePathTemplate is "{ApplicationName}-{DateTime:yyyy-MM-dd}.log", which matches     /// the format used by Microsoft.VisualBasic.Logging.FileLogTraceListener (except that it uses     /// UTC time instead of local time).     /// </para>     /// </remarks>     public class RollingFileTraceListener : TraceListenerBase {         // Default format matches Microsoft.VisualBasic.Logging.FileLogTraceListener         private const string DefaultFilePathTemplate = "{ApplicationName}-{DateTime:yyyy-MM-dd}.log";          // Default format matches Microsoft.VisualBasic.Logging.FileLogTraceListener         public const string DefaultTemplate = "{DateTime:u} [{Thread}] {EventType} {Source} {Id}: {Message}{Data}";          private static readonly string[] SupportedAttributes = {             "template", "Template",             "convertWriteToEvent", "ConvertWriteToEvent",         };          readonly TraceFormatter _traceFormatter = new();         private readonly RollingTextWriter _rollingTextWriter;          /// <summary>         /// Constructor. Writes to a rolling text file using the default name.         /// </summary>         public RollingFileTraceListener()             : this(DefaultFilePathTemplate) { }          /// <summary>         /// Constructor with initializeData.         /// </summary>         /// <param name="filePathTemplate">Template filename to log to; may use replacement parameters.</param>         /// <remarks>         /// <para>         /// A rolling log file is achieved by including the date in the filename, so that when the date changes         /// a different file is used.         /// </para>         /// <para>         /// Available tokens are DateTime (a UTC DateTimeOffset) and LocalDateTime (a local DateTimeOffset),          /// as well as ApplicationName, ProcessId, ProcessName and MachineName. These use standard .NET          /// format strings, e.g. "Trace{DateTime:yyyyMMddTHH}.log" would generate a different log name         /// each hour.         /// </para>         /// <para>         /// The default filePathTemplate is "{ApplicationName}-{DateTime:yyyy-MM-dd}.log", which matches         /// the format used by Microsoft.VisualBasic.Logging.FileLogTraceListener (except that it uses         /// UTC time instead of local time).         /// </para>         /// <para>         /// To get behaviour that exactly matches FileLogTraceListener,          /// use "{ApplicationName}-{LocalDateTime:yyyy-MM-dd}.log".         /// </para>         /// </remarks>         public RollingFileTraceListener(string filePathTemplate) {             _rollingTextWriter = string.IsNullOrEmpty(filePathTemplate)                 ? new RollingTextWriter(DefaultFilePathTemplate)                 : RollingTextWriter.Create(filePathTemplate);         }           /// <summary>         /// Gets or sets whether calls to the Trace class static Write and WriteLine methods should be converted to Verbose events,         /// and then filtered and formatted (otherwise they are output directly to the file).         /// </summary>         [SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults",             MessageId = "System.Boolean.TryParse(System.String,System.Boolean@)",             Justification = "Default value is acceptable if conversion fails.")]         public bool ConvertWriteToEvent {             get {                 // Default behaviour is to convert Write to event.                 var convertWriteToEvent = true;                 if (Attributes.ContainsKey("convertWriteToEvent")) {                     bool.TryParse(Attributes["convertWriteToEvent"], out convertWriteToEvent);                 }                  return convertWriteToEvent;             }             set => Attributes["convertWriteToEvent"] = value.ToString(CultureInfo.InvariantCulture);         }          /// <summary>         /// Gets or sets the file system to use; this defaults to an adapter for System.IO.File.         /// </summary>         public IFileSystem FileSystem {             get => _rollingTextWriter.FileSystem;             set => _rollingTextWriter.FileSystem = value;         }          /// <summary>         /// Gets whether the listener internally handles thread safety         /// (or if the System.Diagnostics framework needs to co-ordinate threading).         /// </summary>         public override bool IsThreadSafe => true;          /// <summary>         /// Gets or sets the token format string to use to display trace output.         /// </summary>         /// <remarks>         /// <para>         /// See TraceFormatter for details of the supported formats.         /// </para>         /// <para>         /// The default value is "{DateTime:u} [{Thread}] {EventType} {Source} {Id}: {Message}{Data}".         /// </para>         /// <para>         /// To get a format that matches Microsoft.VisualBasic.Logging.FileLogTraceListener,          /// use the tab delimited format "{Source}&#x9;{EventType}&#x9;{Id}&#x9;{Message}{Data}".          /// (Note: In the config XML file the TAB characters are XML encoded; if specifying          /// in C# code the delimiters  would be '\t'.)         /// </para>         /// <para>         /// To get a format matching FileLogTraceListener with all TraceOutputOptions enabled, use         /// "{Source}&#x9;{EventType}&#x9;{Id}&#x9;{Message}&#x9;{Callstack}&#x9;{LogicalOperationStack}&#x9;{DateTime:u}&#x9;{ProcessId}&#x9;{ThreadId}&#x9;{Timestamp}&#x9;{MachineName}".         /// </para>         /// <para>         /// To get a format similar to that produced by System.Diagnostics.TextWriterTraceListener,         /// use "{Source} {EventType}: {Id} : {Message}{Data}".         /// </para>         /// </remarks>         public string Template {             get => Attributes.ContainsKey("template") ? Attributes["template"] : DefaultTemplate;             set => Attributes["template"] = value;         }          /// <summary>         /// Gets the template for the rolling file name.         /// </summary>         /// <remarks>         /// <para>         /// This value is part of initializeData; if the value changes the         /// listener is recreated. See the constructor parameter for details         /// of the supported formats.         /// </para>         /// </remarks>         public string FilePathTemplate => _rollingTextWriter.FilePathTemplate;          /// <summary>         /// Flushes the output buffer.         /// </summary>         public override void Flush() {             _rollingTextWriter.Flush();         }          /// <summary>         /// Allowed attributes for this trace listener.         /// </summary>         protected override string[] GetSupportedAttributes() {             return SupportedAttributes;         }          /// <summary>         /// Handles trace Write calls - either output directly to console or convert to verbose event         /// based on the ConvertWriteToEvent setting.         /// </summary>         protected override void Write(string category, string message, object data) {             // Either format as event or write direct to stream based on flag.             if (ConvertWriteToEvent) {                 base.Write(category, message, data);             }             else {                 _rollingTextWriter.Write(null, message);             }         }          /// <summary>         /// Handles trace Write calls - either output directly to console or convert to verbose event         /// based on the ConvertWriteToEvent setting.         /// </summary>         protected override void WriteLine(string category, string message, object data) {             // Either format as event or write direct to stream based on flag.             if (ConvertWriteToEvent) {                 base.WriteLine(category, message, data);             }             else {                 _rollingTextWriter.WriteLine(null, message);             }         }          /// <summary>         /// Write trace event with data.         /// </summary>         protected override void WriteTrace(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             string message, Guid? relatedActivityId, object[] data) {             // NOTE: In Microsoft.VisualBasic.Logging.FileLogTraceListener the following are output separated              // by a configurable delimiter:              //   source, TraceEventType, id, message,              // Then, based on TraceOutputOptions:             //   call stack, logical operation stack, datetime (UTC, format "u"), process id, thread id, timestamp             // Then, based on listener options:             //   host name              // Supporting a template string kind of makes TraceOutputOptions redundant,             // but could support for backwards compatibility.              // i.e. if any T-O-O are set, then append them anyway??              var output = _traceFormatter.Format(Template,                 this,                 eventCache,                 source,                 eventType,                 id,                 message,                 relatedActivityId,                 data             );             _rollingTextWriter.WriteLine(eventCache, output);         }          protected override void Dispose(bool disposing) {             if (disposing) {                 if (_rollingTextWriter != null) {                     _rollingTextWriter.Dispose();                 }             }              base.Dispose(disposing);         }     } }using System; using System.Diagnostics; using System.Globalization; using System.IO;  namespace Xpand.Extensions.Tracing {     class RollingTextWriter : IDisposable {         const int MaxStreamRetries = 5;          private string _currentPath;         private TextWriter _currentWriter;         private readonly object _fileLock = new();         private IFileSystem _fileSystem = new FileSystem();         readonly TraceFormatter _traceFormatter = new();          public RollingTextWriter(string filePathTemplate) {             FilePathTemplate = filePathTemplate;         }          /// <summary>         /// Create RollingTextWriter with filePathTemplate which might contain 1 environment variable in front.         /// </summary>         /// <param name="filePathTemplate"></param>         /// <returns></returns>         public static RollingTextWriter Create(string filePathTemplate) {             var segments = filePathTemplate.Split('%');             if (segments.Length > 3) {                 throw new ArgumentException("InitializeData should contain maximum 1 environment variable.",                     nameof(filePathTemplate));             }              if (segments.Length == 3) {                 var variableName = segments[1];                 var rootFolder = Environment.GetEnvironmentVariable(variableName);                 if (String.IsNullOrEmpty(rootFolder)) {                     if (variableName.Equals("ProgramData", StringComparison.CurrentCultureIgnoreCase) &&                         (Environment.OSVersion.Version.Major <=                          5)) //XP or below: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724832%28v=vs.85%29.aspx                     { //So the host program could run well in XP and Windows 7 without changing the config file.                         rootFolder = Path.Combine(Environment.GetEnvironmentVariable("AllUsersProfile")!,                             "Application Data");                     }                     else {                         throw new ArgumentException("Environment variable is not recognized in InitializeData.",                             nameof(filePathTemplate));                     }                 }                  var filePath = rootFolder + segments[2];                 return new RollingTextWriter(filePath);             }              return new RollingTextWriter(filePathTemplate);         }          public string FilePathTemplate { get; }          public IFileSystem FileSystem {             get => _fileSystem;             set {                 lock (_fileLock) {                     _fileSystem = value;                 }             }         }          public void Flush() {             lock (_fileLock) {                 if (_currentWriter != null) {                     _currentWriter.Flush();                 }             }         }          public void Write(TraceEventCache eventCache, string value) {             string filePath = GetCurrentFilePath(eventCache);             lock (_fileLock) {                 EnsureCurrentWriter(filePath);                 _currentWriter.Write(value);             }         }          public void WriteLine(TraceEventCache eventCache, string value) {             string filePath = GetCurrentFilePath(eventCache);             lock (_fileLock) {                 EnsureCurrentWriter(filePath);                 _currentWriter.WriteLine(value);             }         }          private void EnsureCurrentWriter(string path) {             // NOTE: This is called inside lock(_fileLock)             if (_currentPath != path) {                 if (_currentWriter != null) {                     _currentWriter.Close();                     _currentWriter.Dispose();                     _currentWriter = null;                     _currentPath = null;                 }                  var num = 0;                 var stream = default(Stream);                  while (stream == null && num < MaxStreamRetries) {                     var fullPath = num == 0 ? path : GetFullPath(path, num);                     try {                         stream = FileSystem.Open(fullPath, FileMode.Append, FileAccess.Write, FileShare.Read);                          _currentWriter = new StreamWriter(stream);                         _currentPath = path;                          return;                     }                     catch (DirectoryNotFoundException) {                         throw;                     }                     catch (IOException) { }                      num++;                 }                  throw new InvalidOperationException("Exhausted possible logfile names");             }         }          static string GetFullPath(string path, int num) {             var extension = Path.GetExtension(path);             return path.Insert(path.Length - extension.Length, "-" + num.ToString(CultureInfo.InvariantCulture));         }          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework",             MessageId = "System.DateTimeOffset", Justification = "Deliberate dependency, .NET 2.0 SP1 required.")]         private string GetCurrentFilePath(TraceEventCache eventCache) {             var result = StringTemplate.Format(CultureInfo.CurrentCulture, FilePathTemplate,                 delegate(string name, out object value) {                     switch (name.ToUpperInvariant()) {                         case "ACTIVITYID":                             value = Trace.CorrelationManager.ActivityId;                             break;                         case "APPDATA":                             value = _traceFormatter.HttpTraceContext.AppDataPath;                             break;                         case "APPDOMAIN":                             value = AppDomain.CurrentDomain.FriendlyName;                             break;                         case "APPLICATIONNAME":                             value = _traceFormatter.FormatApplicationName();                             break;                         case "DATETIME":                         case "UTCDATETIME":                             value = TraceFormatter.FormatUniversalTime(eventCache);                             break;                         case "LOCALDATETIME":                             value = TraceFormatter.FormatLocalTime(eventCache);                             break;                         case "MACHINENAME":                             value = Environment.MachineName;                             break;                         case "PROCESSID":                             value = _traceFormatter.FormatProcessId(eventCache);                             break;                         case "PROCESSNAME":                             value = _traceFormatter.FormatProcessName();                             break;                         case "USER":                             value = Environment.UserDomainName + "-" + Environment.UserName;                             break;                         default:                             value = "{" + name + "}";                             return true;                     }                      return true;                 });             return result;         }          public void Dispose() {             Dispose(true);             GC.SuppressFinalize(this);         }          protected virtual void Dispose(bool disposing) {             if (disposing) {                 if (_currentWriter != null) {                     _currentWriter.Dispose();                 }             }         }     } }using System; using System.Collections.Generic; using System.Text;  namespace Xpand.Extensions.Tracing {     /// <summary>     /// Formats structured strings similar to a composite format string      /// but using a template with named, rather than positional, arguments.     /// </summary>     public static class StringTemplate {         // TODO: Add support for objects (in particular anonymous objects)         // as the source of properties          // TODO: Allow instances to be created (make the class non-static),         // that prepare the template in advance and allow fast binding.         // Maybe something similar to Regex compiled?          /*         string _template;              public StringTemplate(string template)         {             _template = template;         }              public string Bind(StringTemplate.GetValue getValue)          {             return Format(null, _template, getValue);         }              public string Bind(IDictionary<string,object> arguments)         {             return Format(null, _template, arguments.TryGetValue);         }              public string Bind(IFormatProvider provider, StringTemplate.GetValue getValue)         {             return Format(provider, _template, getValue);         }              public string Bind(IFormatProvider provider, IDictionary<string, object> arguments)         {             return Format(provider, _template, arguments.TryGetValue);         }         */          /// <summary>         /// Replaces named template items in a specified string          /// with the string representation of a corresponding named object          /// from the specified dictionary.          /// A specified parameter supplies culture-specific formatting information.         /// </summary>         /// <param name="template">A template string (see Remarks).</param>         /// <param name="arguments">A dictionary that contains named objects to format.</param>         /// <returns>A copy of template in which the template items have been replaced          /// by the string representation of the corresponding objects from arguments.</returns>         /// <exception cref="ArgumentNullException">template or arguments is null.</exception>         /// <exception cref="FormatException">template is invalid,          /// or one of the named template items cannot be provided         /// (when the named key does not exist in the arguments IDictionary).</exception>         /// <remarks>         /// <para>         /// Note that argument names may or may not be case-sensitive depending on the         /// comparer used by the dictionary. To get case-insensitive behaviour, use         /// a dictionary that has a case-insensitive comparer.         /// </para>         /// <para>         /// For implementations where a user-supplied template is used to format          /// arguments provided by the system it is recommended that arguments         /// are case-insensitive.         /// </para>         /// </remarks>         public static string Format(string template, IDictionary<string, object> arguments) {             return Format(null, template, arguments);         }          /// <summary>         /// Replaces named template items in a specified string          /// with the string representation of a corresponding named object          /// provided by the passed function.          /// A specified parameter supplies culture-specific formatting information.         /// </summary>         /// <param name="template">A template string (see Remarks).</param>         /// <param name="getValue">An function that supplies named objects to format.</param>         /// <returns>A copy of template in which the template items have been replaced          /// by the string representation of the corresponding objects supplied by getValue.</returns>         /// <exception cref="ArgumentNullException">template or the getValue callback is null.</exception>         /// <exception cref="FormatException">template is invalid,          /// or one of the named template items cannot be provided         /// (getValue returns false when that item is requested).</exception>         /// <remarks>         /// <para>         /// Note that argument names may or may not be case-sensitive depending on the         /// comparer used by the dictionary. To get case-insensitive behaviour, use         /// a dictionary that has a case-insensitive comparer.         /// </para>         /// <para>         /// For implementations where a user-supplied template is used to format          /// arguments provided by the system it is recommended that arguments         /// are case-insensitive.         /// </para>         /// </remarks>         public static string Format(string template, GetValue getValue) {             return Format(null, template, getValue);         }          /// <summary>         /// Replaces named template items in a specified string          /// with the string representation of a corresponding named object          /// from the specified dictionary.          /// A specified parameter supplies culture-specific formatting information.         /// </summary>         /// <param name="provider">An object that supplies culture-specific formatting information.</param>         /// <param name="template">A template string (see Remarks).</param>         /// <param name="arguments">A dictionary that contains named objects to format.</param>         /// <returns>A copy of template in which the template items have been replaced          /// by the string representation of the corresponding objects from arguments.</returns>         /// <exception cref="ArgumentNullException">template or arguments is null.</exception>         /// <exception cref="FormatException">template is invalid,          /// or one of the named template items cannot be provided         /// (when the named key does not exist in the arguments IDictionary).</exception>         /// <remarks>         /// <para>         /// Note that argument names may or may not be case-sensitive depending on the         /// comparer used by the dictionary. To get case-insensitive behaviour, use         /// a dictionary that has a case-insensitive comparer.         /// </para>         /// <para>         /// For implementations where a user-supplied template is used to format          /// arguments provided by the system it is recommended that arguments         /// are case-insensitive.         /// </para>         /// </remarks>         public static string Format(IFormatProvider provider, string template, IDictionary<string, object> arguments) {             if (arguments == null) {                 throw new ArgumentNullException(nameof(arguments));             }              return Format(provider, template, arguments.TryGetValue);         }          /// <summary>         /// Replaces named template items in a specified string          /// with the string representation of a corresponding named object          /// provided by the passed function.          /// A specified parameter supplies culture-specific formatting information.         /// </summary>         /// <param name="provider">An object that supplies culture-specific formatting information.</param>         /// <param name="template">A template string (see Remarks).</param>         /// <param name="getValue">An function that supplies named objects to format.</param>         /// <returns>A copy of template in which the template items have been replaced          /// by the string representation of the corresponding objects supplied by getValue.</returns>         /// <exception cref="ArgumentNullException">template or the getValue callback is null.</exception>         /// <exception cref="FormatException">template is invalid,          /// or one of the named template items cannot be provided         /// (getValue returns false when that item is requested).</exception>         /// <remarks>         /// <para>         /// Note that argument names may or may not be case-sensitive depending on the         /// comparer used by the dictionary. To get case-insensitive behaviour, use         /// a dictionary that has a case-insensitive comparer.         /// </para>         /// <para>         /// For implementations where a user-supplied template is used to format          /// arguments provided by the system it is recommended that arguments         /// are case-insensitive.         /// </para>         /// </remarks>         public static string Format(IFormatProvider provider, string template, GetValue getValue) {             if (template == null) {                 throw new ArgumentNullException(nameof(template));             }              if (getValue == null) {                 throw new ArgumentNullException(nameof(getValue));             }              char[] chArray = template.ToCharArray(0, template.Length);             int index = 0;             int length = chArray.Length;              ICustomFormatter formatter = null;             if (provider != null) {                 formatter = (ICustomFormatter)provider.GetFormat(typeof(ICustomFormatter));             }              StringBuilder builder = new StringBuilder();             while (index < length) {                 var ch = chArray[index];                 index++;                 if (ch == '}') {                     if ((index < length) && (chArray[index] == '}')) {                         // Literal close curly brace                         builder.Append('}');                         index++;                     }                     else {                         throw new FormatException("Input string was not a correct template");                     }                 }                 else if (ch == '{') {                     if ((index < length) && (chArray[index] == '{')) {                         // Literal open curly brace                         builder.Append('{');                         index++;                     }                     else {                         // Template item:                         if (index == length) {                             throw new FormatException("Input string was not a correct template");                         }                          // Argument name                         int nameStart = index;                         ch = chArray[index];                         index++;                         if (!(ch == '_'                               || ch == '@'                               || ch is >= 'a' and <= 'z'                               || ch is >= 'A' and <= 'Z')) {                             throw new FormatException("Input string was not a correct template");                         }                          while ((index < length) &&                                (ch == '.' || ch == '-' || ch == '_' || ch == '@'                                 || ch is >= '0' and <= '9'                                 || ch is >= 'a' and <= 'z'                                 || ch is >= 'A' and <= 'Z')) {                             ch = chArray[index];                             index++;                         }                          int nameEnd = index - 1;                         if (nameEnd == nameStart) {                             throw new FormatException("Input string was not a correct template");                         }                          string argumentName = new string(chArray, nameStart, nameEnd - nameStart);                         if (!getValue(argumentName, out var arg)) {                             throw new FormatException("Input string was not a correct template");                         }                          // Skip blanks                         while ((index < length) && (ch == ' ')) {                             ch = chArray[index];                             index++;                         }                          // Argument alignment                         int width = 0;                         bool leftAlign = false;                         if (ch == ',') {                             if (index == length) {                                 throw new FormatException("Input string was not a correct template");                             }                              ch = chArray[index];                             index++;                             while ((index < length) && (ch == ' ')) {                                 ch = chArray[index];                                 index++;                             }                              if (index == length) {                                 throw new FormatException("Input string was not a correct template");                             }                              if (ch == '-') {                                 leftAlign = true;                                 if (index == length) {                                     throw new FormatException("Input string was not a correct template");                                 }                                  ch = chArray[index];                                 index++;                             }                              if ((ch < '0') || (ch > '9')) {                                 throw new FormatException("Input string was not a correct template");                             }                              while ((index < length) && ch is >= '0' and <= '9') {                                 // TODO: What if number too large for Int32, i.e. throw exception                                 width = width * 10 + (ch - 0x30);                                 ch = chArray[index];                                 index++;                             }                         }                          // Skip blanks                         while ((index < length) && (ch == ' ')) {                             ch = chArray[index];                             index++;                         }                          // Format string                         string formatString = null;                         if (ch == ':') {                             if (index == length) {                                 throw new FormatException("Input string was not a correct template");                             }                              int formatStart = index;                             ch = chArray[index];                             index++;                             while ((index < length) && (ch != '{') && (ch != '}')) {                                 ch = chArray[index];                                 index++;                             }                              int formatEnd = index - 1;                             if (formatEnd >= formatStart) {                                 formatString = new string(chArray, formatStart, formatEnd - formatStart);                             }                         }                          // Insert formatted argument                         if (ch != '}') {                             throw new FormatException("Input string was not a correct template");                         }                          string argumentValue = null;                         if (formatter != null) {                             argumentValue = formatter.Format(formatString, arg, provider);                         }                          if (argumentValue == null) {                             if (arg is IFormattable formattable) {                                 argumentValue = formattable.ToString(formatString, provider);                             }                             else if (arg != null) {                                 argumentValue = arg.ToString();                             }                         }                          argumentValue ??= string.Empty;                          int paddingCount = width - argumentValue.Length;                         if (!leftAlign && (paddingCount > 0)) {                             builder.Append(' ', paddingCount);                         }                          builder.Append(argumentValue);                         if (leftAlign && (paddingCount > 0)) {                             builder.Append(' ', paddingCount);                         }                     }                 }                 else {                     // Literal -- scan up until next curly brace                     int literalStart = index - 1;                     while (index < length) {                         ch = chArray[index];                         if (ch == '{' || ch == '}') {                             break;                         }                          index++;                     }                      builder.Append(chArray, literalStart, index - literalStart);                 }             }              return builder.ToString();         }          /// <summary>         /// Provides named argument values for the StringTemplate.         /// </summary>         /// <param name="name">Name of the argument required.</param>         /// <param name="value">Value of the argument, if it exists.</param>         /// <returns>true if the argument name is valid, i.e. the value can be supplied; false if the argument name is invalid (usually treated as an error)</returns>         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]         public delegate bool GetValue(string name, out object value);     } }using System; using System.Diagnostics; using System.Globalization; using System.IO; using System.Reflection; using System.Runtime.InteropServices; using System.Text; using System.Text.RegularExpressions; using System.Threading; using Fasterflect; using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.Tracing {     static class NativeMethods {         public static HandleRef NullHandleRef = new(null, IntPtr.Zero);          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",             "CA5122:PInvokesShouldNotBeSafeCriticalFxCopRule",             Justification =                 "Rule should only apply to .NET 4.0. See http://connect.microsoft.com/VisualStudio/feedback/details/729254/bogus-ca5122-warning-about-p-invoke-declarations-should-not-be-safe-critical")]         [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]         public static extern int GetModuleFileName(HandleRef hModule, StringBuilder buffer, int length);     }      /// <summary>     /// Adapter that wraps HttpContext.Current.     /// </summary>     public class HttpContextCurrentAdapter : IHttpTraceContext {         static string AppData = "~/App_Data";          /// <summary>         /// Gets the physical file path that corresponds to the App_Data directory, if in the context of a web request.         /// </summary>         public string AppDataPath {             get {                 var context = AppDomain.CurrentDomain.Web().HttpContext();                 if (context == null) {                     return null;                 }                  string path = null;                 var server = context.GetPropertyValue("Server");                 if (server != null) {                     //AppDomain.CurrentDomain.GetData("DataDirectory");                     //return context.Server.MapPath(AppData);                     //HttpRuntime.AppDomainAppVirtualPath                     path = (string)server.CallMethod("MapPath", AppData);                 }                  return path;             }         }          /// <summary>         /// Gets the virtual path of the current request, if in the context of a web request.          /// </summary>         public string RequestPath {             get {                 var context = AppDomain.CurrentDomain.Web().HttpContext();                 if (context == null) return null;                 try {                     var request = AppDomain.CurrentDomain.Web().GetPropertyValue("Request");                     if (request == null) return null;                     return (string)request.GetPropertyValue("Path");                 }                 catch (Exception) {                     return null;                 }             }         }          /// <summary>         /// Gets information about the URL of the current request, if in the context of a web request.          /// </summary>         public Uri RequestUrl {             get {                 var context = AppDomain.CurrentDomain.Web().HttpContext();                 if (context == null) return null;                 try {                     var request = context.GetPropertyValue("Request");                     if (request == null) return null;                     return (Uri)context.GetPropertyValue("Url");                 }                 catch (Exception) {                     return null;                 }             }         }          /// <summary>         /// Gets the IP host address of the remote client, if in the context of a web request.          /// </summary>         public string UserHostAddress {             get {                 var context = AppDomain.CurrentDomain.Web().HttpContext();                 if (context == null) return null;                 try {                     var request = context.GetPropertyValue("Request");                     if (request == null) return null;                     return (string)request.GetPropertyValue("UserHostAddress");                 }                 catch (Exception) {                     return null;                 }             }         }     }      public interface IHttpTraceContext {         /// <summary>         /// Gets the physical file path that corresponds to the App_Data directory, if in the context of a web request.         /// </summary>         string AppDataPath { get; }          /// <summary>         /// Gets the virtual path of the current request, if in the context of a web request.          /// </summary>         string RequestPath { get; }          /// <summary>         /// Gets information about the URL of the current request, if in the context of a web request.          /// </summary>         Uri RequestUrl { get; }          /// <summary>         /// Gets the IP host address of the remote client, if in the context of a web request.          /// </summary>         string UserHostAddress { get; }     }      /// <summary>     /// Formats trace output using a template.     /// </summary>     /// <remarks>     /// <para>     /// Uses the StringTemplate.Format function to format trace output using a supplied template     /// and trace information. The formatted event can then be written to the console, a     /// file, or other text-based output.     /// </para>     /// <para>     /// The following parameters are available in the template string:     /// Data, Data0, EventType, Id, Message, ActivityId, RelatedActivityId, Source,      /// Callstack, DateTime (or UtcDateTime), LocalDateTime, LogicalOperationStack,      /// ProcessId, ThreadId, Timestamp, MachineName, ProcessName, ThreadName,     /// ApplicationName, MessagePrefix, AppDomain.     /// </para>     /// <para>     /// An example template that generates the same output as the ConsoleListener is:     /// "{Source} {EventType}: {Id} : {Message}".     /// </para>     /// </remarks>     public class TraceFormatter {         const int MaxPrefixLength = 40;         const string PrefixContinuation = "...";          static readonly Regex ControlCharRegex = new(@"\p{C}", RegexOptions.Compiled);          string _applicationName;         int _processId;         string _processName;          /// <summary>         /// Gets or sets the context for ASP.NET web trace information.         /// </summary>         public IHttpTraceContext HttpTraceContext { get; set; } = new HttpContextCurrentAdapter();          /// <summary>         /// Formats a trace event, inserted the provided values into the provided template.         /// </summary>         /// <returns>A string containing the values formatted using the provided template.</returns>         /// <remarks>         /// <para>         /// Obsolete. Should use the overload that includes listener instead.         /// </para>         /// </remarks>         [Obsolete("Should use the overload that includes listener instead.")]         public string Format(string template, TraceEventCache eventCache, string source,             TraceEventType eventType, int id, string message,             Guid? relatedActivityId, object[] data) {             return Format(template, null, eventCache, source, eventType, id, message, relatedActivityId, data);         }          /// <summary>         /// Formats a trace event, inserted the provided values into the provided template.         /// </summary>         /// <returns>A string containing the values formatted using the provided template.</returns>         /// <remarks>         /// <para>         /// Uses the StringTemplate.Format function to format trace output using a supplied template         /// and trace information. The formatted event can then be written to the console, a         /// file, or other text-based output.         /// </para>         /// <para>         /// The following parameters are available in the template string:         /// Data, Data0, EventType, Id, Message, ActivityId, RelatedActivityId, Source,          /// Callstack, DateTime (or UtcDateTime), LocalDateTime, LogicalOperationStack,          /// ProcessId, ThreadId, Timestamp, MachineName, ProcessName, ThreadName,         /// ApplicationName, PrincipalName, WindowsIdentityName.         /// </para>         /// <para>         /// An example template that generates the same output as the ConsoleListener is:         /// "{Source} {EventType}: {Id} : {Message}".         /// </para>         /// </remarks>         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework",             MessageId = "System.DateTimeOffset", Justification = "Deliberate dependency, .NET 2.0 SP1 required.")]         public string Format(string template, TraceListener listener, TraceEventCache eventCache,             string source, TraceEventType eventType, int id, string message,             Guid? relatedActivityId, object[] data) {             var result = StringTemplate.Format(CultureInfo.CurrentCulture, template,                 delegate(string name, out object value) {                     switch (name.ToUpperInvariant()) {                         case "EVENTTYPE":                             value = eventType;                             break;                         case "ID":                             value = id;                             break;                         case "MESSAGE":                             value = message;                             break;                         case "MESSAGEPREFIX":                             value = FormatPrefix(message);                             break;                         case "SOURCE":                             value = source;                             break;                         case "DATETIME":                         case "UTCDATETIME":                             value = FormatUniversalTime(eventCache);                             break;                         case "LOCALDATETIME":                             value = FormatLocalTime(eventCache);                             break;                         case "THREADID":                             value = FormatThreadId(eventCache);                             break;                         case "THREAD":                             value = Thread.CurrentThread.Name ?? FormatThreadId(eventCache);                             break;                         case "THREADNAME":                             value = Thread.CurrentThread.Name;                             break;                         case "ACTIVITYID":                             value = Trace.CorrelationManager.ActivityId;                             break;                         case "RELATEDACTIVITYID":                             value = relatedActivityId;                             break;                         case "DATA":                             value = FormatData(data);                             break;                         case "DATA0":                             value = FormatData(data, 0);                             break;                         case "CALLSTACK":                             value = FormatCallstack(eventCache);                             break;                         case "LOGICALOPERATIONSTACK":                             value = FormatLogicalOperationStack(eventCache);                             break;                         case "PROCESSID":                             value = FormatProcessId(eventCache);                             break;                         case "TIMESTAMP":                             value = FormatTimeStamp(eventCache);                             break;                         case "MACHINENAME":                             value = Environment.MachineName;                             break;                         case "PROCESSNAME":                             value = FormatProcessName();                             break;                         case "USER":                             value = Environment.UserDomainName + "\\" + Environment.UserName;                             break;                         case "PROCESS":                             value = Environment.CommandLine;                             break;                         case "APPLICATIONNAME":                             value = FormatApplicationName();                             break;                         case "APPDOMAIN":                             value = AppDomain.CurrentDomain.FriendlyName;                             break;                         case "PRINCIPALNAME":                             value = FormatPrincipalName();                             break;                         case "WINDOWSIDENTITYNAME":                             throw new NotImplementedException();                         // value = FormatWindowsIdentityName();                         case "REQUESTURL":                             value = HttpTraceContext.RequestUrl;                             break;                         case "REQUESTPATH":                             value = HttpTraceContext.RequestPath;                             break;                         case "USERHOSTADDRESS":                             value = HttpTraceContext.UserHostAddress;                             break;                         case "APPDATA":                             value = HttpTraceContext.AppDataPath;                             break;                         case "LISTENER":                             value = (listener == null) ? "" : listener.Name;                             break;                         default:                             value = "{" + name + "}";                             return true;                     }                      return true;                 });             return result;         }          internal object FormatApplicationName() {             EnsureApplicationName();             object value = _applicationName;             return value;         }          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework",             MessageId = "System.DateTimeOffset", Justification = "Deliberate dependency, .NET 2.0 SP1 required.")]         internal static object FormatLocalTime(TraceEventCache eventCache) {             object value = eventCache == null ? DateTimeOffset.Now : ((DateTimeOffset)eventCache.DateTime).ToLocalTime();             return value;         }          internal object FormatProcessId(TraceEventCache eventCache) {             object value;             if (eventCache == null) {                 EnsureProcessInfo();                 value = _processId;             }             else {                 value = eventCache.ProcessId;             }              return value;         }          internal object FormatProcessName() {             EnsureProcessInfo();             object value = _processName;             return value;         }          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Portability", "CA1903:UseOnlyApiFromTargetedFramework",             MessageId = "System.DateTimeOffset", Justification = "Deliberate dependency, .NET 2.0 SP1 required.")]         internal static DateTimeOffset FormatUniversalTime(TraceEventCache eventCache) {             DateTimeOffset value;             value = eventCache == null ? DateTimeOffset.UtcNow : ((DateTimeOffset)eventCache.DateTime).ToUniversalTime();             return value;         }          private void EnsureApplicationName() {             if (_applicationName == null) {                 //applicationName = Path.GetFileNameWithoutExtension(Application.ExecutablePath);                 var entryAssembly = Assembly.GetEntryAssembly();                 if (entryAssembly == null) {                     var moduleFileName = new StringBuilder(260);                     int size = NativeMethods.GetModuleFileName(NativeMethods.NullHandleRef, moduleFileName,                         moduleFileName.Capacity);                     if (size > 0) {                         _applicationName = Path.GetFileNameWithoutExtension(moduleFileName.ToString());                         return;                     }                     //I don't want to raise any error here since I have a graceful result at the end.                 }                  _applicationName = Path.GetFileNameWithoutExtension(entryAssembly?.Location);             }         }          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security",             "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands")]         private void EnsureProcessInfo() {             if (_processName == null) {                 using (Process process = Process.GetCurrentProcess()) {                     _processId = process.Id;                     _processName = process.ProcessName;                 }             }         }          private static object FormatCallstack(TraceEventCache eventCache) {             object value = eventCache?.Callstack;              return value;         }          private static object FormatData(object[] data) {             StringBuilder builder = new StringBuilder();             if (data != null) {                 for (int i = 0; i < data.Length; i++) {                     if (i != 0) {                         builder.Append(",");                     }                      if (data[i] != null) {                         builder.Append(data[i]);                     }                 }             }              object value = builder.ToString();             return value;         }          private static object FormatData(object[] data, int index) {             object value;             if (data != null && data.Length > index) {                 value = data[index];             }             else {                 value = null;             }              return value;         }          private static object FormatLogicalOperationStack(TraceEventCache eventCache) {             object value;             var stack = eventCache == null ? Trace.CorrelationManager.LogicalOperationStack : eventCache.LogicalOperationStack;              if (stack is { Count: > 0 }) {                 StringBuilder stackBuilder = new StringBuilder();                 foreach (object o in stack) {                     if (stackBuilder.Length > 0) stackBuilder.Append(", ");                     stackBuilder.Append(o);                 }                  value = stackBuilder.ToString();             }             else {                 value = null;             }              return value;         }          private static string FormatPrefix(string message) {             if (!string.IsNullOrEmpty(message)) {                 // Prefix is the part of the message before the first <;,.:>                 string[] split = message.Split(new[] { '.', '!', '?', ':', ';', ',', '\r', '\n' }, 2,                     StringSplitOptions.None);                 string prefix;                 if (split[0].Length <= MaxPrefixLength) {                     prefix = split[0];                 }                 else {                     prefix = split[0].Substring(0, MaxPrefixLength - PrefixContinuation.Length) + PrefixContinuation;                 }                  if (ControlCharRegex.IsMatch(prefix)) {                     prefix = ControlCharRegex.Replace(prefix, "");                 }                  return prefix;             }              return message;         }          internal static object FormatPrincipalName() {             var principal = Thread.CurrentPrincipal;             object value = "";             if (principal is { Identity:{ } }) {                 value = principal.Identity.Name;             }              return value;         }          internal static object FormatWindowsIdentityName() {             // var identity = WindowsIdentity.GetCurrent();             // object value = identity.Name;              // return value;             throw new NotImplementedException();         }          internal static object FormatThreadId(TraceEventCache eventCache) {             object value;             if (eventCache == null) {                 value = Thread.CurrentThread.ManagedThreadId;             }             else {                 value = eventCache.ThreadId;             }              return value;         }          private static object FormatTimeStamp(TraceEventCache eventCache) {             object value;             if (eventCache == null) {                 value = null;             }             else {                 value = eventCache.Timestamp;             }              return value;         }     } }using System; using System.Diagnostics; using System.Globalization;  namespace Xpand.Extensions.Tracing {     /// <summary>     /// Trace listener that forwards all calls to a single template method,     /// allowing easy implementation of custom trace listeners.     /// </summary>     /// <remarks>     /// <para>     /// This trace listener is designed to allow easy creation of custom     /// trace listeners by inheriting from this class and implementing     /// a single template method, WriteTrace.     /// </para>     /// <para>     /// The WriteTrace method combines all the various combinations     /// of trace methods from the base TraceListener class, passing     /// the full details to the template method allowing structured     /// logging.     /// </para>     /// <para>     /// By default the write methods are also converted to Verbose trace     /// events, allowing them to also be logged in a structured manner.     /// </para>     /// <para>     /// If implementing a stream-based listener, then the default     /// template methods for Write and WriteLine can also be overridden     /// to provide behaviour similar to stream-based listeners in     /// the .NET Framework.     /// </para>     /// </remarks>     public abstract class TraceListenerBase : TraceListener {         const string CategorySeparator = ": ";          // //////////////////////////////////////////////////////////         // Constructors          /// <summary>         /// Constructor used when creating from config file.          /// (The Name property is set after the TraceListener is created.)         /// </summary>         protected TraceListenerBase() { }          /// <summary>         /// Constructor used when creating dynamically in code. The name should be set in the constructor.         /// </summary>         /// <param name="name">Name of the trace listener.</param>         protected TraceListenerBase(string name)             : base(name) { }           // //////////////////////////////////////////////////////////         // Public Methods          /// <summary>         /// Closes the listener so it no longer receives tracing or debugging output.         /// </summary>         /// <remarks>         /// <para>         /// The default implementation calls Flush().         /// </para>         /// </remarks>         public override void Close() {             // Always Flush before Close             Flush();             base.Close();         }          /// <summary>         /// Writes the trace data to the listener output, if allowed by the configured filter.         /// The data is forwarded to the WriteTrace template method.         /// </summary>         public sealed override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             object data) {             if ((Filter == null) ||                 Filter.ShouldTrace(eventCache, source, eventType, id, null, null, data, null)) {                 WriteTrace(eventCache, source, eventType, id, null, null, new[] { data });             }         }          /// <summary>         /// Writes the trace data to the listener output, if allowed by the configured filter.         /// The data is forwarded to the WriteTrace template method.         /// </summary>         public sealed override void TraceData(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             params object[] data) {             if ((Filter == null) ||                 Filter.ShouldTrace(eventCache, source, eventType, id, null, null, null, data)) {                 WriteTrace(eventCache, source, eventType, id, null, null, data);             }         }          /// <summary>         /// Writes the event to the listener, if allowed by the configured filter.         /// The event is forwarded to the WriteTrace template method.         /// </summary>         public sealed override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             string message) {             if ((Filter == null) ||                 Filter.ShouldTrace(eventCache, source, eventType, id, message, null, null, null)) {                 WriteTrace(eventCache, source, eventType, id, message, null, null);             }         }          /// <summary>         /// Writes the event to the listener, formatting the message with the provided arguments,          /// but only if allowed by the configured filter.         /// The event is forwarded to the WriteTraceFormat template method if it has args, or WriteTrace without.         /// </summary>         /// <remarks>         /// <para>         /// For performance reasons the message is not formatted,          /// and the args not converted to strings,          /// unless the filter is first passed.         /// </para>         /// </remarks>         public sealed override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             string format, params object[] args) {             if ((Filter == null) ||                 Filter.ShouldTrace(eventCache, source, eventType, id, format, args, null, null)) {                 // Note: traceSource.TraceInformation(message) calls TraceEvent(..., format, null)                  // not TraceEvent(..., message), so we don't call string.Format if args is null.                 // This means that calling traceSource.TraceEvent(..., format, [object[]]null) works,                 // instead of throwing ArgumentNullException (as it should).                 // Design decision to have TraceInformation(message) work than to be 100% correct in                  // throwing exceptions when args is null.                 {                     WriteTraceFormat(eventCache, source, eventType, id, format, args);                 }             }         }          /// <summary>         /// Writes the transfer to the listener, if allowed by the configured filter.         /// The transfer is forwarded to the WriteTrace template method.         /// </summary>         public sealed override void TraceTransfer(TraceEventCache eventCache, string source, int id, string message,             Guid relatedActivityId) {             if ((Filter == null) ||                 Filter.ShouldTrace(eventCache, source, TraceEventType.Transfer, id, message, null, null, null)) {                 var traceMessage = string.Format(CultureInfo.CurrentCulture, "{0}, relatedActivityId={1}", message, relatedActivityId.ToString());                 WriteTrace(eventCache, source, TraceEventType.Transfer, id, traceMessage, relatedActivityId, null);             }         }          /// <summary>         /// Writes the object to the listener.         /// The object is forward to the Write template method as data,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void Write(object o) {             Write(null, null, o);         }          /// <summary>         /// Writes the object to the listener with the specified category.         /// The object is forwarded to the Write template method as data,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void Write(object o, string category) {             Write(category, null, o);         }          /// <summary>         /// Writes the message to the listener.         /// The message is forwarded to the Write template method,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void Write(string message) {             Write(null, message, null);         }          /// <summary>         /// Writes the message to the listener with the specified category.         /// The message is forwarded to the Write template method,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void Write(string message, string category) {             Write(category, message, null);         }          /// <summary>         /// Writes the object to the listener.         /// The object is forwarded to the Write template method as data,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void WriteLine(object o) {             WriteLine(null, null, o);         }          /// <summary>         /// Writes the object to the listener with the specified category.         /// The object is forwarded to the Write template method as data,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void WriteLine(object o, string category) {             WriteLine(category, null, o);         }          /// <summary>         /// Writes the message to the listener.         /// The message is forwarded to the Write template method,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void WriteLine(string message) {             WriteLine(null, message, null);         }          /// <summary>         /// Writes the message to the listener with the specified category.         /// The message is forwarded to the Write template method,         /// which by default is then forwarded to the WriteTrace template method.         /// </summary>         public sealed override void WriteLine(string message, string category) {             WriteLine(category, message, null);         }           // //////////////////////////////////////////////////////////         // Protected          /// <summary>         /// Template method that by default forwards the written details          /// to WriteTrace as a Verbose event         /// this should be overridden to write direct to the output if using a stream.         /// </summary>         /// <remarks>         /// <para>         /// The default implementation converts the written details to a Verbose event         /// which is forwarded to WriteTrace for output.         /// </para>         /// <para>         /// The category is prepended to any message with a separating colon (:),         /// which is similar to the format used by framework listeners.         /// The data object is traced as data, which usually means it is         /// also eventually output as text, but usually in a different field.          /// If category is specified when tracing a data object, the category         /// is treated as the message (without any colon).         /// </para>         /// <para>         /// If the listener is using a stream based output, then usually the         /// Write and WriteLine methods should be overridden to output directly to         /// the stream (with a following newline in the case of WriteLine).         /// </para>         /// <para>         /// Listeners should also consider supporting a ConvertWriteToEvent property,         /// which if set calls this base implementation, allowing the user to choose         /// if Write and WriteLine should be output directly or treated as events         /// (and formatted accordingly).         /// </para>         /// <para>         /// Listeners that do not use a continuous stream based output, but use         /// specifically formatted output, should leave this default implementation         /// and simply override WriteTrace.         /// </para>         /// </remarks>         protected virtual void Write(string category, string message, object data) {             TraceWriteAsEvent(category, message, data);         }          /// <summary>         /// Template method that by default forwards the written details          /// to WriteTrace as a Verbose event         /// this should be overridden to write direct to the output as a complete line          /// (with a newline at the end) if using a stream.         /// </summary>         /// <remarks>         /// <para>         /// The default implementation converts the written details to a Verbose event         /// which is forwarded to WriteTrace for output.         /// </para>         /// <para>         /// The category is prepended to any message with a separating colon (:),         /// which is similar to the format used by framework listeners.         /// The data object is traced as data, which usually means it is         /// also eventually output as text, but usually in a different field.          /// If category is specified when tracing a data object, the category         /// is treated as the message (without any colon).         /// </para>         /// <para>         /// If the listener is using a stream based output, then usually the         /// Write and WriteLine methods should be overridden to output directly to         /// the stream (with a following newline in the case of WriteLine).         /// </para>         /// <para>         /// Listeners should also consider supporting a ConvertWriteToEvent property,         /// which if set calls this base implementation, allowing the user to choose         /// if Write and WriteLine should be output directly or treated as events         /// (and formatted accordingly).         /// </para>         /// <para>         /// Listeners that do not use a continuous stream based output, but use         /// specifically formatted output, should leave this default implementation         /// and simply override WriteTrace.         /// </para>         /// </remarks>         protected virtual void WriteLine(string category, string message, object data) {             TraceWriteAsEvent(category, message, data);         }          /// <summary>         /// Virtual method that can be overridden by listeners who want to handle the format strings         /// before the args are resolved.         /// </summary>         /// <remarks>         /// <para>         /// The default implementation of this message uses string.Format() to resolve the args, and         /// then passes the result to WriteTrace.         /// </para>         /// <para>         /// If listeners want to intercept the message, after it has been filtered, but before the args         /// have been resolved, then they can override this method and provide an alternative implementation.         /// For example, Seq records the original format separate from the args, so that it can filter on         /// the message 'type' (based on a hash of the fixed format, ignoring the variable args) and separately         /// also filter on the separate arg values.         /// </para>         /// </remarks>         protected virtual void WriteTraceFormat(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             string format, params object[] args) {             var message = string.Format(CultureInfo.CurrentCulture, format, args);             WriteTrace(eventCache, source, eventType, id, message, null, null);         }          /// <summary>         /// Template method that must be overridden to write trace to the listener output.         /// </summary>         /// <remarks>         /// <para>         /// All of the parent interface of TraceListener is forwarded to this single         /// template method including, by default, calls to Write and WriteLine methods.         /// </para>         /// <para>         /// This means when inheriting from TraceListenerBase only this single         /// method needs to be overridden to implement a complete listener.         /// </para>         /// <para>         /// Listeners that use a continuous stream based output may also consider         /// overriding the two Write and WriteLine template methods to provide         /// direct writing behaviour, although this is not required.         /// </para>         /// </remarks>         protected abstract void WriteTrace(TraceEventCache eventCache, string source, TraceEventType eventType, int id,             string message, Guid? relatedActivityId, object[] data);           // //////////////////////////////////////////////////////////         // Private          [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization",             "CA1303:Do not pass literals as localized parameters",             MessageId =                 "Essential.Diagnostics.TraceListenerBase.WriteTrace(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Nullable<System.Guid>,System.Object[])")]         private void TraceWriteAsEvent(string category, string message, object data) {             if ((Filter == null) || Filter.ShouldTrace(null, null!, TraceEventType.Verbose, 0, message,                     new object[] { category }, data, null)) {                 if (data == null) {                     if (category != null) {                         var categoryMessage = category + CategorySeparator + message;                         WriteTrace(null, null, TraceEventType.Verbose, 0, categoryMessage, null, null);                     }                     else {                         WriteTrace(null, null, TraceEventType.Verbose, 0, message, null, null);                     }                 }                 else {                     WriteTrace(null, null, TraceEventType.Verbose, 0, category, null, new[] { data });                 }             }         }     } }using System; using System.Diagnostics; using System.Diagnostics.CodeAnalysis; using System.Linq;  namespace Xpand.Extensions.Tracing{     public interface IPush{         void Push(ITraceEvent message);              }     [Flags]     public enum RXAction{         None=0,         Subscribe=2,         OnNext=4,         OnCompleted=8,         Dispose=16,         OnError=32,         All=Subscribe|OnNext|OnCompleted|Dispose|OnError     }      public static class TraceEventExtensions {         public static string Key(this ITraceEvent traceEvent)              => $"{traceEvent.Location}{traceEvent.Action}{traceEvent.Value}{traceEvent.Source}{traceEvent.Method}{traceEvent.Value}";     }     public interface ITraceEvent{         RXAction RXAction { get; set; }         string Source{ get; set; }         TraceEventType TraceEventType{ get; set; }         string Location{ get; set; }         string SourceFilePath{ get; set; }         string Method{ get; set; }         int Line{ get; set; }         string Value{ get; set; }         string Action{ get; set; }         string Message{ get; set; }         string CallStack{ get; set; }         string LogicalOperationStack{ get; set; }         DateTime DateTime{ get; set; }         int ProcessId{ get; set; }         int Thread{ get; set; }         long Timestamp{ get; set; }         string ResultType{ get; set; }             string ApplicationTitle{ get; set; }              }      public static class TraceSourceExtensions {         [SuppressMessage("ReSharper", "ForCanBeConvertedToForeach")]         public static void Push(this TraceSource source,ITraceEvent message) {             var listeneers = source.Listeners.OfType<IPush>().ToArray();             for (var index = 0; index < listeneers.Length; index++) {                 var listeneer = listeneers[index];                 listeneer.Push(message);             }         }      } }using System.Linq.Expressions; using System; using System.Reflection; using Fasterflect;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static Expression<Action> CallExpression(this Type type, MethodInfo method, params Expression[] arguments)             => Expression.Lambda<Action>(Expression.Call(Expression.New(type), method, arguments));          public static Expression<Action> CallExpression(this Type type, string method, params Expression[] arguments)             => type.CallExpression(type.Method(method), arguments);     } }using System; using Xpand.Extensions.Fasterflect;  namespace Xpand.Extensions.TypeExtensions{ 	public static partial class TypeExtensions{ 		public static object DefaultValue(this Type t) => t.IsValueType ? Activator.CreateInstance(t) : null; 		 		public static T DefaultValue<T>(this Type t) => t.IsValueType||t.IsArray ? t.CreateInstance<T>() : default; 	} }using System; using System.Collections.Generic; using System.Globalization; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using Fasterflect; using Xpand.Extensions.AssemblyExtensions; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.TypeExtensions {     public static partial class EnumExtensions {         public static bool IsPowerOfTwo(this int value) => (value & (value - 1)) == 0;          public static IEnumerable<T> ToUniqueFlagEnumValues<T>(this IEnumerable<T> flagsEnumValues) where T : struct {             foreach (T item in flagsEnumValues) {                 int intValue = Convert.ToInt32(item);                 //if our int is a power of two, its a unique value of the flags enum                 if (intValue.IsPowerOfTwo()) {                     yield return item;                 }                     //otherwise its a combination of several unique values and we need to break it down further                 else {                     //the enum value output as binary string representation                     string fullBinaryString = Convert.ToString(intValue, 2);                     //an empty template with all 0's that is the length of our binary string                     char[] individualBitTemplate = new string('0', fullBinaryString.Length).ToCharArray();                      IEnumerable<T> individualFlagsEnumValues = fullBinaryString                         .Select((character, index) => {                                 //project each individual bit into its own binary string with 0's in every position                                 //other than the index of the individual bit                                 //Example: binary string 1111                                 //produces 4 individual binary strings                                 //0001                                 //0010                                 //0100                                 //1000                                 var template = (char[])individualBitTemplate.Clone();                                 template[index] = character;                                 return new string(template);                             })                         .Where(individualBitBinaryString => individualBitBinaryString.Any(character => character != '0'))                         .Select(individualBitBinaryString => {                                 //cast the individual binary strings back to their int value, and then into the enum value                                 int intValueOfIndividualBit = Convert.ToInt32(individualBitBinaryString, 2);                                 return (T)Enum.ToObject(typeof(T), intValueOfIndividualBit);                             });                      foreach (T value in individualFlagsEnumValues) {                         yield return value;                     }                 }             }         }         public static string ToCommaSeperatedList<T>(this IEnumerable<T> enumerable) {             var stringBuilder = new StringBuilder();             foreach (T item in enumerable) {                 stringBuilder.Append(item).Append(',');             }             //trim the last , off             if (stringBuilder.Length > 0) {                 stringBuilder.Remove(stringBuilder.Length - 1, 1);             }             return stringBuilder.ToString();         }         public static IEnumerable<T> GetIndividualValues<T>(this Enum myEnum) where T : struct {             return myEnum                 .ToString()                 .Split(new[] { ',' })                 .Select(x => (T)Enum.Parse(typeof(T), x.Trim()))                 .ToUniqueFlagEnumValues();         }         public static FlagsEnumDifference<T> GetDifference<T>(this Enum source, Enum compare) where T : struct {             IEnumerable<T> sourceValues = source.GetIndividualValues<T>();             IEnumerable<T> compareValues = compare.GetIndividualValues<T>().ToArray();              IEnumerable<T> added = compareValues.Where(value => !sourceValues.Contains(value));             IEnumerable<T> removed = sourceValues.Where(value => !compareValues.Contains(value));             return new FlagsEnumDifference<T>(added, removed);         }         /// <summary>         /// Converts the string representation of an enum to its Enum equivalent value. A return value indicates whether the operation succeeded.         /// This method does not rely on Enum.Parse and therefore will never raise any first or second chance exception.         /// </summary>         /// <param name="type">The enum target type. May not be null.</param>         /// <param name="input">The input text. May be null.</param>         /// <param name="value">When this method returns, contains Enum equivalent value to the enum contained in input, if the conversion succeeded.</param>         /// <returns>         /// true if s was converted successfully; otherwise, false.         /// </returns>         public static bool EnumTryParse(this Type type, string input, out object value) {             if (type == null)                 throw new ArgumentNullException(nameof(type));              if (!type.IsEnum)                 throw new ArgumentException(null, nameof(type));              if (input == null) {                 value = type.CreateInstance();                 return false;             }              input = input.Trim();             if (input.Length == 0) {                 value = type.CreateInstance();                 return false;             }              string[] names = Enum.GetNames(type);             if (names.Length == 0) {                 value = type.CreateInstance();                 return false;             }              Type underlyingType = Enum.GetUnderlyingType(type);             Array values = Enum.GetValues(type);             // some enums like System.CodeDom.MemberAttributes *are* flags but are not declared with Flags...             if ((!type.IsDefined(typeof(FlagsAttribute), true)) && (input.IndexOfAny(EnumSeperators) < 0))                 return EnumToObject(type, underlyingType, names, values, input, out value);              // multi value enum             string[] tokens = input.Split(EnumSeperators, StringSplitOptions.RemoveEmptyEntries);             if (tokens.Length == 0) {                 value = type.CreateInstance();                 return false;             }              ulong ul = 0;             foreach (string tok in tokens) {                 string token = tok.Trim(); // NOTE: we don't consider empty tokens as errors                 if (token.Length == 0)                     continue;                  if (!EnumToObject(type, underlyingType, names, values, token, out var tokenValue)) {                     value = type.CreateInstance();                     return false;                 }                  ulong tokenUl;                 switch (Convert.GetTypeCode(tokenValue)) {                     case TypeCode.Int16:                     case TypeCode.Int32:                     case TypeCode.Int64:                     case TypeCode.SByte:                         tokenUl = (ulong)Convert.ToInt64(tokenValue, CultureInfo.InvariantCulture);                         break;                      //case TypeCode.Byte:                     //case TypeCode.UInt16:                     //case TypeCode.UInt32:                     //case TypeCode.UInt64:                     default:                         tokenUl = Convert.ToUInt64(tokenValue, CultureInfo.InvariantCulture);                         break;                 }                  ul |= tokenUl;             }             value = Enum.ToObject(type, ul);             return true;         }          private static readonly char[] EnumSeperators = new[] { ',', ';', '+', '|', ' ' };          private static object EnumToObject(Type underlyingType, string input) {             if (underlyingType == typeof(int)) {                 if (int.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(uint)) {                 if (uint.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(ulong)) {                 if (ulong.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(long)) {                 if (long.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(short)) {                 if (short.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(ushort)) {                 if (ushort.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(byte)) {                 if (byte.TryParse(input, out var s))                     return s;             }              if (underlyingType == typeof(sbyte)) {                 if (sbyte.TryParse(input, out var s))                     return s;             }              return null;         }          private static bool EnumToObject(Type type, Type underlyingType, string[] names, Array values, string input, out object value) {             for (int i = 0; i < names.Length; i++) {                 if (string.Compare(names[i], input, StringComparison.OrdinalIgnoreCase) == 0) {                     value = values.GetValue(i);                     return true;                 }             }              if ((char.IsDigit(input[0]) || (input[0] == '-')) || (input[0] == '+')) {                 object obj = EnumToObject(underlyingType, input);                 if (obj == null) {                     value = type.CreateInstance();                     return false;                 }                 value = obj;                 return true;             }              value = type.CreateInstance();             return false;         }     }     public class FlagsEnumDifference<T> {         public FlagsEnumDifference(IEnumerable<T> added, IEnumerable<T> removed) {             Added = new List<T>(added);             Removed = new List<T>(removed);         }          public List<T> Added { get; private set; }          public List<T> Removed { get; private set; }          public override string ToString() {             return $"Added: {Added.ToCommaSeperatedList()} - Removed: {Removed.ToCommaSeperatedList()}";         }     } }using System; using Xpand.Extensions.AssemblyExtensions; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static string GetResourceString(this Type type, string name)              => type.Assembly.GetManifestResourceStream(type, name).ReadToEndAsString();                  public static string GetResourceString(this Type type, Func<string,bool> nameMatch)              => type.Assembly.GetManifestResourceStream(nameMatch).ReadToEndAsString();     } }using System; using System.Linq;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool Implements(this Type type, params string[] typeNames)             => type.GetInterfaces().Any(type1 => typeNames.Contains(type1.FullName));     } }using System; using System.Linq;  namespace Xpand.Extensions.TypeExtensions{     public static partial class TypeExtensions {         public static bool InheritsFrom(this Type type, string typeName)              => type?.FullName==typeName|| type.ParentTypes().Select(_ => _.FullName).Any(s => typeName.Equals(s,StringComparison.Ordinal));          public static bool InheritsFrom(this Type type, Type baseType){             if (type == null){                 return false;             }              if (type == baseType){                 return true;             }             if (baseType == null){                 return type.IsInterface || type == typeof(object);             }             if (baseType.IsInterface){                 return type.GetInterfaces().Contains(baseType);             }             var currentType = type;             while (currentType != null){                 if (currentType.BaseType == baseType){                     return true;                 }                 currentType = currentType.BaseType;             }             return false;         }     } }using System; using System.Linq;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool IsAssignableToGenericType(this Type givenType, Type genericType)             => givenType.GetInterfaces().Any(it => it.IsGenericType && it.GetGenericTypeDefinition() == genericType) ||                (givenType.IsGenericType && givenType.GetGenericTypeDefinition() == genericType ||                 givenType.BaseType != null && IsAssignableToGenericType(givenType.BaseType, genericType));     } }using System;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool IsDelegate(this Type type)             => typeof(Delegate).IsAssignableFrom(type);     } }using System; using System.Collections; using System.Linq;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool IsEnumerable(this Type type)             => type != typeof(String) && typeof(IEnumerable).IsAssignableFrom(type) ||                (type == typeof(IEnumerable) || type.GetInterfaces().OfType<IEnumerable>().Any());      }          }using System;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool IsNumeric(this Type type,bool decimals=false) {             if (IsNumericCore(type)) {                 if (decimals) {                     switch (Type.GetTypeCode(type)) {                         case TypeCode.Decimal:                         case TypeCode.Double:                         case TypeCode.Single:                             return true;                         default:                             return false;                     }                 }                  return true;             }              return false;         }          private static bool IsNumericCore(Type type) {             switch (Type.GetTypeCode(type)) {                 case TypeCode.Byte:                 case TypeCode.SByte:                 case TypeCode.UInt16:                 case TypeCode.UInt32:                 case TypeCode.UInt64:                 case TypeCode.Int16:                 case TypeCode.Int32:                 case TypeCode.Int64:                 case TypeCode.Decimal:                 case TypeCode.Double:                 case TypeCode.Single:                     return true;                 default:                     return false;             }         }     } }using System.Reflection;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static bool IsPublic(this MemberInfo memberInfo)              => memberInfo switch {                 FieldInfo fieldInfo => fieldInfo.IsPublic,                 PropertyInfo propertyInfo => propertyInfo.GetGetMethod()?.IsPublic == true || propertyInfo.GetSetMethod()?.IsPublic == true,                 MethodInfo methodInfo => methodInfo.IsPublic,                 EventInfo eventInfo => eventInfo.GetAddMethod()?.IsPublic == true || eventInfo.GetRemoveMethod()?.IsPublic == true,                 _ => false             };     } }using System; using System.Collections.Generic;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         private static HashSet<Type> _valueTupleSet = new HashSet<Type>(             new[] {                 typeof(ValueTuple<>), typeof(ValueTuple<,>),                 typeof(ValueTuple<,,>), typeof(ValueTuple<,,,>),                 typeof(ValueTuple<,,,,>), typeof(ValueTuple<,,,,,>),                 typeof(ValueTuple<,,,,,,>), typeof(ValueTuple<,,,,,,,>),                 typeof(Tuple<>), typeof(Tuple<,>),                 typeof(Tuple<,,>), typeof(Tuple<,,,>),                 typeof(Tuple<,,,,>), typeof(Tuple<,,,,,>),                 typeof(Tuple<,,,,,,>), typeof(Tuple<,,,,,,,>)              }         );         public static bool IsTupleFamily(this Type type)              => type.IsGenericType && _valueTupleSet.Contains(type.GetGenericTypeDefinition());     } }using System; using System.Collections.Generic; using System.Linq;   namespace Xpand.Extensions.TypeExtensions{          public static partial class TypeExtensions{         public static IEnumerable<Type> ParentTypes(this Type type){             if (type == null){                 yield break;             }             foreach (var i in type.GetInterfaces()){                 yield return i;             }             var currentBaseType = type.BaseType;             while (currentBaseType != null){                 yield return currentBaseType;                 currentBaseType= currentBaseType.BaseType;             }         }     }      }using System; using System.IO; using System.Threading.Tasks; using Xpand.Extensions.AssemblyExtensions; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.TypeExtensions {     public static partial class EnumExtensions {         public static async Task<string> ReadJson(this Type type, string resourceName)             => await type.Assembly.GetManifestResourceStream(name =>                     Path.GetFileNameWithoutExtension(name) == $"{type.Namespace}.{resourceName}")                 .ReadToEndAsStringAsync();     } }using System; using System.Linq; using Xpand.Extensions.ReflectionExtensions;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static Type RealType(this Type type)              => ((type.IsEnumerable()) && type.IsGenericType) || type.IsNullableType() ?                  type.GenericTypeArguments.First() : type.IsArray ? type.GetElementType() : type;     } }using System; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.TypeExtensions {     public static partial class TypeExtensions {         public static void WriteResourceToFile(this Type type, string resourceName, string filePath)             => type.Assembly.GetManifestResourceStream(type, resourceName).SaveToFile(filePath);      } }using System; using System.Collections.Generic; using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using System.Drawing; using System.Globalization; using System.Linq; using System.Reflection; using System.Text.Json; using System.Text.Json.Nodes; using Fasterflect; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.TypeExtensions {          [Flags]     public enum Conversion {         GuessValues = 0,         None=1,         TreatNullAsDefault = 2,         TreatWhitespaceAsDefault = 4,     }      public static class XpandConvert {         private const string ImplicitOperatorMethodName = "op_Implicit";         private const string ExplicitOperatorMethodName = "op_Explicit";         private static readonly CultureInfo DefaultCultureInfo = CultureInfo.CurrentCulture;         private const Conversion DefaultConversion = Conversion.None|Conversion.TreatNullAsDefault|Conversion.TreatWhitespaceAsDefault;          public static bool CanChange<T>(object value) {             return TryToChange(value, out T _);         }          public static bool CanChange<T>(string value, CultureInfo culture) {             return TryToChange(value, out T _, culture);         }          public static bool CanChange<T>(object value, Conversion options) {             return TryToChange(value, out T _, options);         }          public static bool CanChange<T>(object value, CultureInfo culture, Conversion options) {             return TryToChange(value, out T _, culture, options);         }          public static bool TryToChange<T>(object value, out T result) {             return TryToChange(value, out result, DefaultCultureInfo);         }          public static bool TryToChange<T>(object value, out T result, CultureInfo culture) {             return TryToChange(value, out result, culture, DefaultConversion);         }          public static bool TryToChange<T>(object value, out T result, Conversion options) {             return TryToChange(value, out result, DefaultCultureInfo, options);         }          public static bool TryToChange<T>(object value, out T result, CultureInfo culture, Conversion options) {             if (TryToChange(value, typeof(T), out var tmpResult, options, culture)) {                 result = (T)tmpResult;                 return true;             }             result = default(T);             return false;         }                  public static T Change<T>(this object value)              => value.Change<T>( DefaultCultureInfo);                  public delegate bool TryParseDelegate<T>(ReadOnlySpan<char> span, out T result);          public static T Change<T>(this object value, CultureInfo culture)              => value.Change<T>( culture, DefaultConversion);          public static T Change<T>(this object value, Conversion options)              => value.Change<T>( DefaultCultureInfo, options);          public static T Change<T>(this object value, CultureInfo culture, Conversion options)              => (T)value.Change( typeof(T), culture, options);          public static bool CanChange(this object value, Type destinationType)              => value.TryToChange( destinationType, out _);          public static bool CanChange(this object value, Type destinationType, CultureInfo culture)              => value.TryToChange( destinationType, out _, culture);          public static bool CanChange(this object value, Type destinationType, Conversion options)              => value.TryToChange( destinationType, out _, options);          public static bool CanChange(this object value, Type destinationType, CultureInfo culture, Conversion options)              => value.TryToChange( destinationType, out _, options, culture);          public static bool TryToChange(this object value, Type destinationType, out object result)              => value.TryToChange( destinationType, out result, DefaultCultureInfo);          public static bool TryToChange(this object value, Type destinationType, out object result, CultureInfo culture)              => value.TryToChange( destinationType, out result, DefaultConversion, culture);          public static bool TryToChange(this object value, Type destinationType, out object result, Conversion options)             => value.TryToChange( destinationType, out result, options, DefaultCultureInfo);          public static bool TryToChange(this object value, Type destinationType, out object result, Conversion options , CultureInfo culture) {             if (destinationType == typeof(object)) {                 result = value;                 return true;             }             if (value.IsValueNull()) {                 return TryChangeFromNull(destinationType, out result, options);             }             if (destinationType.IsInstanceOfType(value)) {                 result = value;                 if (destinationType==typeof(string)&&IsNullString(value.ToString())) {                     result = null;                 }                 return true;             }              if (destinationType == typeof(string)) {                 result = $"{value}";                 return true;             }             Type coreDestinationType = destinationType.IsGenericType ? destinationType.GenericTypeArguments.First() : destinationType;             object tmpResult = null;             if (TryChangeCore(value, coreDestinationType, ref tmpResult, culture, options)) {                 result = tmpResult;                 return true;             }             result = null;             return false;         }          private static bool TryChangeFromNull(Type destinationType, out object result, Conversion options) {             result = destinationType.DefaultValue();             if (result == null) {                 return true;             }             return (options & Conversion.TreatNullAsDefault) ==                    Conversion.TreatNullAsDefault;         }          [SuppressMessage("ReSharper", "NonConstantEqualityExpressionHasConstantResult")]         private static bool TryChangeCore(object value, Type destinationType, ref object result, CultureInfo culture, Conversion options) {             if (value.GetType() == destinationType) {                 result = value;                 return true;             }             if (value is JsonValue jsonValue) {                 var valueKind = jsonValue.GetValue<JsonElement>().ValueKind;                 if (valueKind == JsonValueKind.String&&destinationType!=typeof(string)) {                     return jsonValue.Deserialize<string>().TryToChange(destinationType,out result,options,culture);                     }                 result = jsonValue.Deserialize(destinationType);                 return true;             }             if (TryChangeByTryParse(value.ToString(), destinationType, ref result)) {                 return true;             }             if (TryChangeExplicit(value, destinationType, ExplicitOperatorMethodName, ref result)) {                 return true;             }             if (TryChangeExplicit(value, destinationType, ImplicitOperatorMethodName, ref result)) {                 return true;             }             if (TryChangeByIntermediateConversion(value, destinationType, ref result, culture, options)) {                 return true;             }             if (destinationType.IsEnum) {                 if (TryChangeToEnum(value, destinationType, ref result)) {                     return true;                 }             }              var typeConverter = TypeDescriptor.GetConverter(value.GetType());             if (typeConverter.CanConvertFrom(destinationType)) { 	            result = typeConverter.ConvertFrom(value); 	            return true;             }              if ((options & Conversion.TreatWhitespaceAsDefault) == Conversion.TreatWhitespaceAsDefault) {                 if (value is string s && s.IsWhiteSpace()) {                     result = destinationType.DefaultValue();                     return true;                 }             }             if ((options & Conversion.GuessValues) == Conversion.GuessValues) {                 if (TryChangeGuessedValues(value, destinationType, ref result)) {                     return true;                 }             }              return false;         }          static bool TryChangeNullString(object value, Type destinationType, ref object result)              => IsNullString($"{value}") && TryToChange(null, destinationType, out result, Conversion.TreatNullAsDefault);          static bool IsNullString(string asString)              => asString != String.Empty && string.CompareOrdinal("(NULL)", asString) == 0;          private static bool TryChangeGuessedValues(object value, Type destinationType, ref object result) {             if (value is char c && destinationType == typeof(bool)) {                 return TryChangeCharToBool(c, ref result);             }             var changeNullString = TryChangeNullString(value, destinationType, ref result);             if (changeNullString)                 return true;             if ( destinationType == typeof(bool)) {                 return TryChangeStringToBool(value.ToString(), ref result);             }              if (value is bool b && destinationType == typeof(char)) {                 return ChangeBoolToChar(b, out result);             }             if (destinationType ==typeof(TimeSpan)) {                 if (TryToChange(value, typeof (long), out var o,Conversion.GuessValues)) {                     result = new TimeSpan((long) o);                     return true;                 }             }              if ((destinationType == typeof (Rectangle)) &&!string.IsNullOrEmpty(value + "")){                 var rectParts =$"{value}".Split(';');                 if (rectParts.Length == 2){                     var canChange = rectParts[0].TryToChange(typeof (Point), out var point);                     if (canChange){                         canChange=rectParts[1].TryToChange(typeof (Size), out var size);                         if (canChange){                             result = new Rectangle((Point) point, (Size) size);                             return true;                         }                     }                 }             }              if ((destinationType == typeof(Size) || destinationType == typeof(Point)) && !string.IsNullOrEmpty(value + "")) {                 var strings = $"{value}".Split('x');                 if (strings.Length == 2 && (strings[0].CanChange(typeof (int)) && strings[1].CanChange(typeof (int)))){                     result = destinationType.CreateInstance(int.Parse(strings[0]), int.Parse(strings[1]));                     return true;                 }             }              return false;         }          private static bool TryChangeCharToBool(char value, ref object result) {             if ("1JYT".Contains(value.ToString(CultureInfo.InvariantCulture).ToUpper())) {                 result = true;                 return true;             }             if ("0NF".Contains(value.ToString(CultureInfo.InvariantCulture).ToUpper())) {                 result = false;                 return true;             }             return false;         }          private static bool TryChangeStringToBool(string value, ref object result) {             var trueValues = new List<string>(new[] { "1", "yes", "true" });             if (trueValues.Contains(value.Trim().ToLower())) {                 result = true;                 return true;             }             var falseValues = new List<string>(new[] { "0", "no", "false" });             if (falseValues.Contains(value.Trim().ToLower())) {                 result = false;                 return true;             }             return false;         }          private static bool ChangeBoolToChar(bool value, out object result) {             result = value ? 'T' : 'F';             return true;         }          private static bool TryChangeByTryParse(string value, Type destinationType, ref object result) {             if (destinationType == typeof(Boolean)) {                 return TryParseBool(value, ref result);             }             if (destinationType == typeof(Byte)) {                 return TryParseByte(value, ref result);             }             if (destinationType == typeof(Char)) {                 return TryParseChar(value, ref result);             }             if (destinationType == typeof(DateTime)) {                 return TryParseDateTime(value, ref result);             }             if (destinationType == typeof(Decimal)) {                 return TryParseDecimal(value, ref result);             }             if (destinationType == typeof(Double)) {                 return TryParseDouble(value, ref result);             }             if (destinationType == typeof(Int16)) {                 return TryParseInt16(value, ref result);             }             if (destinationType == typeof(Int32)) {                 return TryParseInt32(value, ref result);             }             if (destinationType == typeof(Int64)) {                 return TryParseInt64(value, ref result);             }             if (destinationType == typeof(SByte)) {                 return TryParseSByte(value, ref result);             }             if (destinationType == typeof(Single)) {                 return TryParseSingle(value, ref result);             }             if (destinationType == typeof(UInt16)) {                 return TryParseUInt16(value, ref result);             }             if (destinationType == typeof(UInt32)) {                 return TryParseUInt32(value, ref result);             }             if (destinationType == typeof(UInt64)) {                 return TryParseUInt64(value, ref result);             }             if (destinationType == typeof(Guid)) {                 return TryParseUGuid(value, ref result);             }             return false;         }          static bool TryParseUGuid(string valueString, ref object result) {             var tryParse = Guid.TryParse(valueString, out var guid);             if (tryParse)                 result = guid;             return tryParse;         }          static bool TryParseUInt64(string valueString, ref object result) {             var tryParse = UInt16.TryParse(valueString, out var @ushort);             if (tryParse)                 result = @ushort;             return tryParse;         }          static bool TryParseUInt32(string valueString, ref object result) {             var tryParse = UInt32.TryParse(valueString, out var u);             if (tryParse)                 result = u;             return tryParse;         }          static bool TryParseUInt16(string valueString, ref object result) {             var tryParse = UInt16.TryParse(valueString, out var @ushort);             if (tryParse)                 result = @ushort;             return tryParse;         }          static bool TryParseSingle(string valueString, ref object result) {             var tryParse = Single.TryParse(valueString, out var f);             if (tryParse)                 result = f;             return tryParse;         }          static bool TryParseSByte(string valueString, ref object result) {             var tryParse = SByte.TryParse(valueString, out var @sbyte);             if (tryParse)                 result = @sbyte;             return tryParse;         }          static bool TryParseInt64(string valueString, ref object result) {             var tryParse = Int64.TryParse(valueString, out var l);             if (tryParse)                 result = l;             return tryParse;         }          static bool TryParseInt32(string valueString, ref object result) {             var tryParse = Int32.TryParse(valueString, out var i);             if (tryParse)                 result = i;             return tryParse;         }          static bool TryParseInt16(string valueString, ref object result) {             var tryParse = Int16.TryParse(valueString, out var s);             if (tryParse)                 result = s;             return tryParse;         }          static bool TryParseDouble(string valueString, ref object result) {             var tryParse = double.TryParse(valueString, out var d);             if (tryParse)                 result = d;             return tryParse;         }          static bool TryParseDecimal(string value, ref object result) {             var tryParse = decimal.TryParse(value,NumberStyles.Float, CultureInfo.InvariantCulture, out var @decimal);             if (tryParse)                 result = @decimal;             return tryParse;         }          static bool TryParseDateTime(string value, ref object result) {             var tryParse = DateTime.TryParse(value, out var time);             if (tryParse)                 result = time;             return tryParse;         }          static bool TryParseChar(string value, ref object result) {             var tryParse = char.TryParse(value, out var c);             if (tryParse)                 result = c;             return tryParse;         }          static bool TryParseByte(string value, ref object result) {             var tryParse = byte.TryParse(value, out var b);             if (tryParse)                 result = b;             return tryParse;         }          static bool TryParseBool(string value, ref object result) {             var tryParse = bool.TryParse(value, out var b);             if (tryParse)                 result = b;             return tryParse;         }          private static bool TryChangeExplicit(object value, Type destinationType, string operatorMethodName, ref object result)              => TryChangeExplicit(value, value.GetType(), destinationType, operatorMethodName, ref result) ||                TryChangeExplicit(value, destinationType, destinationType, operatorMethodName, ref result);          private static bool TryChangeExplicit(object value, Type invokerType, Type destinationType, string explicitMethodName, ref object result) {             var methods = invokerType.GetMethods(BindingFlags.Public | BindingFlags.Static);             foreach (MethodInfo method in methods.Where(m => m.Name == explicitMethodName)) {                 if (destinationType.IsAssignableFrom(method.ReturnType)) {                     var parameters = method.GetParameters();                     if (parameters.Length == 1 && parameters[0].ParameterType == value.GetType()) {                         try {                             result = method.Invoke(null, new[] { value });                             return true;                         }                         catch {                             // ignored                         }                     }                 }             }             return false;         }          private static bool TryChangeByIntermediateConversion(object value, Type destinationType, ref object result, CultureInfo culture, Conversion options) {             if (value is char                 && (destinationType == typeof(double) || destinationType == typeof(float))) {                 return TryChangeCore(Convert.ToInt16(value), destinationType, ref result, culture, options);             }             if ((value is double || value is float) && destinationType == typeof(char)) {                 return TryChangeCore(Convert.ToInt16(value), destinationType, ref result, culture, options);             }             return false;         }          private static bool TryChangeToEnum(object value, Type destinationType, ref object result) {             var enumTryParse = destinationType.EnumTryParse(value.ToString(), out var o);             if (enumTryParse)                 result = o;             return enumTryParse;         }          public static object Change(this object value, Type destinationType)              => value.Change( destinationType, DefaultCultureInfo);          public static object Change(this object value, Type destinationType, CultureInfo culture)              => value.Change( destinationType, culture, DefaultConversion);          public static object Change(this object value, Type destinationType, Conversion options)              => value.Change( destinationType, DefaultCultureInfo, options);          public static object Change(this object value, Type destinationType, CultureInfo culture, Conversion options) {             if (TryToChange(value, destinationType, out var result, options, culture)) {                 return result;             }             throw new TypeCannotChanged(value, destinationType);         }     }          public class TypeCannotChanged : InvalidOperationException {         public TypeCannotChanged(object valueToConvert, Type destinationType)             : base($"'{valueToConvert}' ({valueToConvert?.GetType()}) is not convertible to '{destinationType}'.") {         }     }  } using System; using System.Collections.Generic; using Xpand.Extensions.Network;  namespace Xpand.Extensions.UriExtensions {     public static partial class UriExtensions {         static readonly HashSet<string> AllHosts=new() {"localhost", "127.0.0.1", "::1",AppDomain.CurrentDomain.LocalIPAddress()};         static readonly HashSet<string> Hosts=new() {"localhost", "127.0.0.1", "::1",AppDomain.CurrentDomain.LocalIPAddress()};         public static bool IsLocalHost(this Uri uri,bool includeLocalIP=false)              => uri.HostNameType == UriHostNameType.IPv4 || uri.HostNameType == UriHostNameType.IPv6                 ? (includeLocalIP?AllHosts:Hosts).Contains(uri.Host) : uri.IsLoopback;     } }using System; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.UriExtensions {     public static partial class UriExtensions {         public static Uri Merge(this Uri baseUri, Uri relativeUri) {             var uri = new Uri(new Uri(baseUri.ToString().EnsureEndWith("/")), relativeUri);             return new UriBuilder(baseUri) {                 Path = uri.AbsolutePath,Query = uri.Query             }.Uri;         }     } }using System; using System.Collections.Specialized; using System.Web; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.UriExtensions {     public static partial class UriExtensions {         public static Uri ModifyQuery(this Uri uri, Action<NameValueCollection> modify) {             var queryString = HttpUtility.ParseQueryString(uri?.Query!);             modify(queryString);             return new UriBuilder(uri!){                 Query = queryString.ToString()!             }.Uri;         }      } }using System; using System.Collections.Specialized; using System.Web;  namespace Xpand.Extensions.UriExtensions {     public static partial class UriExtensions {         public static NameValueCollection QueryString(this Uri uri) => HttpUtility.ParseQueryString(uri?.Query!);     } }  namespace Xpand.Extensions.Windows.Manager{     public static class Interaction{         private static string GetTitleFromAssembly(System.Reflection.Assembly callingAssembly){             try{                 return callingAssembly.GetName().Name;             }             catch (System.Security.SecurityException){                 string fullName = callingAssembly.FullName;                 int index = fullName.IndexOf(',');                 if (index >= 0){                     return fullName.Substring(0, index);                 }                  return "";             }         }           public static MsgBoxResult MsgBox(string text, string caption = null, MsgBoxStyle options = MsgBoxStyle.OkOnly){             if (string.IsNullOrEmpty(caption))                 caption = GetTitleFromAssembly(System.Reflection.Assembly.GetCallingAssembly());              if (System.Environment.OSVersion.Platform != System.PlatformID.Unix)                 return UnsafeNativeMethods.MessageBox(System.IntPtr.Zero, text, caption, options);              text = text.Replace("\"", @"\""");             caption = caption.Replace("\"", @"\""");              using System.Diagnostics.Process p = System.Diagnostics.Process.Start("notify-send", "\"" + caption + "\" \"" + text + "\"");             p?.WaitForExit();              return MsgBoxResult.Ok;         }           public static MsgBoxResult MsgBox(object objText, object objCaption){             string text = System.Convert.ToString(objText, System.Globalization.CultureInfo.InvariantCulture);             string caption = System.Convert.ToString(objCaption, System.Globalization.CultureInfo.InvariantCulture);              return MsgBox(text, caption);         }                   public static MsgBoxResult MsgBox(object objText){             return MsgBox(objText, null);         }     } }  namespace Xpand.Extensions.Windows.Manager{          public enum MsgBoxResult{         Abort = 3,         Cancel = 2,         Ignore = 5,         No = 7,         Ok = 1,         Retry = 4,         Yes = 6     } }  namespace Xpand.Extensions.Windows.Manager{     [System.Flags]     public enum MsgBoxStyle{         /// <summary>         /// OK button only (default). This member is equivalent to the Visual Basic constant <see langword="vbOKOnly" />.</summary>         OkOnly = 0,          /// <summary>         /// OK and Cancel buttons. This member is equivalent to the Visual Basic constant <see langword="vbOKCancel" />.</summary>         OkCancel = 1,          /// <summary>         /// Abort, Retry, and Ignore buttons. This member is equivalent to the Visual Basic constant <see langword="vbAbortRetryIgnore" />.</summary>         AbortRetryIgnore = 2,          /// <summary>         /// Yes, No, and Cancel buttons. This member is equivalent to the Visual Basic constant <see langword="vbYesNoCancel" />.</summary>         YesNoCancel = AbortRetryIgnore | OkCancel, // 0x00000003          /// <summary>         /// Yes and No buttons. This member is equivalent to the Visual Basic constant <see langword="vbYesNo" />.</summary>         YesNo = 4,          /// <summary>         /// Retry and Cancel buttons. This member is equivalent to the Visual Basic constant <see langword="vbRetryCancel" />.</summary>         RetryCancel = YesNo | OkCancel, // 0x00000005          /// <summary>Critical message. This member is equivalent to the Visual Basic constant <see langword="vbCritical" />.</summary>         Critical = 16, // 0x00000010          /// <summary>Warning query. This member is equivalent to the Visual Basic constant <see langword="vbQuestion" />.</summary>         Question = 32, // 0x00000020          /// <summary>Warning message. This member is equivalent to the Visual Basic constant <see langword="vbExclamation" />.</summary>         Exclamation = Question | Critical, // 0x00000030          /// <summary>Information message. This member is equivalent to the Visual Basic constant <see langword="vbInformation" />.</summary>         Information = 64, // 0x00000040          /// <summary>First button is default. This member is equivalent to the Visual Basic constant <see langword="vbDefaultButton1" />.</summary>         DefaultButton1 = 0,          /// <summary>Second button is default. This member is equivalent to the Visual Basic constant <see langword="vbDefaultButton2" />.</summary>         DefaultButton2 = 256, // 0x00000100          /// <summary>Third button is default. This member is equivalent to the Visual Basic constant <see langword="vbDefaultButton3" />.</summary>         DefaultButton3 = 512, // 0x00000200          /// <summary>Application modal message box. This member is equivalent to the Visual Basic constant <see langword="vbApplicationModal" />.</summary>         ApplicationModal = 0,          /// <summary>System modal message box. This member is equivalent to the Visual Basic constant <see langword="vbSystemModal" />.</summary>         SystemModal = 4096, // 0x00001000          /// <summary>Help text. This member is equivalent to the Visual Basic constant <see langword="vbMsgBoxHelp" />.</summary>         MsgBoxHelp = 16384, // 0x00004000          /// <summary>Right-aligned text. This member is equivalent to the Visual Basic constant <see langword="vbMsgBoxRight" />.</summary>         MsgBoxRight = 524288, // 0x00080000          /// <summary>Right-to-left reading text (Hebrew and Arabic systems). This member is equivalent to the Visual Basic constant <see langword="vbMsgBoxRtlReading" />.</summary>         MsgBoxRtlReading = 1048576, // 0x00100000          /// <summary>Foreground message box window. This member is equivalent to the Visual Basic constant <see langword="vbMsgBoxSetForeground" />.</summary>         MsgBoxSetForeground = 65536, // 0x00010000     } }namespace Xpand.Extensions.Windows.Manager{     internal static class UnsafeNativeMethods{         [System.Runtime.InteropServices.DllImport("user32.dll")]         internal static extern MsgBoxResult MessageBox(System.IntPtr hWnd, string text, string caption,             MsgBoxStyle options);     } }using System; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using System.Threading.Tasks; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Blazor; using DevExpress.ExpressApp.Blazor.AmbientContext; using DevExpress.ExpressApp.Blazor.Services; using DevExpress.Persistent.Base; using Microsoft.Extensions.DependencyInjection; using Xpand.Extensions.XAF.XafApplicationExtensions; using Observable = System.Reactive.Linq.Observable;  namespace Xpand.Extensions.Blazor {     public static class Extensions {         public static BlazorApplication ToBlazor(this XafApplication application) => (BlazorApplication) application;          public static async Task RunWithStorageAsync(this IServiceProvider provider, Action<BlazorApplication> selector,string marker=null)             => await provider.RunWithStorageAsync(() => Observable.Return(Unit.Default).Do(_ => selector(provider.GetApplication(marker))));          public static BlazorApplication GetApplication(this IServiceProvider provider,string marker=null) {             ValueManager.GetValueManager<bool>(marker??XafApplicationExtensions.ApplicationMarker).Value = true; 	        return provider.GetRequiredService<IXafApplicationProvider>().GetApplication();         }          public static Task<T> RunWithStorageAsync<T>(this IServiceProvider provider,Func<BlazorApplication,IObservable<T>> selector,string marker=null)             => provider.RunWithStorageAsync(application => selector(application).ToTask(),marker);                  public static async Task<T> RunWithStorageAsync<T>(this IServiceProvider provider,Func<BlazorApplication,Task<T>> selector,string marker=null)             => await provider.RunWithStorageAsync(async () => await selector(provider.GetApplication(marker)));          public static void RunIsolated(this IServiceProvider provider, Action<BlazorApplication> action, string marker = null)             => ValueManagerContext.RunIsolated(() => action(provider.GetApplication(marker)));                  public static void RunWithStorage(this IServiceProvider provider, Action<BlazorApplication> action, string marker=null) 	        => provider.RunWithStorage(() => action(provider.GetApplication(marker)));          public static void RunWithStorage(this IServiceProvider provider, Action action) 	        => provider.GetRequiredService<IValueManagerStorageContext>().RunWithStorage(action);          public static async Task<T> RunWithStorageAsync<T>(this IServiceProvider provider,Func<IObservable<T>> selector)  	        => await provider.RunWithStorageAsync(selector().ToTask);                  public static async Task<T> RunWithStorageAsync<T>(this IServiceProvider provider,Func<Task<T>> selector)  	        => await provider.GetRequiredService<IValueManagerStorageContext>() 		        .RunWithStorageAsync(selector);     } }using System; using System.Net.Http; using Microsoft.AspNetCore.Components; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection;  namespace Xpand.Extensions.Blazor {     public class HostingStartup : IHostingStartup {         public void Configure(IWebHostBuilder builder)              => builder.ConfigureServices(services => {                 services.AddSingleton<SingletonItems>();                 services.AddScoped<ScopedItems>();                 services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(sp.GetRequiredService<NavigationManager>().BaseUri) });             });     } }using System.Collections.Concurrent;  namespace Xpand.Extensions.Blazor{     public class ScopedItems:ConcurrentDictionary<object,object>{     } }using System.Collections.Concurrent;  namespace Xpand.Extensions.Blazor {     public class SingletonItems:ConcurrentDictionary<object,object>{     } }using System.Reflection; using System.Runtime.InteropServices;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.Blazor")] [assembly: AssemblyMetadata("Platform","Web")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.Blazor")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System.Collections.Generic; using Mono.Cecil;  namespace Xpand.Extensions.Mono.Cecil{     public static partial class MonoCecilExtensions{         public static IEnumerable<TypeDefinition> BaseClasses(this TypeDefinition klassType){             for (var typeDefinition = klassType;                 typeDefinition != null;                 typeDefinition = typeDefinition.BaseType?.Resolve()) yield return typeDefinition;         }      } }using System.Linq; using Mono.Cecil;  namespace Xpand.Extensions.Mono.Cecil{     public static partial class MonoCecilExtensions{         public static bool DoesSpecificTypeImplementInterface(this TypeDefinition childTypeDef,TypeDefinition parentInterfaceDef){             return childTypeDef                 .Interfaces                 .Any(ifaceDef => ifaceDef.InterfaceType.Resolve().DoesSpecificInterfaceImplementInterface( parentInterfaceDef));         }          public static bool DoesSpecificInterfaceImplementInterface(this TypeDefinition iface0, TypeDefinition iface1){             return iface0.MetadataToken == iface1.MetadataToken || iface0.DoesAnySubTypeImplementInterface(iface1);         }          public static bool DoesAnySubTypeImplementInterface(this TypeDefinition childType,TypeDefinition parentInterfaceDef){             return childType                 .BaseClasses()                 .Any(typeDefinition => typeDefinition.DoesSpecificTypeImplementInterface(parentInterfaceDef));         }         public static bool IsAssignableFrom(this TypeDefinition target, TypeDefinition source){             return target == source                    || target.MetadataToken == source.MetadataToken                    || source.IsSubclassOf(target)                    || target.IsInterface && source.DoesAnySubTypeImplementInterface(target);         }       } }using System.Linq; using Mono.Cecil;  namespace Xpand.Extensions.Mono.Cecil{     public static partial class MonoCecilExtensions{         public static bool IsSubclassOf(this TypeDefinition childTypeDef, TypeDefinition parentTypeDef) => childTypeDef             .MetadataToken != parentTypeDef.MetadataToken && childTypeDef.BaseClasses().Any(b => b.MetadataToken == parentTypeDef.MetadataToken);     } }using System; using System.Collections.Generic; using Mono.Cecil;  namespace Xpand.Extensions.Mono.Cecil{     public static partial class MonoCecilExtensions{         public static Type ToType(this TypeReference typeReference,Dictionary<string,Type> typesCache=null){              string fullName = null;             if (typeReference.Scope.MetadataScopeType==MetadataScopeType.AssemblyNameReference){                 fullName = ((AssemblyNameReference) typeReference.Scope).FullName;             }             else if (typeReference.Scope.MetadataScopeType==MetadataScopeType.ModuleDefinition){                 fullName = ((ModuleDefinition) typeReference.Scope).Assembly.FullName;             }             else if (typeReference.Scope.MetadataScopeType==MetadataScopeType.ModuleReference){                 throw new NotImplementedException();             }             var key = $"{typeReference.FullName.Replace("/", "+")},{fullName}";             if (typesCache!=null){                 if (!typesCache.TryGetValue(key, out var type)){                     type = Type.GetType(key,true);                     typesCache.Add(key, type);                 }                 return type;             }              return Type.GetType(key,true);          }      } }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.Cecil")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.Cecil")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System; using System.Linq; using DevExpress.ExpressApp; using DevExpress.Persistent.Base.General; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.Office.Cloud{     public enum CloudObjectType{         Event,         Task     }      public static class CloudObjectExtensions{         public static CloudObjectType ToCloudObjectType(this Type type)              => type.InheritsFrom("Microsoft.Graph.Event") || type.InheritsFrom("Google.Apis.Calendar.v3.Data.Event") || typeof(IEvent).IsAssignableFrom(type)                 ? CloudObjectType.Event : type.InheritsFrom("Microsoft.Graph.OutlookTask") || type.InheritsFrom("Google.Apis.Tasks.v1.Data.Task") || typeof(ITask).IsAssignableFrom(type)                     ? CloudObjectType.Task : throw new NotSupportedException(type.FullName);          public static IQueryable<CloudOfficeObject> QueryCloudOfficeObject(this IObjectSpace objectSpace, string cloudId, CloudObjectType cloudObjectType)              => objectSpace.GetObjectsQuery<CloudOfficeObject>().Where(o => o.CloudObjectType == cloudObjectType && o.CloudId == cloudId);          public static IQueryable<CloudOfficeObject> QueryCloudOfficeObject(this IObjectSpace objectSpace, string localId, Type cloudEntityType){             var cloudObjectType = cloudEntityType.ToCloudObjectType();             return objectSpace.GetObjectsQuery<CloudOfficeObject>().Where(o => o.CloudObjectType == cloudObjectType && o.LocalId == localId);         }          public static IQueryable<CloudOfficeObject> QueryCloudOfficeObject(this IObjectSpace objectSpace, Type cloudEntityType, object localEntity){             var localId = objectSpace.GetKeyValue(localEntity);             return objectSpace.QueryCloudOfficeObject(localId.ToString(), cloudEntityType);         }      } }using DevExpress.Xpo; using Xpand.Extensions.Office.Cloud.BusinessObjects;  namespace Xpand.Extensions.Office.Cloud{     [DeferredDeletion(false)]     public class CloudOfficeObject : CloudOfficeBaseObject{         public CloudOfficeObject(Session session) : base(session){         }           string _localId;         CloudObjectType _cloudObjectType;          public CloudObjectType CloudObjectType{             get => _cloudObjectType;             set => SetPropertyValue(nameof(CloudObjectType), ref _cloudObjectType, value);         }          [Indexed(nameof(CloudObjectType), Unique = true)]         public string LocalId{             get => _localId;             set => SetPropertyValue(nameof(LocalId), ref _localId, value);         }          string _cloudId;          [Size(255)]         public string CloudId{             get => _cloudId;             set => SetPropertyValue(nameof(CloudId), ref _cloudId, value);          }     } }using System; using System.Drawing; using System.Linq; using System.Reactive; using System.Reactive.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions; using DevExpress.ExpressApp.Templates; using Fasterflect;  using Xpand.Extensions.Office.Cloud.BusinessObjects; using Xpand.Extensions.Reactive.Transform; using Xpand.Extensions.XAF.ActionExtensions; using Xpand.Extensions.XAF.Attributes; using Xpand.Extensions.XAF.FrameExtensions; using Xpand.Extensions.XAF.XafApplicationExtensions; using Xpand.XAF.Modules.Reactive.Services; using Xpand.XAF.Modules.Reactive.Services.Actions;  namespace Xpand.Extensions.Office.Cloud{     public static class Extensions{         public static void SaveToken(this ICloudOfficeToken store, Func<IObjectSpace> objectSpaceFactory){             using var space = objectSpaceFactory();             var storage = (ICloudOfficeToken)(space.GetObject(store) ?? space.CreateObject(store.GetType()));             storage.Token = store.Token;             storage.TokenType = store.TokenType;             storage.EntityName = store.EntityName;             space.CommitChanges();         }          internal static IObservable<TCloudEntity> MapEntity<TCloudEntity, TLocalEntity>(this Func<IObjectSpace> objectSpaceFactory, TLocalEntity localEntity,             Func<TLocalEntity, IObservable<TCloudEntity>> insert, Func<(string cloudId, TLocalEntity task), IObservable<TCloudEntity>> update){             var objectSpace = objectSpaceFactory();             var localId = objectSpace.GetKeyValue(localEntity).ToString();             var cloudId = objectSpace.GetCloudId(localId, localEntity.GetType());             return cloudId == null ? insert(localEntity) : update((cloudId, localEntity));         }                            public static IObservable<T> DeleteObjectSpaceLink<T>(this IObservable<T> source) where T : IObjectSpaceLink              => source.Select(link => {                 link.ObjectSpace.Delete(link);                 link.ObjectSpace.CommitChanges();                 return link;             });          public static bool IsDelete(this SynchronizationType synchronizationType)              => new[]{SynchronizationType.CreatedOrDeleted,SynchronizationType.Deleted,SynchronizationType.All }.Contains(synchronizationType);          public static bool IsCreate(this SynchronizationType synchronizationType)              => new[]{SynchronizationType.Created, SynchronizationType.CreatedOrDeleted, SynchronizationType.CreatedOrUpdated,SynchronizationType.All}.Contains(synchronizationType);                  public static bool IsUpdate(this SynchronizationType synchronizationType)              => new[]{SynchronizationType.Updated, SynchronizationType.CreatedOrUpdated, SynchronizationType.UpdatedOrDeleted,SynchronizationType.All}.Contains(synchronizationType);          public static IObservable<(TCloudEntity serviceObject, MapAction mapAction)>             ModifiedObjects<TLocalEntity, TCloudEntity>(this IObjectSpace objectSpace, SynchronizationType synchronizationType,                  Func<(CloudOfficeObject cloudOfficeObject, TLocalEntity localEntity), IObservable<(TCloudEntity , MapAction mapAction)>> delete,                 Func<TLocalEntity, IObservable<(TCloudEntity serviceObject, MapAction mapAction)>> map){                          var deleteObjects =synchronizationType.IsDelete()? objectSpace.WhenDeletedObjects<TLocalEntity>(true)                 .SelectMany(_ => _.objects.SelectMany(o => { 	                var deletedId = _.objectSpace.GetKeyValue(o).ToString(); 	                return _.objectSpace.QueryCloudOfficeObject(typeof(TCloudEntity), o).Where(officeObject => officeObject.LocalId == deletedId).ToArray()                         .Select(officeObject => (officeObject,bo:o));                 }))                 .SelectMany(t => delete(t).Select(_ => t.officeObject))                 .To((TCloudEntity)typeof(TCloudEntity).CreateInstance())                 .Select(o => (o,MapAction.Delete)):Observable.Empty<(TCloudEntity serviceObject, MapAction mapAction)>();              var newObjects = synchronizationType.IsCreate() ? objectSpace.WhenCommiting<TLocalEntity>(ObjectModification.New,true)                 .SelectMany(_ => _.objects).SelectMany(map):Observable.Empty<(TCloudEntity serviceObject, MapAction mapAction)>();                          var updateObjects = synchronizationType.IsUpdate() ? objectSpace.WhenCommiting<TLocalEntity>(ObjectModification.Updated,true)                 .SelectMany(_ => _.objects).SelectMany(map):Observable.Empty<(TCloudEntity serviceObject, MapAction mapAction)>();             return updateObjects.Merge(newObjects).Merge(deleteObjects);         }          public static IObservable<TServiceObject> MapEntities<TBO, TServiceObject>(this IObjectSpace objectSpace,IObservable<TBO> deletedObjects,             IObservable<TBO> newOrUpdatedObjects, Func<CloudOfficeObject, IObservable<TServiceObject>> delete, Func<TBO, IObservable<TServiceObject>> map)              => newOrUpdatedObjects.SelectMany(map)                 .Merge(deletedObjects                     .SelectMany(_ => {                         var deletedId = objectSpace.GetKeyValue(_).ToString();                         return objectSpace.QueryCloudOfficeObject(typeof(TServiceObject), _).Where(o => o.LocalId == deletedId).ToObservable();                     })                     .SelectMany(cloudOfficeObject => delete(cloudOfficeObject).Select(_ => cloudOfficeObject))                     .To<TServiceObject>());          public static IObservable<T> NewCloudObject<T>(this IObservable<T> source, Func<IObjectSpace> objectSpaceFactory, string localId)              => source.SelectMany(@event => Observable.Using(objectSpaceFactory,                  space => space.NewCloudObject(localId, (string)@event.GetPropertyValue("Id"), @event.GetType().ToCloudObjectType())                     .Select(_ => @event)));                  public static IObservable<CloudOfficeObject> NewCloudObject(this IObjectSpace space, string localId, string cloudId, Type cloudObjectType)              => space.NewCloudObject(localId, cloudId, cloudObjectType.ToCloudObjectType());          public static IObservable<CloudOfficeObject> NewCloudObject(this IObjectSpace space, object localEntity, object cloudEntity){             var localId = space .GetKeyValue(localEntity).ToString();             var cloudId = cloudEntity.GetPropertyValue("Id").ToString();             return space.NewCloudObject(localId, cloudId, cloudEntity.GetType().ToCloudObjectType());         }                   public static IObservable<CloudOfficeObject> NewCloudObject(this IObjectSpace space, string localId, string cloudId, CloudObjectType cloudObjectType){             var cloudObject = space.CreateObject<CloudOfficeObject>();             cloudObject.LocalId = localId;             cloudObject.CloudId = cloudId;             cloudObject.CloudObjectType = cloudObjectType;             space.CommitChanges();             return cloudObject.Observe();         }                   public static string GetCloudId(this IObjectSpace objectSpace, string localId, Type cloudEntityType)              => objectSpace.QueryCloudOfficeObject(localId, cloudEntityType).FirstOrDefault()?.CloudId;          private static IObservable<SimpleAction> RegisterAuthActions(this ApplicationModulesManager manager,string serviceName)              => manager.RegisterViewSimpleAction($"Connect{serviceName}", action => action.Initialize(serviceName))                 .Merge(manager.RegisterViewSimpleAction($"Disconnect{serviceName}", action => action.Initialize(serviceName)))                 .Publish().RefCount();          private static void Initialize(this SimpleAction action,string serviceName){             action.Caption = $"Sign In {serviceName}";             action.ImageName = serviceName;             if (action.Id == $"Connect{serviceName}"){                 action.ToolTip = "Connect";             }             else{                 action.Caption = $"Sign out {serviceName}";                 action.ToolTip="Sign out";             }             action.PaintStyle=ActionItemPaintStyle.CaptionAndImage;          }              internal static IObservable<Unit> Connect(this ApplicationModulesManager manager, string serviceName,             Type serviceStorageType, Func<XafApplication, IObservable<bool>> needsAuthentication, Func<XafApplication, IObservable<Unit>> authorize){             var registerActions = manager.RegisterAuthActions(serviceName);             return registerActions.ConfigureStyle()                 .Merge(registerActions.ExecuteActions(needsAuthentication,serviceName,serviceStorageType,authorize))                 .ToUnit();         }          public static IObservable<bool> NeedsAuthentication<TAuthentication>(this XafApplication application,Func<IObservable<bool>> authorize) where TAuthentication:CloudOfficeBaseObject              => application.UseObjectSpace(typeof(TAuthentication),space => (space.GetObjectByKey<TAuthentication>( application.CurrentUserId())).Observe())                 .SelectMany(b => b!=null ? authorize() : true.Observe());          private static IObservable<Unit> ConfigureStyle(this IObservable<SimpleAction> source)              => source.WhenCustomizeControl()                 .Select(t => {                     var application = t.action.Application;                     if (application.GetPlatform() == Platform.Web) {                         if (t.action.Id.StartsWith("Connect")) {                             t.action.Model.SetValue("IsPostBackRequired", true);                         }                          var menuItem = t.e.Control.GetPropertyValue("MenuItem");                         var itemStyle = menuItem.GetPropertyValue("ItemStyle");                         itemStyle.GetPropertyValue("Font").SetPropertyValue("Name", "Roboto Medium");                         itemStyle.GetPropertyValue("SelectedStyle").SetPropertyValue("BackColor", Color.White);                         itemStyle.SetPropertyValue("ForeColor", ColorTranslator.FromHtml("#757575"));                         itemStyle.GetPropertyValue("HoverStyle").SetPropertyValue("BackColor", Color.White);                         menuItem.CallMethod("ForceMenuRendering");                     }                      return t.action;                 })                 .ToUnit();          private static IObservable<SimpleAction> Activate(this IObservable<(bool needsAuth, SimpleAction action)> source, string serviceName, Type serviceStorageType)              => source.Select(t => {                     t.action.Activate(nameof(NeedsAuthentication), t.action.Id.StartsWith("Connect") ? t.needsAuth : !t.needsAuth);                     if (!t.needsAuth && t.action.Id.StartsWith("Disconnect")){                         t.action.UpdateDisconnectActionToolTip(serviceName,serviceStorageType);                     }                      return t.action;                 });          private static void UpdateDisconnectActionToolTip(this SimpleAction action, string serviceName, Type serviceStorageType){             using var objectSpace = action.Application.CreateObjectSpace(serviceStorageType);             var disconnectMicrosoft = action.Controller.Frame.Actions().First(a => a.Id==$"Disconnect{serviceName}");             var currentUserId = action.Application.CurrentUserId();             var objectByKey = objectSpace.GetObjectByKey(serviceStorageType,currentUserId);             var userName = objectByKey?.GetPropertyValue("UserName");             if (!disconnectMicrosoft.Data.ContainsKey("ToolTip")){                 disconnectMicrosoft.Data["ToolTip"] = disconnectMicrosoft.ToolTip;             }             disconnectMicrosoft.ToolTip = $"{disconnectMicrosoft.Data["ToolTip"]} {userName}";         }          private static IObservable<Unit> ExecuteActions(this IObservable<SimpleAction> registerActions,             Func<XafApplication, IObservable<bool>> needsAuthentication, string serviceName, Type serviceStorageType,             Func<XafApplication, IObservable<Unit>> authorize)              => registerActions.ActivateWhenUserDetails()                 .SelectMany(action => needsAuthentication(action.Application).Select(b => b).Pair(action)                     .Activate(serviceName, serviceStorageType)                     .Merge(action.Authorize(serviceName,serviceStorageType,authorize,needsAuthentication))                 ).ToUnit();          private static IObservable<SimpleAction> Authorize(this SimpleAction action, string serviceName,             Type serviceStorageType, Func<XafApplication, IObservable<Unit>> authorize,             Func<XafApplication, IObservable<bool>> needsAuthentication)              => action.WhenExecute(e => {                 var execute = e.Action.Id == $"Disconnect{serviceName}"                     ? e.Action.Application.UseObjectSpace(_ => {                         var objectSpace = e.Action.View().ObjectSpace;                         objectSpace.Delete(objectSpace.GetObjectByKey(serviceStorageType,e.Action.Application.CurrentUserId()));                         objectSpace.CommitChanges();                         e.Action.Data.Clear();                         return e.Action.AsSimpleAction().Observe();                     })                     : authorize(e.Action.Application).To(e.Action.AsSimpleAction());                 return execute.SelectMany(simpleAction => needsAuthentication(simpleAction.Application).Pair(simpleAction))                     .ActivateWhenAuthenticationNeeded(serviceName, serviceStorageType);             });          private static IObservable<SimpleAction> ActivateWhenUserDetails(this IObservable<SimpleAction> registerActions)              => registerActions.Select(action => action).ActivateInUserDetails()                 .Do(action => action.Activate(nameof(NeedsAuthentication),false) );                   private static IObservable<SimpleAction> ActivateWhenAuthenticationNeeded(             this IObservable<(bool needsAuth, SimpleAction action)> source, string serviceName, Type serviceStorageType)              => source.Select(t => {                     if (t.action.Id == $"Connect{serviceName}"){                         t.action.Activate(nameof(NeedsAuthentication), t.needsAuth);                         t.action.Controller.Frame.Action($"Disconnect{serviceName}").Activate(nameof(NeedsAuthentication), !t.needsAuth);                     }                     else{                         t.action.Activate(nameof(NeedsAuthentication), !t.needsAuth);                         t.action.Controller.Frame.Action($"Connect{serviceName}").Activate(nameof(NeedsAuthentication), t.needsAuth);                     }                     t.action.UpdateDisconnectActionToolTip(serviceName, serviceStorageType);                     return t.action;                 })                 .WhenActive();       }        }using System; using System.Linq; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using DevExpress.ExpressApp; using DevExpress.Persistent.Base.General; using Fasterflect; using Xpand.Extensions.AppDomainExtensions; using Xpand.Extensions.EventArgExtensions; using Xpand.Extensions.Office.Cloud.BusinessObjects; using Xpand.Extensions.Reactive.Combine; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Office.Cloud{     public static class MapExtensions{         public static IObservable<(IObjectSpace objectSpace, IEvent local, TCloudEvent cloud, MapAction mapAction)> SynchronizeLocalEvent<TCloudEvent, TService>(             this IObservable<TService> source, Func<IObjectSpace> objectSpaceFactory, Guid currentUserId, Func<TService, ICloudOfficeToken, IObservable<                 (TCloudEvent @event,MapAction mapAction)>> modifiedEventsList, Type localEventType,string tokenType)             => Observable.Using(objectSpaceFactory, objectSpace => source.SelectMany(service => modifiedEventsList(service,                     objectSpace.CloudOfficeToken(currentUserId, typeof(TCloudEvent).FullName,tokenType)))                 .SynchronizeLocalEvent(objectSpaceFactory, localEventType));          public static CloudOfficeToken CloudOfficeToken(this IObjectSpace objectSpace,Guid currentUserId,string entityName,string tokenType){             var cloudOfficeToken = objectSpace.GetObjectsQuery<CloudOfficeToken>().FirstOrDefault(token =>                 token.CloudOfficeTokenStorage.Oid == currentUserId && token.EntityName == entityName&&token.TokenType==tokenType);                          if (cloudOfficeToken == null){                 cloudOfficeToken = objectSpace.CreateObject<CloudOfficeToken>();                 cloudOfficeToken.CloudOfficeTokenStorage =objectSpace.GetObjectByKey<CloudOfficeTokenStorage>(currentUserId)?? objectSpace.CreateObject<CloudOfficeTokenStorage>();                 cloudOfficeToken.CloudOfficeTokenStorage.Oid = currentUserId;                 cloudOfficeToken.TokenType = tokenType;                 cloudOfficeToken.EntityName=entityName;             }                          objectSpace.CommitChanges();             return cloudOfficeToken;         }          static IObservable<(IObjectSpace objectSpace, IEvent source, TCloudEvent @event, MapAction mapAction)>             SynchronizeLocalEvent<TCloudEvent>(this IObservable<(TCloudEvent @event, MapAction mapAction)> source,                 Func<IObjectSpace> objectSpaceFactory, Type localEventType)              => source.SelectMany(t => Observable.Using(objectSpaceFactory, objectSpace => objectSpace                 .QueryCloudOfficeObject((string)t.@event.GetPropertyValue("Id"), t.@event.GetType().ToCloudObjectType()).ToObservable(Scheduler.Immediate)                 .Select(cloudObject => ((IEvent) objectSpace.GetObjectByKey(localEventType,new Guid(cloudObject.LocalId)))).Pair(t)                 .Select(tuple => (objectSpace,tuple.source,tuple.other.@event,tuple.other.mapAction))                 .SwitchIfEmpty((objectSpace,(IEvent)null,t.@event,t.mapAction).Observe().Select(tuple => tuple))                 .Finally(objectSpace.CommitChanges)));          public static IObservable<(TCloudEntity serviceObject, MapAction mapAction)>             SynchronizeCloud<TCloudEntity, TLocalEntity>(this Func<IObjectSpace> objectSpaceFactory, SynchronizationType synchronizationType, IObjectSpace objectSpace,             Func<string, IObservable<Unit>> deleteReqest, Func<TCloudEntity, IObservable<TCloudEntity>> insertReqest, Func<(string cloudId,MapAction mapAction), IObservable<TCloudEntity>> getRequest,             Func<(TCloudEntity cloudEntity, TLocalEntity localEntity, string cloudId), IObservable<TCloudEntity>> updateRequest,              Action<GenericEventArgs<(CloudOfficeObject cloudOfficeObject, TLocalEntity localEntinty)>> onDelete = null, Action<(TCloudEntity target, TLocalEntity source)> onInsert = null,             Action<(TCloudEntity target, TLocalEntity source)> update = null) where TCloudEntity : class             => objectSpace.ModifiedObjects<TLocalEntity, TCloudEntity>(synchronizationType, cloudOfficeObject                      => cloudOfficeObject.Delete<TCloudEntity,TLocalEntity>(onDelete, deleteReqest).FirstOrDefaultAsync().Select(entity => (entity,MapAction.Delete)),                 localEntity => objectSpaceFactory.MapEntity(localEntity, sourceEntity                          => sourceEntity.Insert(objectSpace, objectSpaceFactory, onInsert, insertReqest).Select(entity => (entity, MapAction.Insert)), _                          => _.task.Update(_.cloudId, getRequest, updateRequest, update).Select(entity => (entity, MapAction.Update))                 ));          private static IObservable<TCloudEntity> Update<TCloudEntity, TLocalEntity>(this TLocalEntity source, string cloudId, Func<(string cloudId,MapAction mapAction), IObservable<TCloudEntity>> getRequest, 	        Func<(TCloudEntity cloudEntity, TLocalEntity localEntity, string cloudId), IObservable<TCloudEntity>> updateRequest,  	        Action<(TCloudEntity target, TLocalEntity source)> update = null)              => getRequest((cloudId,MapAction.Update)).SelectMany(target => {                     update?.Invoke((target, source)); 			        return updateRequest.Start(source, cloudId,  target); 		        });          private static IObservable<TCloudEntity> Start<TCloudEntity, TLocalEntity>(this Func<(TCloudEntity cloudEntity, TLocalEntity localEntity, string cloudId),              IObservable<TCloudEntity>> updateRequest,TLocalEntity source, string cloudId,  TCloudEntity target)              => AppDomain.CurrentDomain.IsHosted() ? Observable.Start(()                  => updateRequest((target, source, cloudId)).Wait()) : updateRequest((target, source, cloudId));          private static IObservable<TCloudEntity> Insert<TCloudEntity, TLocalEntity>(this TLocalEntity sourceEvent, IObjectSpace objectSpace, Func<IObjectSpace> objectSpaceFactory,             Action<(TCloudEntity, TLocalEntity)> insert, Func<TCloudEntity, IObservable<TCloudEntity>> insertReqest){             var cloudEntity = (TCloudEntity)typeof(TCloudEntity).CreateInstance();             insert?.Invoke((cloudEntity, sourceEvent));             return insertReqest.Start(cloudEntity)                 .NewCloudObject(objectSpaceFactory, objectSpace.GetKeyValue(sourceEvent).ToString());         }          private static IObservable<TCloudEntity> Start<TCloudEntity>(this Func<TCloudEntity, IObservable<TCloudEntity>> insertReqest, TCloudEntity updatedEvent)              => AppDomain.CurrentDomain.IsHosted()? Observable.Start(()                  => insertReqest(updatedEvent).Wait()):insertReqest(updatedEvent);          private static IObservable<TCloudEntity> Delete<TCloudEntity, TLocalEntity>(this (CloudOfficeObject cloudOfficeObject, TLocalEntity localEntinty) t,             Action<GenericEventArgs<(CloudOfficeObject cloudOfficeObject, TLocalEntity localEntinty)>> delete,             Func<string, IObservable<Unit>> deleteReqest) where TCloudEntity : class{             var args = new GenericEventArgs<(CloudOfficeObject cloudOfficeObject,TLocalEntity localEntinty)>(t);             delete?.Invoke(args);             return !args.Handled ? deleteReqest.Start<TCloudEntity>(t.cloudOfficeObject) : Observable.Empty<TCloudEntity>();         }          private static IObservable<TCloudEntity> Start<TCloudEntity>(this Func<string, IObservable<Unit>> deleteReqest,CloudOfficeObject cloudOfficeObject) where TCloudEntity : class              => AppDomain.CurrentDomain.IsHosted()? Observable.Start(()                      => deleteReqest(cloudOfficeObject.CloudId).Select(entity => (TCloudEntity)null).Wait())                 :deleteReqest(cloudOfficeObject.CloudId).Select(entity => (TCloudEntity)null);     }      public enum MapAction{         Delete,         Insert,         Update     }     public enum SynchronizationType{         All,         Created,         Updated,         Deleted,         CreatedOrUpdated,         CreatedOrDeleted,         UpdatedOrDeleted     }  }using System; using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using System.Linq; using System.Reactive.Linq; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using DevExpress.Persistent.Base; using DevExpress.Persistent.Base.General;  using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.XAF.ModelExtensions; using Xpand.Extensions.XAF.ModelExtensions.Shapes; using Xpand.XAF.Modules.Reactive;  namespace Xpand.Extensions.Office.Cloud{           [DomainLogic(typeof(IModelOffice))]     public static class ModelOfficeLogic{                  public static IObservable<IModelOffice> Office(this IObservable<IModelReactiveModules> source)              => source.Select(modules => modules.Office());          public static IModelOffice Office(this IModelReactiveModules reactiveModules)              => ((IModelReactiveModuleOffice) reactiveModules).Office;     }      public enum OAuthPrompt{         [SuppressMessage("ReSharper", "InconsistentNaming")]          Select_Account,         Login,         Consent     }      public interface IModelOAuthRedirectUri:IModelOAuth{         [Required]         string RedirectUri{ get; set; }     }      public interface IModelOAuth:IModelNode{         [Required][DefaultValue(OAuthPrompt.Consent)]         OAuthPrompt Prompt{ get;  set; }         [Description("Space seperated list of scopes")]         string Scopes{ get;  set; }         [Required]         string ClientId{ get; set; }         [Required]         string ClientSecret{ get; set; }     }          [DomainLogic(typeof(IModelOAuth))]     public static class ModelOathLogic{         public static void AddScopes(this IModelOAuth modelOAuth, params string[] scopes)              => modelOAuth.Scopes = modelOAuth.Scopes().Concat(scopes).Distinct().Join(" ");          internal static string[] Scopes(this IModelOAuth modelOAuth)              => $"{modelOAuth.Scopes}".Split(' ').Where(s => !string.IsNullOrEmpty(s)).Distinct().ToArray();     }      public interface IModelSynchronizationType{         [Required][DefaultValue(SynchronizationType.All)]         SynchronizationType SynchronizationType{ get;  set; }     }           public interface IModelCalendar:IModelNode{         [Required]         string DefaultCalendarName{ get; set; }         [DataSourceProperty(nameof(NewCloudEvents))]         [Required]         IModelClass NewCloudEvent{ get; set; }         [Browsable(false)]         IModelList<IModelClass> NewCloudEvents{ get; }          IModelCalendarItems Items{ get; }     }      [DomainLogic(typeof(IModelCalendar))]     public static class ModelCalendarLogic{                  public static string Get_DefaultCalendarName(this IModelCalendar modelCalendar){             var interfaces = modelCalendar.Parent.GetType().GetInterfaces();             if (interfaces.Any(type => type.Name.Contains("Microsoft"))){                 return "Calendar";             }             if (interfaces.Any(type => type.Name.Contains("Google"))){                 return "primary";             }             throw new NotImplementedException();         }                   public static IModelClass Get_NewCloudEvent(this IModelCalendar modelCalendar)             => modelCalendar.NewCloudEvents.FirstOrDefault();                           public static CalculatedModelNodeList<IModelClass> Get_NewCloudEvents(this IModelCalendar modelCalendar)              => modelCalendar.Application.BOModel.Where(c =>c.TypeInfo.IsPersistent&&!c.TypeInfo.IsAbstract&&typeof(IEvent).IsAssignableFrom(c.TypeInfo.Type) ).ToCalculatedModelNodeList();     }      public interface IModelCalendarItems : IModelList<IModelCalendarItem>,IModelNode{     }      public interface IModelCalendarItem:IModelSynchronizationType,IModelCallDirection,IModelObjectViewDependency{     }      public interface IModelCallDirection{         [Required][DefaultValue(CallDirection.Both)]         CallDirection CallDirection{ get; set; }     }          public enum CallDirection{         Both,         In,         Out     } }using System; using System.ComponentModel; using DevExpress.ExpressApp; using DevExpress.Xpo;  namespace Xpand.Extensions.Office.Cloud.BusinessObjects{     [NonPersistent][OptimisticLocking(false)][DeferredDeletion(false)]     public abstract class CloudOfficeBaseObject : XPCustomObject, IObjectSpaceLink{         protected CloudOfficeBaseObject(Session session) : base(session){         }          protected override void OnSaving(){             base.OnSaving();             if (Session is NestedUnitOfWork || !Session.IsNewObject(this) || !Oid.Equals(Guid.Empty))                 return;             Oid = XpoDefault.NewGuid();         }          [Browsable(false)]         public IObjectSpace ObjectSpace { get; set; }         Guid _oid;         [Key]         public Guid Oid{             get => _oid;             set => SetPropertyValue(nameof(Oid), ref _oid, value);         }     } }using DevExpress.Xpo;   namespace Xpand.Extensions.Office.Cloud.BusinessObjects{     [DeferredDeletion(false)]          public class CloudOfficeTokenStorage : CloudOfficeBaseObject{         public CloudOfficeTokenStorage(Session session) : base(session){         }                    [Association("CloudOfficeTokenStorage-CloudOfficeTokens")]         public XPCollection<CloudOfficeToken> CloudOfficeTokens => GetCollection<CloudOfficeToken>(nameof(CloudOfficeTokens));     }      [DeferredDeletion(false)]          public class CloudOfficeToken:CloudOfficeBaseObject,ICloudOfficeToken{         public CloudOfficeToken(Session session) : base(session){         }          string _entityName;         public string EntityName{             get => _entityName;             set => SetPropertyValue(nameof(EntityName), ref _entityName, value);         }          string _tokenType;          public string TokenType{             get => _tokenType;             set => SetPropertyValue(nameof(TokenType), ref _tokenType, value);         }          string _token;         [Size(SizeAttribute.Unlimited)]         public string Token{             get => _token;             set => SetPropertyValue(nameof(Token), ref _token, value);         }          CloudOfficeTokenStorage _cloudOfficeTokenStorage;          [Association("CloudOfficeTokenStorage-CloudOfficeTokens")]         public CloudOfficeTokenStorage CloudOfficeTokenStorage{             get => _cloudOfficeTokenStorage;             set => SetPropertyValue(nameof(CloudOfficeTokenStorage), ref _cloudOfficeTokenStorage, value);         }     }     public interface ICloudOfficeToken{         string TokenType { get; set; }         string Token { get; set; }         string EntityName { get; set; }     }  }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()] [assembly:InternalsVisibleTo("Xpand.XAF.Modules.Office.Cloud.Microsoft,PublicKey=0024000004800000940000000602000000240000525341310004000001000100df18f4f3de9ec490707183c78a72914070a526bfb1818e1687442b137c2bfa9bf5e8533859a8efaa62aa2ea28e03623fef5531f8dd29d74f781a9e50743172dbe8d74b0106ceddfcda17f8dd1034f2896a56e1026faa2cc0e2def8dc1f519ad13924c44f16339a57ed97981a8777c7fa6025a11e54cc694e504d462a400681c0")] [assembly:InternalsVisibleTo("Xpand.XAF.Modules.Office.Cloud.Google,PublicKey=0024000004800000940000000602000000240000525341310004000001000100df18f4f3de9ec490707183c78a72914070a526bfb1818e1687442b137c2bfa9bf5e8533859a8efaa62aa2ea28e03623fef5531f8dd29d74f781a9e50743172dbe8d74b0106ceddfcda17f8dd1034f2896a56e1026faa2cc0e2def8dc1f519ad13924c44f16339a57ed97981a8777c7fa6025a11e54cc694e504d462a400681c0")] [assembly:InternalsVisibleTo("Xpand.XAF.Modules.Office.Cloud.Google.Tasks,PublicKey=0024000004800000940000000602000000240000525341310004000001000100df18f4f3de9ec490707183c78a72914070a526bfb1818e1687442b137c2bfa9bf5e8533859a8efaa62aa2ea28e03623fef5531f8dd29d74f781a9e50743172dbe8d74b0106ceddfcda17f8dd1034f2896a56e1026faa2cc0e2def8dc1f519ad13924c44f16339a57ed97981a8777c7fa6025a11e54cc694e504d462a400681c0")]using System; using System.Linq; using Google.Apis.Auth.OAuth2.Web; using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.DependencyInjection; using Xpand.Extensions.Blazor;  namespace Xpand.Extensions.Office.Cloud.Google.Blazor{     public class GoogleCodeStateStartup : IHostingStartup{         public void Configure(IWebHostBuilder builder)              => builder.ConfigureServices(services => {                 services.AddTransient<IStartupFilter, GoogleCodeState>();             });     }      public class GoogleCodeState : IStartupFilter{         public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)              => app => {                 app.Use(async (context, next2) => {                     var cultureQuery = context.Request.Query["code"];                     var code = cultureQuery.FirstOrDefault();                     if (code != null){                         var state = context.Request.Query["state"].First();                         var key = Guid.Parse(state.Substring(0, state.Length - AuthorizationCodeWebApp.StateRandomLength));                         app.ApplicationServices.GetService<SingletonItems>()?.TryAdd(key, code);                     }                     await next2();                 });                 next(app);             };     } }using System.Reflection; using System.Runtime.InteropServices;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.Office.Cloud.Google.Blazor")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.Office.Cloud.Google.Blazor")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")] [assembly: AssemblyMetadata("Platform","Web")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion("2.201.34.6")] [assembly: AssemblyFileVersion("2.201.34.6")] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()] [assembly:InternalsVisibleTo("Xpand.XAF.Modules.Office.Cloud.Tests,PublicKey=0024000004800000940000000602000000240000525341310004000001000100df18f4f3de9ec490707183c78a72914070a526bfb1818e1687442b137c2bfa9bf5e8533859a8efaa62aa2ea28e03623fef5531f8dd29d74f781a9e50743172dbe8d74b0106ceddfcda17f8dd1034f2896a56e1026faa2cc0e2def8dc1f519ad13924c44f16339a57ed97981a8777c7fa6025a11e54cc694e504d462a400681c0")]using System; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Combine {     public static partial class Combine {         public static IObservable<TResult> CombineVeryLatest<TLeft, TRight, TResult>(this IObservable<TLeft> leftSource,             IObservable<TRight> rightSource, Func<TLeft, TRight, TResult> selector)              => Observable.Defer(() => {                 int l = -1, r = -1;                 return leftSource.Select(Tuple.Create<TLeft, int>).CombineLatest(                         rightSource.Select(Tuple.Create<TRight, int>),                         (x, y) => new { x, y })                     .Where(t => t.x.Item2 != l && t.y.Item2 != r)                     .Do(t => {                         l = t.x.Item2;                         r = t.y.Item2;                     })                     .Select(t => selector(t.x.Item1, t.y.Item1));             });     } }using System; using System.Reactive.Linq; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.Reactive.Combine{     public static partial class Combine{         public static IObservable<(TSource previous, TSource current)> CombineWithPrevious<TSource>(this IObservable<TSource> source,bool ensurePrevious=false)              => source.Scan((previous: default(TSource), current: default(TSource)), (_, current) => (_.current, current))                 .Select(t => (t.previous, t.current)).Where(t => !ensurePrevious||!t.previous.IsDefaultValue());         public static IObservable<TSource> CombineWithPrevious<TSource>(this IObservable<TSource> source,Func<(TSource previous,TSource current),TSource> selector,bool emitPrevious=false)              => source.CombineWithPrevious(!emitPrevious).Select(selector);                  public static IObservable<(TSource previous, TSource current)> CombineWithPrevious<TSource>(this IObservable<TSource> source,Func<(TSource previous,TSource current),bool> selector,bool emitPrevious=false)              => source.CombineWithPrevious(!emitPrevious).Where(selector);                  public static IObservable<TSource> ToCurrent<TSource>(this IObservable<(TSource previous, TSource current)> source)              => source.Select(t => t.current);     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Combine {     public static partial class Combine {         public static IObservable<T> DelayIfEmpty<T>(this IObservable<T> source, TimeSpan timeSpan)             => source.SwitchIfEmpty(Observable.Defer(() => Observable.Timer(timeSpan).SelectMany(_ => Observable.Empty<T>())));     } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Threading; using System.Threading.Tasks; using Xpand.Extensions.Reactive.Filter; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Combine{     public static partial class Combine{         public static IObservable<TC> MergeOrCombineLatest<TA, TB, TC>(this IObservable<TA> a, IObservable<TB> b, Func<TA, TC> aStartsFirst, Func<TB, TC> bStartFirst, Func<TA, TB, TC> bothStart)             => a.Publish(aa => b.Publish(bb => aa.CombineLatest(bb, bothStart)                     .Publish(xs => aa.Select(aStartsFirst).Merge(bb.Select(bStartFirst)).TakeUntil(xs).SkipLast(1).Merge(xs))));         public static IObservable<T> MergeOrdered<T>(this IObservable<IObservable<T>> source, int maximumConcurrency = Int32.MaxValue)              => Observable.Defer(() => {                 var semaphore = new SemaphoreSlim(maximumConcurrency);                 return source.Select(inner => {                         var published = inner.Replay();                         _ = semaphore.WaitAsync().ContinueWith(_ => published.Connect(), TaskScheduler.Default);                         return published.Finally(() => semaphore.Release());                     })                     .Concat();             });          public static IObservable<TSource> MergeWith<TSource>(this IObservable<TSource> source,             Func<TSource, IObservable<TSource>> selector, IScheduler scheduler = null)             => source.Publish(obs => obs.Merge(obs.SelectMany(selector),scheduler??Scheduler.Default));                  public static IObservable<TValue> MergeWith<TSource, TValue>(this IObservable<TSource> source, TValue value, IScheduler scheduler = null)              => source.Merge(default(TSource).Observe(scheduler ?? CurrentThreadScheduler.Instance)).Select(_ => value);          public static IObservable<Unit> MergeToUnit<TSource, TValue>(this IObservable<TSource> source, IObservable<TValue> value, IScheduler scheduler = null)              => source.ToUnit().Merge(value.ToUnit());                  public static IObservable<TValue> MergeTo<TSource, TValue>(this IObservable<TSource> source, IObservable<TValue> value, IScheduler scheduler = null) where TValue:class              => source.Select(source1 => source1 as TValue).WhenNotDefault().Merge(value.To<TValue>());                  public static IObservable<object> MergeToObject<TSource, TValue>(this IObservable<TSource> source, IObservable<TValue> value, IScheduler scheduler = null) where TValue:class              => source.Select(source1 => source1 as object).WhenNotDefault().Merge(value.To<TValue>());          public static IObservable<T> MergeIgnored<T,T2>(this IObservable<T> source,Func<T,IObservable<T2>> secondSelector,Func<T,bool> merge=null)             => source.Publish(obs => obs.SelectMany(arg => {                 merge ??= _ => true;                 var observable = Observable.Empty<T>();                 if (merge(arg)) {                     observable = secondSelector(arg).IgnoreElements().To(arg);                 }                 return observable.Merge(arg.Observe());             }));                  public static IObservable<T> MergeIgnored<T,T2>(this IObservable<T> source,Func<T,bool> merge,Func<T,IObservable<T2>> secondSelector)             => source.MergeIgnored(secondSelector);                  public static IObservable<T> MergeIgnored<T>(this IObservable<T> source,Func<T,bool> merge,Action<T> @do)             => source.MergeIgnored(_ => Observable.Empty<T>(), arg => {                 @do(arg);                 return merge(arg);             });      } }using System; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Combine{     public static partial class Combine{         public static IObservable<T> SwitchIfDefault<T>(this IObservable<T> @this, IObservable<T> switchTo)             where T : class{             if (@this == null) throw new ArgumentNullException(nameof(@this));             if (switchTo == null) throw new ArgumentNullException(nameof(switchTo));             return @this.SelectMany(entry => entry != default(T) ? entry.Observe() : switchTo);         }     } }using System; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Combine{     public static partial class Combine{         public static IObservable<T> SwitchIfEmpty<T>(this IObservable<T> source, IObservable<T> switchTo) {             var signal = new AsyncSubject<Unit>();             return source.Do(_ => {                 signal.OnNext(Unit.Default);                  signal.OnCompleted();             }).Concat(switchTo.TakeUntil(signal));          }     } }using System; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Combine {     public static partial class Combine {         /// <summary>         /// starts receiving merged pairs as soon as both sequences have emitted a value, not when the source2 sequence has completed. the elements of the source2 sequence are buffered two times. One time by the Replay operator, and another one by the replayed.ToAsyncEnumerable()         /// </summary>         /// <returns></returns>         public static IObservable<(TFirst First, TSecond Second)> ZipWithRepeated<TFirst, TSecond>(             this IObservable<TFirst> source, IObservable<TSecond> other)              => other.Replay(replayed => source.ToAsyncEnumerable()                 .Zip(replayed.ToAsyncEnumerable().Repeat())                 .ToObservable());     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Conditional {     public static partial class Conditional {         public static IObservable<TResult> If<TSource, TResult>(this IObservable<TSource> source,             Func<int,TSource, bool> predicate, Func<TSource, IObservable<TResult>> thenSource, Func<TSource, IObservable<TResult>> elseSource)              => source.SelectMany((value, i) => predicate(i,value) ? thenSource(value) : elseSource(value));          public static IObservable<TResult> If<TSource, TResult>(this IObservable<TSource> source,             Func<TSource, bool> predicate, Func<TSource, IObservable<TResult>> thenSource, Func<TSource, IObservable<TResult>> elseSource)              => source.SelectMany(value => predicate(value) ? thenSource(value) : elseSource(value));          public static IObservable<TResult> If<TSource, TResult>(this IObservable<TSource> source,             Func<TSource, bool> predicate, Func<TSource, IObservable<TResult>> thenSource)              => source.SelectMany(value => predicate(value) ? thenSource(value) :Observable.Empty<TResult>());                  public static IObservable<TResult> If<TSource, TResult>(this IObservable<TSource> source,             Func<TSource, bool> predicate, Func<IObservable<TResult>> thenSource, Func< IObservable<TResult>> elseSource)              => source.If(predicate, _ => thenSource(),_ => elseSource());     } }using System; using System.ComponentModel; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Conditional{     public static partial class Conditional{         public static IObservable<T> TakeUntilDisposed<T>(this IObservable<T> source, IComponent component)              => source.TakeUntil(component.WhenDisposed());     } }using System; using System.Reactive.Concurrency; using System.Reactive.Disposables; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create{     public static partial class Create {         public static IObservable<Tuple<TSource1, TSource2>> Permutations<TSource1, TSource2>(             this IObservable<TSource1> source, IObservable<TSource2> other, IScheduler scheduler = null)              => Observable.Create<Tuple<TSource1, TSource2>>(observer => {                 var replay = other.Replay(scheduler ??= Scheduler.CurrentThread);                 var sequence = source.SelectMany(i => replay.Select(j => Tuple.Create(i, j)));                 return new CompositeDisposable(replay.Connect(), sequence.Subscribe(observer));             });     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<T> RepeatDefaultValueDuringSilence<T>(this IObservable<T> source,             TimeSpan maxQuietPeriod, IScheduler scheduler = null)             => source.RepeatDuringSilence(maxQuietPeriod, _ => typeof(T).DefaultValue().Observe().Cast<T>(),scheduler);     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<T> RepeatDuringSilence<T>(this IObservable<T> source, TimeSpan maxQuietPeriod,             Func<T, IObservable<T>> observableSelector, IScheduler scheduler = null)              =>  source.Select(x => Observable.Interval(maxQuietPeriod,scheduler??Scheduler.Default)                 .Select(_ => observableSelector(x)).Concat().StartWith(x)).Switch();     } }using System; using System.Reactive.Concurrency; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<T[]> RepeatEmptyDuringSilence<T>(this IObservable<T[]> source, TimeSpan maxQuietPeriod, IScheduler scheduler = null)             => source.RepeatDuringSilence(maxQuietPeriod, _ => Array.Empty<T>().Observe());     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<T> RepeatLastValue<T>(this IObservable<T> source,             Func<T,IObservable<object>> when, IScheduler scheduler = null) {             scheduler ??= Scheduler.Default;             return source.Select(x => when(x).Select(_ => x).StartWith(scheduler, x))                 .Switch();         }      } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create{     public static partial class Create {          public static IObservable<T> RepeatLastValueDuringSilence<T>(this IObservable<T> source,             TimeSpan maxQuietPeriod, IScheduler scheduler = null) {             scheduler ??= Scheduler.Default;             return source.Select(x => Observable.Interval(maxQuietPeriod, scheduler).Select(_ => x).StartWith(scheduler, x))                 .Switch();         }     } }using System; using System.Reactive.Disposables; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<TSource> RepeatUntilCompleted<TSource, TOther>(this IObservable<TSource> source, IObservable<TOther> other)              => Observable.Create<TSource>(observer => {                 var disposables = new CompositeDisposable();                 var completed = false;                 disposables.Add((other ??= (IObservable<TOther>)source).Subscribe(_ => { }, () => completed = true));                 disposables.Add(Observable.While(() => !completed, source).Subscribe(observer));                 return disposables;             });     } }using System; using System.Reactive; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Create {     public static partial class Create {         public static IObservable<T> RepeatUntilEmpty<T>(this IObservable<T> source)              => source.Materialize()                 .Repeat()                 .StartWith((Notification<T>)null)                 .Buffer(2, 1)                 .Select(it => {                     if (it[1].Kind != NotificationKind.OnCompleted) {                         return it[1];                     }                     // it[1] is OnCompleted, check the previous one                     if (it[0] != null && it[0].Kind != NotificationKind.OnCompleted) {                         // not a consecutive OnCompleted, so we ignore this OnCompleted with a NULL marker                         return null;                     }                      // okay, we have two consecutive OnCompleted, stop this observable.                     return it[1];                 })                 .Where(it => it != null) // remove the NULL marker                 .Dematerialize();     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.ErrorHandling { 	public static partial class ErrorHandling { 		public static IObservable<T> CompleteOnError<T>(this IObservable<T> source,Action<Exception> onError=null,Func<Exception,bool> match=null) 			=> source.Catch<T,Exception>(exception => { 				if (!(match?.Invoke(exception) ?? true)) return Observable.Throw<T>(exception); 				onError?.Invoke(exception); 				return Observable.Empty<T>(); 			});          		public static IObservable<T> CompleteOnError<T,TException>(this IObservable<T> source,Action<Exception> onError=null) where TException:Exception 			=> source.CompleteOnError(onError,exception => exception is TException);          		public static IObservable<T> CompleteOnError<T>(this IObservable<T> source,Type exceptionType,Action<Exception> onError=null)  			=> source.CompleteOnError(onError,exceptionType.IsInstanceOfType); 	} }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.ErrorHandling {     public static partial class ErrorHandling {         public static IObservable<T> ConsoleWriteLine<T>(this IObservable<T> source,Func<T,object> modify)              => source.Do(obj => Console.WriteLine(modify(obj)));          public static IObservable<T> ConsoleWriteLine<T>(this IObservable<T> source)              => source.Do(obj => Console.WriteLine(obj));     } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Filter;  namespace Xpand.Extensions.Reactive.ErrorHandling {     public static partial class ErrorHandling {         public static IObservable<T> RetryWhen<T,TException>(this IObservable<T> source) where TException : Exception              => source.RetryWhen(obs => obs.OfType<TException>());                  public static IObservable<T> RetryWhen<T,TException>(this IObservable<T> source,Func<TException,IObservable<Unit>> signal) where TException : Exception              => source.RetryWhen(obs => obs.OfType<TException>());                  public static IObservable<T> RetryWhenObjectDisposed<T>(this IObservable<T> source)              => source.RetryWhen<T,ObjectDisposedException>();                  // public static IObservable<T> RetryWhen<T,TException>(this IObservable<T> source,          //     Func<TException,IObservable<object>> retryOnError,IScheduler scheduler = null) where TException:Exception{         //     var strategy = SecondsBackoffStrategy;         //     scheduler ??= DefaultScheduler.Instance;         //     var attempt = 0;         //     return Observable.Defer(() => (attempt++ == 0 ? source : source.DelaySubscription(strategy(attempt - 1), scheduler))         //             .Select(Notification.CreateOnNext)         //             .Catch((TException ex) => retryOnError(ex).Publish(obs => obs.WhenNotDefault().SelectMany(_=>Observable.Return(Notification.CreateOnError<T>(ex)))         //                 .Merge(obs.WhenDefault().SelectMany(_=>Observable.Throw<Notification<T>>(ex))))))         //         .Retry().Dematerialize();         // }      } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Filter;  namespace Xpand.Extensions.Reactive.ErrorHandling {     public static partial class ErrorHandling {         /// <summary>         /// The default retry strategy for <see cref="RetryWithBackoff{T}"/>, which waits n^2 seconds between each retry, or 180 seconds, whichever is smaller.         /// </summary>         public static readonly Func<int, TimeSpan> SecondsBackoffStrategy = n => TimeSpan.FromSeconds(Math.Min(Math.Pow(2, n), 180));         public static readonly Func<int, TimeSpan> MilliSecondsBackoffStrategy = n => TimeSpan.FromMilliseconds(Math.Min(Math.Pow(2, n), 180)*200);          /// <summary>         /// Retries an observable upon failure, using the provided strategy to determine how long to wait between retries.         /// </summary>         /// <remarks>         /// <para>         /// This extension method can be used to retry any source pipeline a specified number of times, with a custom         /// wait period between those retries. The <paramref name="retryCount"/> parameter determines the maximum number of retries. The         /// default value is <see langword="null"/>, which means there is no maximum (will retry indefinitely). The         /// <paramref name="strategy"/> parameter dictates the period between retries, and it defaults to <see cref="SecondsBackoffStrategy"/>.         /// </para>         /// <para>         /// The <paramref name="retryOnError"/> parameter can be used to determine whether a particular exception should instigate a         /// retry. By default, all exceptions will.         /// </para>         /// </remarks>         /// <typeparam name="T">         /// The source type.         /// </typeparam>         /// <param name="source">         /// The source observable.         /// </param>         /// <param name="retryCount">         /// How many times to retry, or <see langword="null"/> to retry indefinitely.         /// </param>         /// <param name="strategy">         /// The strategy to use when retrying, or <see langword="null"/> to use <see cref="SecondsBackoffStrategy"/>.         /// </param>         /// <param name="retryOnError">         /// Predicate to determine whether a given error should result in a retry, or <see langword="null"/> to always retry on error.         /// </param>         /// <param name="scheduler">         /// The scheduler to use for delays, or <see langword="null"/> to use the default scheduler.         /// </param>         /// <returns>         /// An observable that will retry a failing source observable according to the timing dictated by <paramref name="strategy"/>.         /// </returns>         public static IObservable<T> RetryWithBackoff<T>(this IObservable<T> source, int? retryCount = null, Func<int, TimeSpan> strategy = null,             Func<Exception, bool> retryOnError = null, IScheduler scheduler = null) {             strategy ??= SecondsBackoffStrategy;             scheduler ??= DefaultScheduler.Instance;             retryOnError ??= (_ => true);             var attempt = 0;             var pipeline = Observable.Defer(() => (attempt++ == 0 ? source : source.DelaySubscription(strategy(attempt - 1), scheduler))                 .Select(Notification.CreateOnNext)                 .Catch((Exception ex) => retryOnError(ex) ? Observable.Throw<Notification<T>>(ex) : Observable.Return(Notification.CreateOnError<T>(ex))));             pipeline = retryCount.HasValue ? pipeline.Retry(retryCount.Value) : pipeline.Retry();             return pipeline.Dematerialize();         }     } }using System; using System.Linq; using System.Reactive.Concurrency; using System.Reactive.Linq;  using Xpand.Extensions.Reactive.Combine;  namespace Xpand.Extensions.Reactive.Filter{     public static partial class Filter{                  public static IObservable<T> DistinctUntilChanged<T>(this IObservable<T> source, TimeSpan duration,             IScheduler scheduler = null, Func<T, object> keySelector = null, Func<T, object, bool> matchFunc = null){             scheduler ??= Scheduler.Default;             matchFunc ??= (arg1, arg2) => ReferenceEquals(null, arg1) ? ReferenceEquals(null, arg2) : arg1.Equals(arg2);             keySelector ??= arg => arg;             var sourcePub = source.Publish().RefCount();             return sourcePub.GroupByUntil(k => keySelector(k), x => Observable.Timer(duration, scheduler)                         .TakeUntil(sourcePub.Where(item => !matchFunc(item, x.Key))))                 .SelectMany(y => y.FirstAsync());         }     } }using System; using System.Linq; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Combine;  namespace Xpand.Extensions.Reactive.Filter {     public static partial class Filter {         public static IObservable<T> DistinctWithPrevious<T, T2>(this IObservable<T[]> source, Func<T, T2> selector)             => source.CombineWithPrevious().Where(t => t.previous != null)                 .SelectMany(t => t.current.Where(info => {                     var currentValue = selector(info);                     return !t.previous.Select(selector).Contains(currentValue);                 }).StartWith(t.previous));     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Filter {     public static partial class Filter {         public static IObservable<TSource> ExactType<TSource>(this IObservable<object> source)             => source.WhenNotDefault().OfType<TSource>().Where(source1 => source1.GetType() == typeof(TSource));     } }using System; using System.Diagnostics; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Filter {     public static partial class Filter {         public static IObservable<T> WhenDebuggerThrottle<T>(this IObservable<T> source, TimeSpan delay) {             if (Debugger.IsAttached) {                 return source.Throttle(delay);             }              return source;         }          public static IObservable<T> ThrottleN<T>(this IObservable<T> source,int take, TimeSpan delay, IScheduler scheduler = null)              => source.Publish(o => o.Take(take)                 .Concat(o.IgnoreElements().TakeUntil(default(T).Observe().Delay(delay, scheduler ??= Scheduler.Default)))                 .Repeat()                 .TakeUntil(o.IgnoreElements().Concat(Observable.Return(default(T)))));     } }using System; using System.Reactive.Linq; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.Reactive.Filter{     public static partial class Filter{ 	    public static IObservable<TSource> WhenDefault<TSource>(this IObservable<TSource> source)  		    => source.Where(obj => obj.IsDefaultValue());  	    public static IObservable<TSource> WhenDefault<TSource,TValue>(this IObservable<TSource> source,Func<TSource, TValue> valueSelector)  		    =>source.Where(source1 => valueSelector(source1).IsDefaultValue()); 	     	    public static IObservable<TSource> WhenDefault<TSource>(this IObservable<TSource> source,Func<TSource, object> valueSelector,Func<TSource,Type> valueType)  		    =>source.Where(source1 => valueSelector(source1).IsDefaultValue());     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Filter {     public static partial class Filter {         public static IObservable<TSource> WhenNot<TSource>(this IObservable<TSource> source, Func<TSource, bool> filter)              => source.Where(source1 => !filter(source1));     } }using System; using System.Collections; using System.Reactive.Linq; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.Reactive.Filter{     public static partial class Filter{ 	    public static IObservable<TSource> WhenNotDefault<TSource,TValue>(this IObservable<TSource> source,Func<TSource,TValue> valueSelector)              =>source.Where(source1 => !valueSelector(source1).IsDefaultValue());          public static IObservable<TSource> WhenNotDefault<TSource>(this IObservable<TSource> source) => source.Where(s => !s.IsDefaultValue());                  public static IObservable<TSource> WhenNotDefaultOrEmpty<TSource>(this IObservable<TSource> source) where TSource:IEnumerable             => source.WhenNotDefault().WhenNotEmpty();                  public static IObservable<string> WhenNotDefaultOrEmpty(this IObservable<string> source) => source.Where(s => !s.IsNullOrEmpty());                  public static IObservable<string> WhenDefaultOrEmpty(this IObservable<string> source) => source.Where(s => s.IsNullOrEmpty());     } }using System; using System.Collections; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Filter{     public static partial class Filter{         public static IObservable<TOut> WhenNotEmpty<TOut>(this IObservable<TOut> source) where TOut:IEnumerable             => source.Where(outs => outs.Cast<object>().Any());      } }using System; using System.ComponentModel; using System.Linq; using System.Linq.Expressions; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.ExpressionExtensions; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Filter{     public static partial class Filter{         public static IObservable<(TObject sender, PropertyChangedEventArgs e)> WhenPropertyChanged<TObject>(this TObject o, Expression<Func<TObject, object>> memberSelector) where TObject : INotifyPropertyChanged              => o.WhenPropertyChanged().Where(_ =>memberSelector==null|| _.e.PropertyName == memberSelector.MemberExpressionName());          public static IObservable<(TObject sender, PropertyChangedEventArgs e)> WhenPropertyChanged<TObject>(this TObject o,params string[] names) where TObject : INotifyPropertyChanged              => o.WhenEvent<PropertyChangedEventArgs>(nameof(INotifyPropertyChanged.PropertyChanged))                 .Where(eventArgs =>!names.Any()|| names.Any(s => s==eventArgs.PropertyName)).InversePair(o);          public static IObservable<(TObject sender, PropertyChangedEventArgs e)> WhenPropertyChanged<TObject>(this IObservable<TObject> source,             Expression<Func<TObject, object>> memberSelector, IScheduler scheduler = null) where TObject : INotifyPropertyChanged              => source.SelectMany(o => o.WhenPropertyChanged(memberSelector));              } }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.Reactive")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.Reactive")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Subjects {      /// <summary>     /// Subject with same semantics as <see cref="ValveSubject{T}"/>, but adding flushing out capability      /// which allows clearing the valve of any remaining elements before closing.     /// </summary>     /// <typeparam name="T">Elements type</typeparam>     public class FlushableValveSubject<T> : IFlushableValveSubject<T> {         private readonly BehaviorSubject<ValveSubject<T>> _valvesSubject = new(new ValveSubject<T>());         private ValveSubject<T> CurrentValve => _valvesSubject.Value;          public bool IsOpen => CurrentValve.IsOpen;          public bool IsClosed => CurrentValve.IsClosed;          public void OnNext(T value) => CurrentValve.OnNext(value);          public void OnError(Exception error) => CurrentValve.OnError(error);          public void OnCompleted() {             CurrentValve.OnCompleted();             _valvesSubject.OnCompleted();         }          public IDisposable Subscribe(IObserver<T> observer) => _valvesSubject.Switch().Subscribe(observer);          public void Open() => CurrentValve.Open();          public void Close() => CurrentValve.Close();          /// <summary>         /// Discards remaining elements in the valve and reset the valve into a closed state         /// </summary>         /// <returns>Replayable observable with any remaining elements</returns>         public IObservable<T> FlushAndClose() {             var previousValve = CurrentValve;             _valvesSubject.OnNext(CreateClosedValve());             var remainingElements = new ReplaySubject<T>();             previousValve.Subscribe(remainingElements);             previousValve.Open();             return remainingElements;         }          private static ValveSubject<T> CreateClosedValve() {             var valve = new ValveSubject<T>();             valve.Close();             return valve;         }     }      public interface IFlushableValveSubject<T> : IValveSubject<T> {         IObservable<T> FlushAndClose();     }      public static class FlushableValveExtensions {         public static IFlushableValveSubject<T> Synchronize<T>(this IFlushableValveSubject<T> valve)             => Synchronize(valve, new object());          public static IFlushableValveSubject<T> Synchronize<T>(this IFlushableValveSubject<T> valve, object gate)             => new SynchronizedFlushableValveAdapter<T>(valve, gate);     }      internal class SynchronizedFlushableValveAdapter<T> : SynchronizedValveAdapter<T>, IFlushableValveSubject<T> {         private readonly object _gate;         private readonly IFlushableValveSubject<T> _valve;          public SynchronizedFlushableValveAdapter(IFlushableValveSubject<T> valve, object gate)             : base(valve, gate) {             _valve = valve;             _gate = gate;         }          public IObservable<T> FlushAndClose() {             lock (_gate) {                 return _valve.FlushAndClose();             }         }     } }using System; using System.Collections.Generic; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Subjects {     public class ReplayLastPerKeySubject<T, TKey> : ISubject<T> {         private readonly Func<T, TKey> _keySelector;         private readonly ReplaySubject<ReplaySubject<T>> _subjects;         private readonly IObservable<T> _mergedSubjects;         private readonly Dictionary<TKey, ReplaySubject<T>> _perKey;          public ReplayLastPerKeySubject(Func<T, TKey> keySelector) {             _keySelector = keySelector;             _subjects = new ReplaySubject<ReplaySubject<T>>();             _mergedSubjects = _subjects.Merge();             _perKey = new Dictionary<TKey, ReplaySubject<T>>();         }          public void OnNext(T value) {             var key = _keySelector(value);             if (!_perKey.TryGetValue(key, out var subject)) {                 subject = new ReplaySubject<T>(1);                 _perKey.Add(key, subject);                 _subjects.OnNext(subject);             }              subject.OnNext(value);         }          public void OnCompleted() {             _subjects.OnCompleted();             _subjects.Subscribe(subject => subject.OnCompleted());         }          public void OnError(Exception error) => _subjects.OnError(error);          public IDisposable Subscribe(IObserver<T> observer) => _mergedSubjects.Subscribe(observer);     } }using System; using System.Reactive.Concurrency; using System.Reactive.Disposables; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Subjects {     public class RollingReplaySubject {         public static RollingReplaySubject<TSource, long> Create<TSource>(             TimeSpan bufferClearingInterval) {             return                 new RollingReplaySubject<TSource, long>(                     Observable.Interval(bufferClearingInterval));         }          public static RollingReplaySubject<TSource, long> Create<TSource>(             TimeSpan bufferClearingInterval, IScheduler scheduler) {             return                 new RollingReplaySubject<TSource, long>(                     Observable.Interval(bufferClearingInterval, scheduler));         }          protected class NopSubject<TSource> : ISubject<TSource> {             public static readonly NopSubject<TSource> Default = new();              public void OnCompleted() { }              public void OnError(Exception error) { }              public void OnNext(TSource value) { }              public IDisposable Subscribe(IObserver<TSource> observer) {                 return Disposable.Empty;             }         }     }      public class RollingReplaySubject<TSource, TBufferClearing> : RollingReplaySubject, ISubject<TSource> {         private readonly ReplaySubject<IObservable<TSource>> _subjects;         private readonly IObservable<TSource> _concatenatedSubjects;         private ISubject<TSource> _currentSubject;         private readonly IDisposable _bufferClearingHandle;         private readonly object _gate = new();          public RollingReplaySubject(IObservable<TBufferClearing> bufferClearing) {             _bufferClearingHandle = bufferClearing.Synchronize(_gate).Subscribe(_ => Clear());             _subjects = new ReplaySubject<IObservable<TSource>>(1);             _concatenatedSubjects = _subjects.Concat();             _currentSubject = new ReplaySubject<TSource>();             _subjects.OnNext(_currentSubject);         }          private void Clear() {             _currentSubject.OnCompleted();             _currentSubject = new ReplaySubject<TSource>();             _subjects.OnNext(_currentSubject);         }          public void OnNext(TSource value) {             lock (_gate) {                 _currentSubject.OnNext(value);             }         }          public void OnError(Exception error) {             lock (_gate) {                 _currentSubject.OnError(error);                 _currentSubject = NopSubject<TSource>.Default;                 _bufferClearingHandle.Dispose();             }         }          public void OnCompleted() {             lock (_gate) {                 _currentSubject.OnCompleted();                 _subjects.OnCompleted();                 _currentSubject = NopSubject<TSource>.Default;                 _bufferClearingHandle.Dispose();             }         }          public IDisposable Subscribe(IObserver<TSource> observer) {             return _concatenatedSubjects.Subscribe(observer);         }     } }using System; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Subjects {     /// <summary>     /// Subject offering Open() and Close() methods, with built-in buffering.     /// Note that closing the valve in the observer is supported.     /// </summary>     /// <remarks>As is the case with other Rx subjects, this class is not thread-safe, in that     /// order of elements in the output is in-deterministic in the case of concurrent operation      /// of Open()/Close()/OnNext()/OnError(). To guarantee strict order of delivery even in the      /// case of concurrent access, <see cref="ValveSubjectExtensions.Synchronize{T}(IValveSubject{T})"/> can be used.</remarks>     /// <typeparam name="T">Elements type</typeparam>     public class ValveSubject<T> : IValveSubject<T> {         private enum Valve {             Open,             Closed         }          private readonly Subject<T> _input = new();         private readonly BehaviorSubject<Valve> _valveSubject = new(Valve.Open);         private readonly Subject<T> _output = new();          public ValveSubject() {             var valveOperations = _valveSubject.DistinctUntilChanged();             _input.Buffer(valveOperations.Where(v => v == Valve.Closed),                     _ => valveOperations.Where(v => v == Valve.Open))                 .SelectMany(t => t).Subscribe(_input);             _input.Where(_ => _valveSubject.Value == Valve.Open).Subscribe(_output);         }          public bool IsOpen => _valveSubject.Value == Valve.Open;          public bool IsClosed => _valveSubject.Value == Valve.Closed;          public void OnNext(T value) => _input.OnNext(value);          public void OnError(Exception error) => _input.OnError(error);          public void OnCompleted() {             _output.OnCompleted();             _input.OnCompleted();             _valveSubject.OnCompleted();         }          public IDisposable Subscribe(IObserver<T> observer) => _output.Subscribe(observer);          public void Open() => _valveSubject.OnNext(Valve.Open);          public void Close() => _valveSubject.OnNext(Valve.Closed);     }      public interface IValveSubject<T> : ISubject<T> {         void Open();          void Close();     }      public static class ValveSubjectExtensions {         public static IValveSubject<T> Synchronize<T>(this IValveSubject<T> valve) => Synchronize(valve, new object());          public static IValveSubject<T> Synchronize<T>(this IValveSubject<T> valve, object gate) => new SynchronizedValveAdapter<T>(valve, gate);     }      internal class SynchronizedValveAdapter<T> : IValveSubject<T> {         private readonly object _gate;         private readonly IValveSubject<T> _valve;          public SynchronizedValveAdapter(IValveSubject<T> valve, object gate) {             _valve = valve;             _gate = gate;         }          public void OnNext(T value) {             lock (_gate) {                 _valve.OnNext(value);             }         }          public void OnError(Exception error) {             lock (_gate) {                 _valve.OnError(error);             }         }          public void OnCompleted() {             lock (_gate) {                 _valve.OnCompleted();             }         }          public IDisposable Subscribe(IObserver<T> observer) => _valve.Subscribe(observer);          public void Open() {             lock (_gate) {                 _valve.Open();             }         }          public void Close() {             lock (_gate) {                 _valve.Close();             }         }     } }using System; using System.Collections.Generic; using System.Collections.Immutable; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<IReadOnlyList<T>> AccumulateAll<T>(this IObservable<T> next)              => next.Scan(ImmutableList<T>.Empty, (a, b) => a.Add(b));          public static IObservable<IReadOnlyList<int>> AccumulateAllOrdered(this IObservable<int> source)              => source.Scan(ImmutableList<int>.Empty, (a, b) => {                 var res = a.BinarySearch(b);                 if (res <= -1)                     res = ~res;                 return a.Insert(res, b);             });          public static IObservable<IReadOnlyList<double>> AccumulateAllOrdered(this IObservable<double> source)              => source.Scan(ImmutableList<double>.Empty, (a, b) => {                 var res = a.BinarySearch(b);                 if (res <= -1)                     res = ~res;                 return a.Insert(res, b);             });          public static IObservable<IReadOnlyList<decimal>> AccumulateAllOrdered(this IObservable<decimal> source)              => source.Scan(ImmutableList<decimal>.Empty, (a, b) => {                 var res = a.BinarySearch(b);                 if (res <= -1)                     res = ~res;                 return a.Insert(res, b);             });     } }using System; using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<double> LiveAverage(this IObservable<double> source)             => source.Publish(p => p.LiveCount().Zip(p.LiveSum(), (a, b) => b / a));          public static IObservable<decimal> LiveAverage(this IObservable<decimal> source)              => source.Publish(p => p.LiveCount().Zip(p.LiveSum(), (a, b) => b / a));          public static IObservable<double> LiveAverage<T>(this IObservable<T> source, Func<T, int> func)              => source.Publish(p => p.LiveCount().Zip(p.LiveSum(func), (a, b) => (double) b / a));          public static IObservable<decimal> LiveAverage<T>(this IObservable<T> source, Func<T, decimal> func)              => source.Publish(p => p.LiveCount().Zip(p.LiveSum(func), (a, b) => b / a));          public static IObservable<double> LiveAverage<T>(this IObservable<T> source, Func<T, double> func)              => source.Publish(p => p.LiveCount().Zip(p.LiveSum(func), (a, b) => b / a));              } }using System; using System.Collections.Generic; using System.Linq; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Reactive.Subjects; using Xpand.Extensions.Numeric;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T[]> RollingBuffer<T>(this IObservable<T> source, TimeSpan buffering, IScheduler scheduler = null) {             scheduler ??= TaskPoolScheduler.Default;             return Observable.Create<T[]>(o => {                 var list = new LinkedList<Timestamped<T>>();                 return source.Timestamp(scheduler).Subscribe(tx => {                     list.AddLast(tx);                     while (scheduler.Now.Ticks > buffering.Ticks &&                            (list.First!.Value.Timestamp < scheduler.Now.Subtract(buffering)))                         list.RemoveFirst();                     o.OnNext(list.Select(tx2 => tx2.Value).ToArray());                 }, o.OnError, o.OnCompleted);             });         }          public static IObservable<IList<T>> BufferUntilInactive<T>(this IObservable<T> source, TimeSpan delay,IScheduler scheduler=null)             => source.BufferUntilInactive(delay,window => window.ToList(),scheduler);                  public static IObservable<IList<T>> BufferUntilInactive<T>(this IObservable<T> source, int seconds,IScheduler scheduler=null)             => source.BufferUntilInactive(seconds.Seconds(),window => window.ToList(),scheduler);                  public static IObservable<IList<T>> BufferUntilInactive<T>(this IObservable<T> source, TimeSpan delay,Func<IObservable<T>,IObservable<IList<T>>> resultSelector,IScheduler scheduler=null)             => source.Publish(obs => obs.Window(() => obs.Throttle(delay,scheduler??Scheduler.Default)).SelectMany(resultSelector));                  public static IObservable<TSource[]> BufferUntilCompleted<TSource>(this IObservable<TSource> source,bool skipEmpty=false)              => source.Buffer(Observable.Never<Unit>()).Where(sources => !skipEmpty || sources.Any()).Select(list => list.ToArray());          /// <summary>         /// Returns a connectable observable, that once connected, will start buffering data until the observer subscribes, at which time it will send all buffered data to the observer and then start sending new data.         /// Thus the observer may subscribe late to a hot observable yet still see all of the data.  Later observers will not see the buffered events.         /// </summary>         /// <param name="source"></param>         /// <returns></returns>         public static IConnectableObservable<T> BufferUntilSubscribed<T>(this IObservable<T> source) {             return new BufferUntilSubscribedObservable<T>(source, ImmediateScheduler);         }          class BufferUntilSubscribedObservable<T> : IConnectableObservable<T> {             private readonly IObservable<T> _source;             private readonly IScheduler _scheduler;             private readonly Subject<T> _liveEvents;             private bool _observationsStarted;             private Queue<T> _buffer;             private readonly object _gate;              public BufferUntilSubscribedObservable(IObservable<T> source, IScheduler scheduler) {                 _source = source;                 _scheduler = scheduler;                 _liveEvents = new Subject<T>();                 _buffer = new Queue<T>();                 _gate = new object();                 _observationsStarted = false;             }              public IDisposable Subscribe(IObserver<T> observer) {                 lock (_gate) {                     if (_observationsStarted) {                         return _liveEvents.Subscribe(observer);                     }                      _observationsStarted = true;                      var bufferedEvents =                         GetBuffers().Concat()                             .Finally(                                 RemoveBuffer); // Finally clause to remove the buffer if the first observer stops listening.                     return _liveEvents.Merge(bufferedEvents).Subscribe(observer);                 }             }              public IDisposable Connect() {                 return _source.Subscribe(OnNext, _liveEvents.OnError, _liveEvents.OnCompleted);             }              private void RemoveBuffer() {                 lock (_gate) {                     _buffer = null;                 }             }              /// <summary>             /// Acquires a lock and checks the buffer.  If it is empty, then replaces it with null and returns null.  Else replaces it with an empty buffer and returns the old buffer.             /// </summary>             /// <returns></returns>             private Queue<T> GetAndReplaceBuffer() {                 lock (_gate) {                     if (_buffer == null) {                         return null;                     }                      if (_buffer.Count == 0) {                         _buffer = null;                         return null;                     }                      var result = _buffer;                     _buffer = new Queue<T>();                     return result;                 }             }              /// <summary>             /// An enumerable of buffers that will complete when a call to GetAndReplaceBuffer() returns a null, e.g. when the observer has caught up with the incoming source data.             /// </summary>             /// <returns></returns>             private IEnumerable<IObservable<T>> GetBuffers() {                 while (GetAndReplaceBuffer() is{ } buffer) {                     yield return buffer.ToObservable(_scheduler);                 }             }              private void OnNext(T item) {                 lock (_gate) {                     if (_buffer != null) {                         _buffer.Enqueue(item);                         return;                     }                 }                  _liveEvents.OnNext(item);             }         }                  /// <summary>         /// Emits a list every interval that contains all the currently buffered elements.         /// </summary>         public static IObservable<IList<TSource>> BufferHistorical<TSource>(this IObservable<TSource> source, TimeSpan interval, TimeSpan replayDuration)              => source.Replay(replayed => Observable.Interval(interval)                 .SelectMany(_ => replayed.TakeUntil(Observable.Return(Unit.Default, Scheduler.CurrentThread)).ToList())                 .TakeUntil(replayed.LastOrDefaultAsync()), replayDuration, ImmediateScheduler);                  public static IObservable<IList<TSource>> BufferOmitEmpty<TSource>(this IObservable<TSource> observable, TimeSpan maxDelay, int maxBufferCount)              => observable.GroupByUntil(_ => 1, g => Observable.Timer(maxDelay).Merge(g.Skip(maxBufferCount - 1).Take(1).Select(_ => 1L)))                 .Select(x => x.ToArray())                 .Switch();                  /// <summary>         /// Splits the elements of a sequence into chunks that are starting with         /// elements that satisfy the predicate.         /// </summary>         public static IObservable<IList<TSource>> BufferByPredicate<TSource>(this IObservable<TSource> source, Predicate<TSource> startNewBufferPredicate)              => source.SelectMany(x => {                     var subSequence = Observable.Return((Value: x, HasValue: true));                     return startNewBufferPredicate(x) ? subSequence.Prepend((default, false)) : subSequence;                 })                 .GroupByUntil(_ => 0, g => g.SkipWhile(e => e.HasValue))                 .SelectMany(g => g.Where(e => e.HasValue).Select(e => e.Value).ToArray())                 .Where(w => w.Length > 0);          public static IObservable<T> BufferWhen<T>(this IObservable<T> source, IObservable<object> signal,Func<IObservable<T>,IObservable<T>> selector=null)              => source.Publish(obs => obs.Buffer(signal).Take(1)                 .SelectMany(list => list.ToNowObservable().Concat(selector?.Invoke(obs)??obs)));     }           }using System; using System.Reactive; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Filter;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> ConcatDefer<T>(this IObservable<T> source, Func<IObservable<T>> target)             => source.Concat(Observable.Defer(target));          public static IObservable<Unit> ConcatDeferToUnit<T>(this IObservable<T> source, Func<IObservable<T>> target)             => source.ToUnit().Concat(Observable.Defer(target).ToUnit());         public static IObservable<Unit> ConcatDeferToUnit<T>(this IObservable<T> source, Func<IObservable<object>> target)             => source.ToUnit().Concat(Observable.Defer(target).ToUnit());                  public static IObservable<Unit> ConcatToUnit<T,T1>(this IObservable<T> source, IObservable<T1> target)             => source.ToUnit().Concat(Observable.Defer(target.ToUnit));                  public static IObservable<TTarget> ConcatIgnoredValue<TSource,TTarget>(this IObservable<TSource> source, TTarget value)              => source.Select(_ => default(TTarget)).WhenNotDefault().Concat(value.Observe());                  public static IObservable<Unit> ConcatIgnoredUnit<TSource>(this IObservable<TSource> source)              => source.ConcatIgnoredValue(Unit.Default);         public static IObservable<T> ConcatIgnored<T,T2>(this IObservable<T> source,Func<T,IObservable<T2>> secondSelector,Func<T,bool> merge=null)             => source.SelectMany(arg => {                 merge ??= _ => true;                 return merge(arg) ? secondSelector(arg).IgnoreElements().ConcatIgnoredValue(arg).Finally(() => {}) : arg.Observe();             });         public static IObservable<T> ConcatIgnored<T>(this IObservable<T> source,Action<T> action,Func<T,bool> merge=null)             => source.SelectMany(arg => {                 merge ??= _ => true;                 if (merge(arg)) {                     action(arg);                     return Observable.Empty<T>().ConcatIgnoredValue(arg);                 }                 return arg.Observe();             });         public static IObservable<T> ConcatIgnoredFirst<T,T2>(this IObservable<T> source,Func<T,IObservable<T2>> secondSelector,Func<T,bool> merge=null)             => source.SelectMany((arg, i) => {                 var observable = Observable.Empty<T>();                 if (i == 0) {                     merge ??= _ => true;                     if (merge(arg)) {                         observable = secondSelector(arg).IgnoreElements().To(arg);                     }                     return observable.Concat(arg.Observe());                 }                  return arg.Observe();              });     } }using System; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<(T item, int length)> CountSubsequent<T>(this IObservable<T> source, Func<T, object> key){             var eventTraceSubject = source.Publish().RefCount();             return eventTraceSubject                 .GroupByUntil(key, _ => eventTraceSubject.DistinctUntilChanged(key))                 .SelectMany(ob => {                     var r = ob.Replay();                     r.Connect();                     return r.IgnoreElements().Concat(default(T).Observe())                         .Select(_ => r.ToEnumerable().ToArray());                 })                 .Select(_ => (_.First(), _.Length));         }  	    public static IObservable<int> CountLiveStreams<T>(this IObservable<IObservable<T>> streamOfStreams)              => streamOfStreams.Select(x => x.IgnoreElements().Select(_ => 0).Catch(Observable.Empty<int>()).Prepend(1).Append(-1))                 .Merge()                 .Scan(0, (accumulator, delta) => accumulator + delta)                 .Prepend(0);                  public static IObservable<int> LiveCount<T>(this IObservable<T> source)             => source.Select((_, b) => b + 1);          public static IObservable<long> LiveLongCount<T>(this IObservable<T> source)              => source.Scan(0L, (a, _) => a + 1);                       } }namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {              } }using System; using System.Collections.Generic; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> DistinctLatest<T, TKey>(this IObservable<T> newElements,             IEnumerable<T> seedElements, Func<T, TKey> replacementSelector)              => seedElements.ToObservable()                 .Concat(newElements)                 .GroupBy(_ => replacementSelector)                 .SelectMany(grp => grp.Replay(1).Publish().RefCount());     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<T> DoNotComplete<T>(this IObservable<T> source) => source.Concat(Observable.Never<T>());     } }using System; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<TOut> Drain<TSource, TOut>(this IObservable<TSource> source, Func<TSource, IObservable<TOut>> selector)              => Observable.Defer(() => {                 var queue = new BehaviorSubject<Unit>(new Unit());                 return source.Zip(queue, (v, q) => v)                     .SelectMany(v => selector(v).Do(_ => { }, () => queue.OnNext(new Unit())));             });     } }using System; using System.Collections.Generic; using System.Reactive.Linq; using System.Threading;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{                  /// <summary>Projects each element to an observable sequence, which is merged         /// in the output observable sequence only if the previous projected observable         /// sequence has completed.</summary>         public static IObservable<TResult> ExhaustMap<TSource, TResult>(this IObservable<TSource> source, Func<TSource, IObservable<TResult>> function)              => Observable.Defer(() => {                 int mutex = 0;                 return source.SelectMany(item => Interlocked.CompareExchange(ref mutex, 1, 0) == 0                         ? function(item).Finally(() => Volatile.Write(ref mutex, 0)) : Observable.Empty<TResult>());             });                  /// <summary>Projects each element to an observable sequence, which is merged         /// in the output observable sequence only if the previous projected observable         /// sequence has completed.</summary>         public static IObservable<TResult> ExhaustMap<TSource, TResult>(this IObservable<TSource> source, Func<TSource,int, IObservable<TResult>> function)              => Observable.Defer(() => {                 int mutex = 0;                 return source.SelectMany((item, i) => Interlocked.CompareExchange(ref mutex, 1, 0) == 0                     ? function(item,i).Finally(() => Volatile.Write(ref mutex, 0)) : Observable.Empty<TResult>());             });                   public static IObservable<TResult> ExhaustMapPerKey<TSource, TKey, TResult>(             this IObservable<TSource> source, Func<TSource, TKey> keySelector,             Func<TSource, TKey, IObservable<TResult>> function, int maximumConcurrency, IEqualityComparer<TKey> keyComparer = default)              => Observable.Using(() => new SemaphoreSlim(maximumConcurrency, maximumConcurrency), globalSemaphore => source                 .GroupBy(keySelector, keyComparer ??= EqualityComparer<TKey>.Default)                 .SelectMany(group => Observable.Using(() => new SemaphoreSlim(1, 1),                     localSemaphore => @group.SelectMany(item => Observable.If(() => localSemaphore.Wait(0),                         Observable.If(() => globalSemaphore.Wait(0), Observable.Defer(() => function(item, @group.Key))                                 .Finally(() => globalSemaphore.Release()))                             .Finally(() => localSemaphore.Release()))))));     } }using System; using System.Collections.Generic; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         /// <summary>         /// Ignores elements having a specific value, until this value has         /// been repeated contiguously for a specific duration.         /// </summary>         public static IObservable<T> IgnoreNonEstablishedContiguousValue<T>(             this IObservable<T> source, T value, TimeSpan dueTimeUntilEstablished,             IEqualityComparer<T> comparer = default, IScheduler scheduler = default)              => Observable.Defer(() => {                 IStopwatch stopwatch = null;                 return source.Do(item => {                         if ((comparer ??= EqualityComparer<T>.Default).Equals(item, value))                             stopwatch ??= (scheduler ??= global::System.Reactive.Concurrency.Scheduler.Default).StartStopwatch();                         else                             stopwatch = null;                     })                     .Where(_ => stopwatch == null || stopwatch.Elapsed >= dueTimeUntilEstablished);             });     } } using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<decimal> LiveMax(this IObservable<decimal> source)              => source.Scan(decimal.MaxValue, Math.Max);          public static IObservable<int> LiveMax(this IObservable<int> source)             => source.Scan(int.MaxValue, Math.Max);          public static IObservable<double> LiveMax(this IObservable<double> source)              => source.Scan(double.MaxValue, Math.Max);     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<double> LiveMedian(this IObservable<int> source)             => source.AccumulateAllOrdered().Select(a => a.Count % 2 == 0 ? (double)(a[a.Count / 2 - 1] + a[a.Count / 2]) / 2 : a[a.Count / 2]);          public static IObservable<decimal> LiveMedian(this IObservable<decimal> source)              => source.AccumulateAllOrdered().Select(a => a.Count % 2 == 0 ? (a[a.Count / 2 - 1] + a[a.Count / 2]) / 2 : a[a.Count / 2]);           public static IObservable<double> LiveMedian(this IObservable<double> source)              => source.AccumulateAllOrdered().Select(a => a.Count % 2 == 0 ? (a[a.Count / 2 - 1] + a[a.Count / 2]) / 2 : a[a.Count / 2]);              } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<decimal> LiveMin(this IObservable<decimal> source)              => source.Scan(decimal.MaxValue, Math.Min);          public static IObservable<int> LiveMin(this IObservable<int> source)             => source.Scan(int.MaxValue, Math.Min);          public static IObservable<double> LiveMin(this IObservable<double> source)              => source.Scan(double.MaxValue, Math.Min);     } }using System; using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Reactive.Linq; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<IGrouping<int, int>> LiveModa(this IObservable<int> source)              => source.GroupBy(a => a).Select(a => a.LiveCount().Select(b => Tuple.Create(a.Key, b))).Merge()                 .Scan(default(KeyValuePair<int, ImmutableStack<int>>), (a, b) => a.Key > b.Item2 ? a :                     a.Key == b.Item2 ? new KeyValuePair<int, ImmutableStack<int>>(b.Item2, a.Value.Push(b.Item1)) :                     new KeyValuePair<int, ImmutableStack<int>>(b.Item2, ImmutableStack<int>.Empty.Push(b.Item1)))                 .Select(a => a.Value.AsGroup(a.Key));          public static IObservable<IGrouping<int, decimal>> LiveModa(this IObservable<decimal> source)              => source.GroupBy(a => a).Select(a => a.LiveCount().Select(b => Tuple.Create(a.Key, b)))                 .Merge().Scan(default(KeyValuePair<int, ImmutableStack<decimal>>), (a, b)                      => a.Key > b.Item2 ? a : a.Key == b.Item2 ? new KeyValuePair<int, ImmutableStack<decimal>>(b.Item2, a.Value.Push(b.Item1))                         : new KeyValuePair<int, ImmutableStack<decimal>>(b.Item2, ImmutableStack<decimal>.Empty.Push(b.Item1)))                 .Select(a => a.Value.AsGroup(a.Key));                       } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<(TSource source, TValue other)> Pair<TSource, TValue>(this IObservable<TSource> source, TValue value) =>             source.Select(_ => (_, value));         public static IObservable<(TValue value, TSource source)> InversePair<TSource, TValue>(this IObservable<TSource> source, TValue value) =>             source.Select(_ => ( value,_));     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<decimal> LiveRange(this IObservable<decimal> source)              => source.Publish(p => p.LiveMax().Zip(p.LiveMin(), (a, b) => a - b).Skip(1));          public static IObservable<int> LiveRange(this IObservable<int> source)              => source.Publish(p => p.LiveMax().Zip(p.LiveMin(), (a, b) => a - b).Skip(1));          public static IObservable<double> LiveRange(this IObservable<double> source)              => source.Publish(p => p.LiveMax().Zip(p.LiveMin(), (a, b) => a - b).Skip(1));              } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Combine;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<T> Observe<T>(this T self, IScheduler scheduler = null)              => Observable.Return(self, scheduler ?? ImmediateScheduler);                  public static IObservable<T> Observe<T,T2>(this T self,Func<T,IObservable<T2>> secondSelector, IScheduler scheduler = null)              => self.Observe(scheduler).MergeIgnored(secondSelector);                  [Obsolete()]         public static IObservable<T> ReturnObservable<T>(this T self, IScheduler scheduler = null)              => Observable.Return(self, scheduler ?? ImmediateScheduler);          [Obsolete()]         public static IObservable<T> ReturnObservable<T,T2>(this T self,Func<T,IObservable<T2>> secondSelector, IScheduler scheduler = null)              => self.Observe(scheduler).MergeIgnored(secondSelector);     } }using System; using System.Collections.Concurrent; using System.Collections.Immutable; using System.Diagnostics.CodeAnalysis; using System.Reactive.Concurrency; using System.Reactive.Disposables; using System.Reactive.Linq; using System.Reactive.Subjects; using System.Threading.Tasks.Dataflow;  namespace Xpand.Extensions.Reactive.Transform{ 	 	public static partial class Transform{ 		[SuppressMessage("ReSharper", "HeapView.CanAvoidClosure")] 		public static IObservable<T> RoundRobin<T>(this IObservable<T> source){ 			 			return Observable.Create<T>(observer => { 				var cache = new BlockingCollection<T>();  				source.Do(i => cache.TryAdd(i)).Subscribe();  				return () => cache.ToObservable(global::System.Reactive.Concurrency.Scheduler.Default).Do(observer); 			}); 		} 		// public static IObservable<T> RoundRobin<T>(this IObservable<T> source){ 		// 	var subscribers = new BehaviorSubject<ImmutableList<IObserver<T>>>(ImmutableList<IObserver<T>>.Empty); 		// 	ImmutableList<IObserver<T>> latest = ImmutableList<IObserver<T>>.Empty; 		// 	subscribers.Subscribe(l => latest = l); 		// 		// 	var shared = source 		// 		.Select((v, i) => (v, i)) 		// 		.WithLatestFrom(subscribers, (t, s) => (t.v, t.i, s)) 		// 		.Publish() 		// 		.RefCount(); 		// 	return Observable.Create<T>(observer => { 		// 		subscribers.OnNext(latest.Add(observer)); 		// 		var dispose = Disposable.Create(() => subscribers.OnNext(latest.Remove(observer))); 		// 		// 		var sub = shared 		// 			.Where(t => t.i % t.s.Count == t.s.FindIndex(o => o == observer)) 		// 			.Select(t => t.v) 		// 			.Subscribe(observer); 		// 		// 		return new CompositeDisposable(dispose, sub); 		// 	}); 		// } 		public static IObservable<T> Distribute<T>(this IObservable<T> source) { 			var buffer = new BufferBlock<T>(); 			source.Subscribe(buffer.AsObserver());              			return Observable.Create<T>(observer => buffer.LinkTo( 				new ActionBlock<T>(observer.OnNext, new ExecutionDataflowBlockOptions { BoundedCapacity = 1 }) 			)); 		} 	} }using System; using System.Collections.Generic; using System.Collections.Immutable; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<IDictionary<TKey, TSource>> SampleByKey<TSource, TKey>(this IObservable<TSource> source,              Func<TSource, TKey> keySelector, TimeSpan interval, IEqualityComparer<TKey> keyComparer = default)              => source.Scan(ImmutableDictionary.Create<TKey, TSource>(keyComparer),                     (dict, x) => dict.SetItem(keySelector(x), x))                 .Publish(published => Observable.Interval(interval)                     .WithLatestFrom(published, (_, dict) => dict)                     .TakeUntil(published.LastOrDefaultAsync()));     } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Reactive.Subjects; using Xpand.Extensions.Reactive.Combine;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform {         public static IObservable<T> SampleResponsive<T>(             this IObservable<T> source, TimeSpan delay, IScheduler scheduler = null) {             scheduler ??= global::System.Reactive.Concurrency.Scheduler.Default;             return delay == TimeSpan.Zero ? source                 : source.Publish(src => {                     var fire = new Subject<T>();                      var whenCanFire = fire                         .Select(_ => new Unit())                         .Delay(delay, scheduler)                         .StartWith(scheduler, new Unit());                      var subscription = src                         .CombineVeryLatest(whenCanFire, (x, _) => x)                         .Subscribe(fire);                      return fire.Finally(subscription.Dispose);                 });         }     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> SampleSometimes<T>(this IObservable<T> source, TimeSpan sampleTime, IObservable<bool> isSamplingOn)              => source.Sometimes(obs => obs.Sample(sampleTime), isSamplingOn);              } }using System; using System.Reactive.Linq; using System.Threading; using Xpand.Extensions.Reactive.Utility;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform {         public static IObservable<TResult> SelectAndOmit<T, TResult>(this IObservable<T> source,             Func<T,int, IObservable<TResult>> process, SemaphoreSlim semaphoreSlim = null, Action<T> noProcess = null, int maximumConcurrencyCount = 1) {             var dispose = false;             if (semaphoreSlim == null){                 semaphoreSlim = new SemaphoreSlim(maximumConcurrencyCount, maximumConcurrencyCount);                 dispose = true;             }              return source.SelectMany((item, i) => {                     if (semaphoreSlim.Wait(0)){                         return Observable.Return(process(item,i)                             .FinallySafe(() => semaphoreSlim.Release()));                     }                      noProcess?.Invoke(item);                     return Observable.Empty<IObservable<TResult>>();                  })                 .Merge(maximumConcurrencyCount)                 .FinallySafe(() => {                     if (dispose) {                         semaphoreSlim.Dispose();                     }                 });         }          public static IObservable<TResult> SelectAndOmit<T, TResult>(this IObservable<T> source,             Func<T, IObservable<TResult>> process,SemaphoreSlim semaphoreSlim=null, Action<T> noProcess=null, int maximumConcurrencyCount = 1)              => source.SelectAndOmit((item, _) => process(item), semaphoreSlim, noProcess, maximumConcurrencyCount);     } }using System; using System.Collections.Generic; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<TSource> SelectMany<TSource>(this IObservable<IObservable<TSource>> source)              => source.SelectMany(source1 => source1);                  public static IObservable<TSource> SelectMany<TSource>(this IObservable<IEnumerable<TSource>> source)              => source.SelectMany(source1 => source1.ToNowObservable());         public static IObservable<TSource> SelectMany<TSource>(this IObservable<IEnumerable<TSource>> source,int take)              => source.SelectMany(source1 => source1.Take(take).ToNowObservable());         public static IObservable<TSource> SelectMany<TSource>(this IObservable<IAsyncEnumerable<TSource>> source)              => source.SelectMany(source1 => source1.ToObservable());                       } }using System; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using System.Threading.Tasks;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<T2> SelectManySequential<T1, T2>(this IObservable<T1> source, Func<T1, IObservable<T2>> selector)              => source.Select(x => Observable.Defer(() => selector(x))).Concat();         public static IObservable<T2> SelectManySequential<T1, T2>(this IObservable<T1> source, Func<T1, Task<T2>> selector)              => source.SelectManySequential(arg => selector(arg).ToObservable());                  public static IObservable<T2> SelectManySequential<T1, T2>(this IObservable<T1> source, Func<T1,int, IObservable<T2>> selector)              => source.Select((x,i) => Observable.Defer(() => selector(x,i))).Concat();     } }using System; using System.Collections.Concurrent; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Subjects; using System.Threading;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         /// <summary>         /// Projects each element of the source observable sequence to a subsequence,         /// and merges the resulting subsequences into one observable sequence.         /// The merged sequence completes when all the projected subsequences complete         /// on their own. Unlike the SelectMany operator, the subsequences are not         /// unsubscribed when an error occurs.         /// </summary>         public static IObservable<TResult> SelectManyUntilCompletion<TSource, TResult>(this IObservable<TSource> source,             Func<TSource, CancellationToken, IObservable<TResult>> selector)              => Observable.Defer(() => {                 var cts = new CancellationTokenSource();                 var errors = new ConcurrentQueue<Exception>();                 var stopSignal = new Subject<Unit>();                 var stopSignalSynchronized = Observer.Synchronize(stopSignal);                  IObservable<T> HandleErrorReturnEmpty<T>(Exception ex) {                     cts.Cancel();                     bool ignoreError = ex is OperationCanceledException                                        && cts.IsCancellationRequested;                     if (!ignoreError) errors.Enqueue(ex);                     stopSignalSynchronized.OnNext(default);                     return Observable.Empty<T>();                 }                  return source                     .TakeUntil(stopSignal)                     .Catch((Exception ex) => HandleErrorReturnEmpty<TSource>(ex))                     .SelectMany(item => {                         if (!errors.IsEmpty) return Observable.Empty<TResult>();                         IObservable<TResult> projected;                         try {                             projected = selector(item, cts.Token);                         }                         catch (Exception ex) {                             return HandleErrorReturnEmpty<TResult>(ex);                         }                          return projected                             .Catch((Exception ex) => HandleErrorReturnEmpty<TResult>(ex));                     })                     .Concat(Observable.Defer(() => {                         cts.Dispose();                         if (!errors.IsEmpty) throw new AggregateException(errors);                         return Observable.Empty<TResult>();                     }));             });     } }using System; using System.Collections.Generic; using System.Linq; using System.Reactive; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<IReadOnlyList<Timestamped<T>>> SlidingWindow<T>(this IObservable<Timestamped<T>> source, TimeSpan length)              => source.Scan(new LinkedList<Timestamped<T>>(), (list, newSample) => {                     list.AddLast(newSample);                     var oldest = newSample.Timestamp - length;                     while (list.Count > 0 && list.First.Value.Timestamp < oldest)                         list.RemoveFirst();                      return list;                 }).Select(l => l.ToList().AsReadOnly());     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> Sometimes<T>(this IObservable<T> source,Func<IObservable<T>,IObservable<T>> target, IObservable<bool> isOn)             => source.Publish(obs => target(obs).Publish(sampled => isOn.Select(b => b ? sampled : obs).Switch()));     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<T> StepInterval<T>(this IObservable<T> source, TimeSpan minDelay, IScheduler scheduler = null)              => source.Select(x => Observable.Empty<T>()                 .Delay(minDelay, scheduler??=DefaultScheduler.Instance)                 .StartWith(x)             ).Concat();     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<decimal> LiveSum<T>(this IObservable<T> source, Func<T, decimal> func)             => source.Scan(0m, (a, b) => a + func(b));          public static IObservable<decimal> LiveSum(this IObservable<decimal> source)              => source.Scan(0m, (a, b) => a + b);          public static IObservable<double> LiveSum(this IObservable<double> source)              => source.Scan(0d, (a, b) => a + b);          public static IObservable<int> LiveSum<T>(this IObservable<T> source, Func<T, int> func)              => source.Scan(0, (a, b) => a + func(b));          public static IObservable<double> LiveSum<T>(this IObservable<T> source, Func<T, double> func)              => source.Scan(0D, (a, b) => a + func(b));                       } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<TSource> SwitchFirst<TSource>(this IObservable<IObservable<TSource>> source)              => Observable.Create<TSource>(o => {                     bool free = true;                     return source.Where(_ => free).Do(_ => free = false)                         .Select(el => el.Finally(() => free = true)).Switch()                         .Subscribe(o);                 }             );     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> Throw<T>(this Exception exception)             => Observable.Throw<T>(exception);     } }using System; using System.Reactive.Linq; using System.Runtime.CompilerServices; using Xpand.Extensions.Reactive.Combine;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> ThrowIfEmpty<T>(this IObservable<T> source,[CallerMemberName]string caller="")             => source.SwitchIfEmpty(Observable.Defer(() => Observable.Throw<T>(new InvalidOperationException($"source is empty {caller}"))));     } }using System; using System.Reactive; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Filter;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<TValue> To<TSource,TValue>(this IObservable<TSource> source,TValue value)              => source.Select(_ => value);          public static IObservable<T> To<T>(this IObservable<object> source)              => source.Select(o =>o is T arg? arg: default);         public static IObservable<T> To<T>(this IObservable<Unit> source)              => source.Select(_ => default(T));                   public static IObservable<T> To<T,TResult>(this IObservable<TResult> source)              => source.Select(_ => default(T)).WhenNotDefault();     } }using System; using System.Collections.Generic; using System.Linq; using System.Reactive.Linq; using System.Text.Json; using System.Text.Json.Nodes;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<object> ToObject<T>(this IObservable<T> source)              => source.Select(_ => default(object));                  public static IObservable<TResult> ToObject<TResult>(this IObservable<JsonNode> source)              => source.Select(jToken => jToken.Deserialize<TResult>());                  public static IEnumerable<object> ToObject<T>(this IEnumerable<T> source)              => source.Select(_ => default(object));     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Threading;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<TSource> ToObservable<TSource>(this IEnumerable<TSource> source, SynchronizationContext context)             => source.ToObservable().ObserveOn(context);         public static IObservable<TSource> ToNowObservable<TSource>(this IEnumerable<TSource> source)             => source.ToObservable(ImmediateScheduler);                  public static IObservable<TSource> Consume<TSource>(this BlockingCollection<TSource> source)             => source.GetConsumingEnumerable().ToObservable(Scheduler.Default);     } }using System; using System.Reactive.Threading.Tasks; using System.Runtime.CompilerServices;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static ConfiguredTaskAwaitable<T> ToTaskWithoutConfigureAwait<T>(this IObservable<T> source) => source.ToTask().ConfigureAwait(false);     } }using System; using System.Collections.Generic; using System.Linq; using System.Reactive; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<Unit> ToUnit<T>(this IObservable<T> source) => source.Select(_ => Unit.Default);         public static IEnumerable<Unit> ToUnit<T>(this IEnumerable<T> source) => source.Select(_ => Unit.Default);              } }using System; using System.Reactive; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{ 	    public static IObservable<T> TransformPattern<T>(this IObservable<EventPattern<EventArgs>> source)  		    => source.Select(pattern => pattern.Sender).Cast<T>();  	    public static IObservable<(T sender, TEventArgs e)> TransformPattern<TEventArgs, T>(             this IObservable<EventPattern<TEventArgs>> source) where TEventArgs : EventArgs  		    => source.Select(pattern => ((T) pattern.Sender, pattern.EventArgs));     } }using System; using System.Linq; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using Xpand.Extensions.TaskExtensions;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static T Wait<T>(this IObservable<T> source, TimeSpan timeSpan)              => source.ToTask().Timeout(timeSpan).Result;         public static IObservable<T> WaitUntilInactive<T>(this IObservable<T> source, TimeSpan timeSpan,int count =1,IScheduler scheduler=null)              =>timeSpan==TimeSpan.Zero?source: source.BufferUntilInactive(timeSpan,scheduler:scheduler).SelectMany(list => list.TakeLast(count).ToArray());                  public static IObservable<T> WaitUntilInactive<T>(this IObservable<T> source, int seconds, int count = 1,IScheduler scheduler=null)             => source.WaitUntilInactive(TimeSpan.FromSeconds(seconds), count,scheduler);              } }using System; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.Reactive.Filter;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         public static IObservable<T> When<T>(this object source)             => source.As<T>().Observe().WhenNotDefault();         public static IObservable<T> When<T>(this T source,string typeName)             => source.As(typeName).Observe().WhenNotDefault();     } }using System; using System.ComponentModel; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform{     public static partial class Transform{         public static IObservable<TDisposable> Disposed<TDisposable>(this IObservable<TDisposable> source) where TDisposable:IComponent              => source.SelectMany(item => item.WhenDisposed());          public static IObservable<TDisposable> WhenDisposed<TDisposable>(this TDisposable source) where TDisposable : IComponent              => source.WhenEvent(nameof(IComponent.Disposed)).To(source);     } }using System; using System.Collections.Concurrent; using System.Linq; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Reflection; using Fasterflect; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.TypeExtensions; using Type = System.Type;  namespace Xpand.Extensions.Reactive.Transform {     public static partial class Transform {         private static readonly ConcurrentDictionary<(Type type, string eventName),(EventInfo info,MethodInfo add,MethodInfo remove)> Events = new();         public static readonly IScheduler ImmediateScheduler=Scheduler.Immediate;          public static IObservable<EventPattern<object>> WhenEvent(this object source,params string[] eventNames)              => eventNames.ToNowObservable().SelectMany(source.FromEventPattern<EventArgs>)                 .Select(pattern => new EventPattern<object>(pattern.Sender, pattern.EventArgs));         // private static IObservable<EventPattern<TArgs>> FromEventHandler<TArgs>(this object source, EventHandler eventHandler) {         //     return Observable.FromEventPattern(         //             (sender, args) => eventHandler(sender, args),         //             (sender, args) => eventHandler.Remove(sender, args))         //         .Select(pattern => new EventPattern<TArgs>(pattern.Sender, (TArgs)pattern.EventArgs));         // }         private static IObservable<EventPattern<TArgs>> FromEventPattern<TArgs>(this object source, string eventName) {             var eventInfo = source.EventInfo(eventName);                          if ((eventInfo.info.EventHandlerType?.IsGenericType ?? false)&&eventInfo.info.EventHandlerType.GenericTypeArguments.First()==typeof(TArgs)) {                 return Observable.FromEventPattern<TArgs>(                         handler => eventInfo.add.Invoke(source, new object[] { handler }),                         handler => eventInfo.remove.Invoke(source, new object[] { handler }))                     .Select(pattern => new EventPattern<TArgs>(pattern.Sender, pattern.EventArgs));             }              if (eventInfo.add.IsPublic&&!eventInfo.add.IsStatic) {                 return Observable.FromEventPattern<TArgs>(source, eventName);                 }              if (eventInfo.info.EventHandlerType == typeof(EventHandler)) {                 return Observable.FromEventPattern(                         handler => eventInfo.add.Invoke(source, new object[] { handler }),                         handler => eventInfo.remove.Invoke(source, new object[] { handler }))                     .Select(pattern => new EventPattern<TArgs>(pattern.Sender, (TArgs)pattern.EventArgs));                 }             return Observable.FromEventPattern<TArgs>(                     handler => eventInfo.add.Invoke(source, new object[] { handler }),                     handler => eventInfo.remove.Invoke(source, new object[] { handler }))                 .Select(pattern => new EventPattern<TArgs>(pattern.Sender, pattern.EventArgs));         }                  private static (EventInfo info,MethodInfo add,MethodInfo remove) EventInfo(this object source,string eventName)              => Events.GetOrAdd((source as Type ?? source.GetType(), eventName), t => {                 var eventInfo = (EventInfo)t.type.Members(MemberTypes.Event,Flags.AllMembers).OrderByDescending(info => info.IsPublic())                     .First(info => info.Name == eventName || info.Name.EndsWith(".".JoinString(eventName)));                 return (eventInfo, eventInfo.AddMethod,eventInfo.RemoveMethod);             });          public static IObservable<(TEventArgs args, TSource source)> WhenEvent<TSource,TEventArgs>(this object source, params string[] eventNames)             => eventNames.ToNowObservable().SelectMany(eventName => source.FromEventPattern<TEventArgs>(eventName).Select(pattern => (pattern.EventArgs,(TSource)source)));                  public static IObservable<TEventArgs> WhenEvent<TEventArgs>(this object source, params string[] eventNames)              => eventNames.ToNowObservable().SelectMany(eventName =>                 source.FromEventPattern<TEventArgs>(eventName).Select(pattern => pattern.EventArgs));     } }using System; using System.ComponentModel; using System.Linq; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform.Collections {     public static class Collections {         public static IObservable<ListChangedEventArgs> WhenListChanged<T>(this T source,params ListChangedType[] changedTypes) where T:IBindingList             => source.WhenEvent<ListChangedEventArgs>(nameof(IBindingList.ListChanged))                 .Where(args =>!changedTypes.Any()|| changedTypes.Contains(args.ListChangedType));     } }using System; using System.Net.Http; using System.Reactive.Linq; using System.Reactive.Subjects; using System.Reflection; using Xpand.Extensions.Reactive.Transform.System.Net;  namespace Xpand.Extensions.Reactive.Transform.System {     public static class AppDomainExtensions {         static readonly IConnectableObservable<AppDomain> AppdomainOneEmission;         static AppDomainExtensions() {             AppdomainOneEmission = AppDomain.CurrentDomain.Observe().BufferUntilSubscribed();             AppdomainOneEmission.Connect();         }         public static IObservable<Assembly> WhenAssemblyLoad(this AppDomain appDomain)              => appDomain.WhenEvent<AssemblyLoadEventArgs>(nameof(AppDomain.AssemblyLoad)).Select(eventArgs => eventArgs.LoadedAssembly);          public static IObservable<ResolveEventArgs> WhenAssemblyResolve(this AppDomain appDomain) 	        => appDomain.WhenEvent<ResolveEventArgs>(nameof(AppDomain.AssemblyResolve));          public static IObservable<AppDomain> ExecuteOnce(this AppDomain appDomain)              => AppdomainOneEmission.AsObservable();                  public static HttpClient HttpClient(this AppDomain domain) => NetworkExtensions.HttpClient;     } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Threading; using Xpand.Extensions.Reactive.Utility;  namespace Xpand.Extensions.Reactive.Transform.System {     public static class TimeSpanExtensions {         public static IObservable<Unit> After(this TimeSpan timeSpan, Action execute,IScheduler scheduler=null)             => Unit.Default.Observe().Delay(timeSpan,scheduler??Scheduler.Default)                 .Do(execute).ToUnit();         public static IObservable<Unit> After(this TimeSpan timeSpan, Action execute,SynchronizationContext context)             => Unit.Default.Observe().Delay(timeSpan,context.Scheduler()).Do(execute).ToUnit();         public static IObservable<long> Timer(this TimeSpan dueTime,IScheduler scheduler=null)             => Observable.Timer(dueTime,scheduler??Scheduler.Default);                  public static IObservable<long> Interval(this TimeSpan dueTime)             => Observable.Interval(dueTime);     } }using System; using System.Diagnostics; using System.Reactive; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Transform.System.Diagnostics{     public static class ProcessEx{         public static IObservable<float> PrivateBytes(this Process process,IObservable<Unit> signal)              => Observable.Using(() => new PerformanceCounter("Process", "Private Bytes", process.ProcessName),counter => signal                 .Select(_ => counter.NextValue()).Select(sample => sample));          public static bool StartWithEvents(this Process process,bool outputDataReceived=true,bool outputErrorReceived=true,bool enableRaisingEvents=true,bool createNoWindow=true){             process.StartInfo.RedirectStandardOutput = outputDataReceived;             process.StartInfo.RedirectStandardError = outputErrorReceived;             if (outputDataReceived||outputErrorReceived){                 process.StartInfo.UseShellExecute = false;                 process.StartInfo.CreateNoWindow = createNoWindow;             }             var start = process.Start();             process.EnableRaisingEvents = enableRaisingEvents;             if (start&&outputDataReceived){                 process.BeginOutputReadLine();                 }             if (start&&outputErrorReceived){                 process.BeginErrorReadLine();                 }             return start;         }          public static IObservable<string> WhenOutputDataReceived(this Process process)             => process.WhenEvent<DataReceivedEventArgs>(nameof(Process.OutputDataReceived)).Select(pattern => pattern.Data);          public static IObservable<string> WhenErrorDataReceived(this Process process)             => process.WhenEvent<DataReceivedEventArgs>(nameof(Process.ErrorDataReceived)).Select(pattern => pattern.Data);          public static IObservable<Process> WhenExited(this Process process)              => process.WhenEvent(nameof(Process.Exited)).To(process);     } }using System; using System.IO; using System.Linq; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using System.Text.RegularExpressions; using Xpand.Extensions.FileExtensions; using Xpand.Extensions.Reactive.ErrorHandling; using Xpand.Extensions.StreamExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.Reactive.Transform.System.IO {     public static class DirectoryInfoExtensions {         public static IObservable<FileInfo> WhenFileCreated(this DirectoryInfo directoryInfo,string pattern=null) {             var infoClone = new DirectoryInfo(directoryInfo.FullName);             if (!infoClone.Exists) {                 directoryInfo = directoryInfo.ParentExists();                 return Observable.Using(() => new FileSystemWatcher(directoryInfo.FullName) { EnableRaisingEvents = true,IncludeSubdirectories = true},                      watcher => watcher.WhenEvent<FileSystemEventArgs>(nameof(FileSystemWatcher.Created))                         .Where(e => new[]{WatcherChangeTypes.Created,WatcherChangeTypes.Renamed}.Contains(e.ChangeType))                         .Publish(source =>source.Where(e => File.Exists(e.FullPath))                             .Where(e =>Path.GetDirectoryName(e.FullPath)==infoClone.FullName&& (pattern==null||Regex.IsMatch(Path.GetFileName(e.FullPath),                                 pattern.WildCardToRegular())) )) )                     .Select(e => new FileInfo(e.FullPath));             }             return Observable.Using(() => new FileSystemWatcher(directoryInfo.FullName, pattern??"*"){ EnableRaisingEvents = true }, watcher => watcher                 .WhenEvent<FileSystemEventArgs>(nameof(FileSystemWatcher.Created))                 .Select(args => new FileInfo(args.FullPath)));         }          public static IObservable<FileInfo> WhenCreated(this FileInfo fileInfo)              => fileInfo.Exists?fileInfo.Observe():Observable.Defer(() => fileInfo.Directory.WhenFileCreated(fileInfo.Name).Take(1));                  public static IObservable<FileInfo> WhenChanged(this FileInfo fileInfo)              => fileInfo.When(nameof(FileSystemWatcher.Changed));          private static IObservable<FileInfo> When(this FileInfo fileInfo,string eventName)              => Observable.Using(() => new FileSystemWatcher(fileInfo.DirectoryName!,fileInfo.Name){ EnableRaisingEvents = true }, watcher => watcher                 .WhenEvent<FileSystemEventArgs>(eventName)                 .Select(args => new FileInfo(args.FullPath)));          public static IObservable<FileInfo> WhenDeleted(this FileInfo fileInfo)              => fileInfo.When(nameof(FileSystemWatcher.Deleted));                  public static IObservable<FileInfo> WhenRenamed(this FileInfo fileInfo)              => fileInfo.When(nameof(FileSystemWatcher.Renamed));          public static IObservable<string> WhenFileReadAsString(this FileInfo fileInfo,             FileMode fileMode = FileMode.OpenOrCreate, FileAccess fileAccess = FileAccess.Read, FileShare fileShare = FileShare.Read,int retry=5)              => fileInfo.WhenFileRead(stream => stream.ReadToEndAsStringAsync().ToObservable(),fileMode,fileAccess,fileShare,retry);                  public static IObservable<byte[]> WhenFileReadAsBytes(this FileInfo fileInfo,             FileMode fileMode = FileMode.OpenOrCreate, FileAccess fileAccess = FileAccess.Read, FileShare fileShare = FileShare.Read,int retry=5)              => fileInfo.WhenFileRead(stream => stream.Bytes().Observe(),fileMode,fileAccess,fileShare,retry);          public static IObservable<T> WhenFileRead<T>(this FileInfo fileInfo,Func<FileStream,IObservable<T>> selector,             FileMode fileMode = FileMode.OpenOrCreate, FileAccess fileAccess = FileAccess.Read, FileShare fileShare = FileShare.Read,int retry=5)              => Observable.Defer(async () => {                 if (fileMode==FileMode.OpenOrCreate && !Directory.Exists(fileInfo.DirectoryName)) {                     Directory.CreateDirectory(fileInfo.DirectoryName!);                 }                 await using var fileStream = File.Open(fileInfo.FullName, fileMode, fileAccess, fileShare);                 return (await selector(fileStream)).Observe();             }).RetryWithBackoff(retry);          public static IObservable<DirectoryInfo> WhenDirectory(this DirectoryInfo directory,bool create=true)              => Observable.Defer(() => {                 if (!directory.Exists){                     if (create) {                         Directory.CreateDirectory(directory.FullName);                         return directory.Observe();                     }                     return Observable.Empty<DirectoryInfo>();                 }                 return directory.Observe();             });          public static IObservable<FileInfo> OpenFile(this FileInfo fileInfo,FileMode fileMode=FileMode.Open,FileAccess fileAccess=FileAccess.Read,FileShare fileShare=FileShare.Read)              => Observable.Defer(() => Observable.Using(() => File.Open(fileInfo.FullName, fileMode, fileAccess, fileShare),                     _ => {                         _.Dispose();                         return fileInfo.Observe();                     }))                 .RetryWithBackoff(strategy:_ => TimeSpan.FromMilliseconds(200));      } }using System; using System.Linq; using System.Net; using System.Net.NetworkInformation; using System.Net.Sockets; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using Xpand.Extensions.Reactive.ErrorHandling; using Xpand.Extensions.Reactive.Utility;  namespace Xpand.Extensions.Reactive.Transform.System.Net{     public static class SystemNetTransform{         private static readonly IObservable<IPAddress> LocalHost;          static SystemNetTransform() => LocalHost = Dns.GetHostAddressesAsync("localhost").ToObservable().SelectMany().LastAsync().ReplayConnect(1);          public static IObservable<IPEndPoint> Listening(this IObservable<IPEndPoint> source,bool repeatWhenOffline=true,TimeSpan? timeSpan=null)              => LocalHost.CombineLatest(source, (localHost, endPoint) => endPoint.Address.Equals(localHost)                      ? endPoint.LocalHostListening(repeatWhenOffline,timeSpan ??= TimeSpan.FromMilliseconds(500)) : endPoint.Ping()).Merge();          private static IObservable<IPEndPoint> LocalHostListening(this IPEndPoint endPoint,bool repeatWhenOffline, TimeSpan timeSpan) {             var inUsed = Observable.While(() => !endPoint.Listening(), Observable.Empty<IPEndPoint>().Delay(timeSpan))                 .Concat(endPoint.Observe());             var notInUse = Observable.While(endPoint.Listening, Observable.Empty<IPEndPoint>().Delay(timeSpan))                 .Concat(endPoint.Observe());             return repeatWhenOffline ? inUsed.RepeatWhen(_ => _.SelectMany(_ => notInUse)) : inUsed;         }          public static IObservable<(IPAddress address,int port)> Ping(this IPAddress address, int port)              => Observable.Using(() => new TcpClient(), client => {                 var result = client.BeginConnect(address, port, null, null);                 result.AsyncWaitHandle.WaitOne(TimeSpan.FromMilliseconds(1500));                 client.EndConnect(result);                 return (address, port).Observe();             }).CompleteOnError();          public static IObservable<IPEndPoint> Ping(this IPEndPoint endPoint)              => endPoint.Address.Ping(endPoint.Port).To(endPoint);          public static bool Listening(this IPEndPoint endPoint) => IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners().Contains(endPoint);         public static bool IsFree(this IPEndPoint endPoint) => !endPoint.Listening();     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using System.Net; using System.Net.Http; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Subjects; using System.Reactive.Threading.Tasks; using System.Runtime.CompilerServices; using System.Text; using System.Text.Json; using System.Text.Json.Nodes; using Fasterflect; using Xpand.Extensions.BytesExtensions; using Xpand.Extensions.JsonExtensions; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.Network; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.Reactive.Conditional; using Xpand.Extensions.Reactive.Transform.System.Text.Json; using Xpand.Extensions.Reactive.Utility; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.Reactive.Transform.System.Net {     public static class NetworkExtensions {         public static readonly HttpStatusCode[] WorthRetryingCodes ={             HttpStatusCode.TooManyRequests, IpBanned, WafLimit, HttpStatusCode.BadGateway, HttpStatusCode.Forbidden,             HttpStatusCode.Unauthorized, HttpStatusCode.RequestTimeout,HttpStatusCode.InternalServerError,HttpStatusCode.ServiceUnavailable,              HttpStatusCode.GatewayTimeout,          };         public const HttpStatusCode TooManyRequests = HttpStatusCode.TooManyRequests;         public const HttpStatusCode IpBanned = (HttpStatusCode)418;         public const HttpStatusCode WafLimit = (HttpStatusCode)403;                  private static readonly Subject<(HttpResponseMessage message, object instance)> ResponseSubject = new();         private static readonly Subject<(HttpResponseMessage message,object instance)> ObjectSentSubject = new();         public static IObservable<(HttpResponseMessage message, object instance)> Object => ObjectSentSubject.AsObservable();         public static IObservable<(HttpResponseMessage message, object instance)> Responded => ResponseSubject.AsObservable();          public static bool WorthRetry(this HttpResponseMessage message)              => WorthRetryingCodes.Contains(message.StatusCode);          public static IObservable<TimeSpan> RetryAfter(this HttpResponseException e,Func<TimeSpan,IObservable<Unit>> selector=null) {             IObservable<TimeSpan> Retry(TimeSpan retryAfter1) => Observable.If(() => retryAfter1>TimeSpan.Zero,retryAfter1.Timer())                 .DefaultIfEmpty().To(retryAfter1);             return e.HttpResponseMessage.RetryAfter().Observe()                 .SelectMany(retryAfter => selector?.Invoke(retryAfter).To<TimeSpan>() ?? Retry(retryAfter));         }          public static HttpClient HttpClient { get; set; }=new();                  public static TimeSpan RetryAfter(this HttpResponseMessage responseMessage){             var dateTime = !responseMessage.Headers.Contains("Date") ? DateTime.Now                 : DateTimeOffset.Parse(responseMessage.Headers.GetValues("Date").First()).LocalDateTime;             var retryAfterDelta = responseMessage.Headers.RetryAfter?.Delta;             DateTime? delay = null;             if (retryAfterDelta.HasValue){                 delay = dateTime.Add(retryAfterDelta.Value);                 }             return (responseMessage.StatusCode switch{                 WafLimit =>delay?? dateTime.AddMinutes(5),                 IpBanned => delay??dateTime.AddMinutes(20),                 TooManyRequests => delay??dateTime.AddSeconds(61),                 _ =>responseMessage.WorthRetry()? (delay??dateTime.AddSeconds(61)): DateTime.Now.AddSeconds(-1)             }).Subtract(DateTime.Now);         }          public static T Sign<T>(this T requestMessage,string key,string secret) where T:HttpRequestMessage{             if (key != null) {                 var toSing = requestMessage.RequestUri!.PathAndQuery;                 if (requestMessage.Method != HttpMethod.Get) {                     toSing = requestMessage.RequestUri.AbsolutePath.JoinString("?",requestMessage.Content!.ReadAsStringAsync().Result);                 }                 var sign = secret.Bytes().CryptoSign(toSing).Replace("-", "").ToLower();                 requestMessage.Headers.Add("Signature", sign);                 requestMessage.Headers.Add("APIKEY", key);             }             return requestMessage;         }          public static IObservable<T> Send<T>(this HttpMethod httpMethod, string requestUrl,             ConcurrentDictionary<object, IConnectableObservable<object>> cache, T obj, string key = null,             string secret = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null, TimeSpan? pollInterval = null)             where T : class ,new()             => httpMethod.Observe()                 .Cache(cache, requestUrl, method => Observable.FromAsync(() => HttpClient.SendAsync(method.NewHttpRequestMessage( requestUrl,obj, key, secret)))                         .Do(message => ResponseSubject.OnNext((message, obj))),pollInterval).                 Send(obj,deserializeResponse);          public static IObservable<T> Send<T>(this HttpClient client, HttpMethod httpMethod, string requestUrl,             object obj = null, string key = null, string secret = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null) where T : class,new()             =>  Observable.FromAsync(() => client.SendAsync(httpMethod.NewHttpRequestMessage(requestUrl,obj, key, secret)))                 .Do(message => ResponseSubject.OnNext((message, obj)))                 .WhenResponseObject(obj??typeof(T).CreateInstance(),httpResponseMessage => deserializeResponse?.Invoke(httpResponseMessage));          private static readonly JsonDocument EmptyArrayDoc = JsonDocument.Parse("[]");          public static JsonDocument EmptyArrayJsonDocument(this HttpClient client)             => EmptyArrayDoc;                  public static IObservable<T> Send<T>(this HttpClient client, HttpRequestMessage httpRequestMessage) where T:class,new()             => client.Send(httpRequestMessage, default(Func<HttpResponseMessage, IObservable<T>>));          public static IObservable<T> Send<T>(this HttpClient client, HttpRequestMessage httpRequestMessage, Func<HttpResponseMessage, IObservable<T>> deserializeResponse) where T:class,new()             => Observable.FromAsync(() => client.SendAsync(httpRequestMessage, HttpCompletionOption.ResponseHeadersRead))                 .Do(message => ResponseSubject.OnNext((message, null)))                 .WhenResponseObject(CreateInstance<T>(), deserializeResponse.Invoke);          private static object CreateInstance<T>() => typeof(T) == typeof(string) ? "" : typeof(T).CreateInstance();          public static IObservable<T> SendRequest<T>(this HttpClient client, HttpRequestMessage httpRequestMessage,              T obj = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null, [CallerMemberName] string caller = "") where T : class,new()             => client.SendRequest(httpRequestMessage,null,obj,deserializeResponse,caller);                  public static IObservable<T> SendRequest<T>(this HttpClient client, HttpRequestMessage httpRequestMessage,Action<HttpResponseMessage> onResponse,              T obj = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null, [CallerMemberName] string caller = "") where T : class,new()             => client.Request( httpRequestMessage, onResponse, obj)                 .SendRequest(obj??typeof(T).CreateInstance(), deserializeResponse);          private static IObservable<HttpResponseMessage> Request<T>(this HttpClient client, HttpRequestMessage httpRequestMessage, Action<HttpResponseMessage> onResponse=null, T obj=default) where T : class,new()              => client.SendAsync(httpRequestMessage,HttpCompletionOption.ResponseHeadersRead)                 .ToObservable().EnsureSuccessStatusCode()                 .Do(message => onResponse?.Invoke(message))                 .Do(message => ResponseSubject.OnNext((message, obj)));          public static IObservable<(HttpResponseMessage message,JsonObject[] objects)> WhenResponseObject(this HttpClient client, HttpRequestMessage httpRequestMessage)              => client.WhenResponse(httpRequestMessage).Select(t => (t.result.Message,t.response.DeserializeJsonNode().ToJsonObjects().ToArray()));                  static IObservable<(byte[] response, ResponseResult result)> WhenResponse(this HttpClient client, HttpRequestMessage httpRequestMessage)              => client.Request<ResponseResult>(httpRequestMessage).WhenResponseObject(null, httpResponseMessage => new ResponseResult(httpResponseMessage).Observe())                 .SelectMany(result => Observable.FromAsync(() => result.Message.Content.ReadAsByteArrayAsync()).ObserveOnDefault().Pair(result));          // public static IObservable<HttpResponseMessage> EnsureSuccessStatusCode1(this IObservable<HttpResponseMessage> source)         //     => source.If(message => !message.IsSuccessStatusCode,)         public static IObservable<HttpResponseMessage> EnsureSuccessStatusCode(this IObservable<HttpResponseMessage> source)              => source.If(message => !message.IsSuccessStatusCode, message => Observable.If(message.IsJsonResponse,message.WhenJsonDocument())                 .Merge(Observable.If(() => !message.IsJsonResponse(),Observable.FromAsync(() => message.Content.ReadAsStringAsync())                     .SelectMany(content => Observable.Throw<(HttpResponseMessage[] objects, JsonDocument document)>(new HttpResponseException($"{message.StatusCode}, {message.ReasonPhrase}, {content}", message)))))                 .SelectMany(t => t.objects),message => message.Observe());          private static IObservable<(HttpResponseMessage[] objects, JsonDocument document)> WhenJsonDocument(this HttpResponseMessage message)              => Observable.FromAsync(() => message.Content.ReadAsStreamAsync()).WhenJsonDocument(document =>                     Observable.Throw<HttpResponseMessage>(new HttpResponseException(document.RootElement.ToString(), message)))                 .Catch<(HttpResponseMessage[] objects, JsonDocument document),Exception>(exception                      => Observable.Throw<(HttpResponseMessage[] objects, JsonDocument document)>(new HttpResponseException($"{message.StatusCode}, {message.ReasonPhrase}, {exception}", message)));           public static IObservable<(T[] objects, JsonDocument document)> WhenResponseDocument<T>(this HttpClient client,             HttpRequestMessage httpRequestMessage, Func<(JsonDocument document, HttpResponseMessage message), IObservable<T>> selector)              => client.Request<ResponseResult>(httpRequestMessage)                 .SelectMany(message => message.Content.ReadAsStreamAsync().ToObservable()                     .SelectMany(stream => stream.WhenJsonDocument(document => selector((document, message)))));          public static IObservable<(JsonDocument document, HttpResponseMessage message)> WhenResponseDocument(             this HttpClient client, HttpRequestMessage httpRequestMessage)             => client.Request<ResponseResult>(httpRequestMessage)                 .SelectMany(message => message.Content.ReadAsStreamAsync().ToObservable()                     .SelectMany(stream => stream.WhenJsonDocument()                         .Finally(() => { }).Select(document => (document, message))));                           public static IObservable<(T[] objects, JsonDocument document)> WhenResponseDocument<T>(this HttpClient client,             string url, Func<JsonDocument, IObservable<T>> selector)              => client.GetStreamAsync(url).ToObservable()                 .SelectMany(stream => stream.WhenJsonDocument(selector));                  public static IObservable<T> SelectMany<T>(this IObservable<(T[] objects, JsonDocument document)> source) => source.SelectMany(t => t.objects);                  public static IObservable<T> SelectElement<T>(this IObservable<(JsonDocument document,HttpResponseMessage message)> source,Func<JsonElement,IObservable<T>> selector)              => source.SelectDocument(document => selector(document.RootElement));          public static IObservable<JsonDocument> SelectDocument(this IObservable<(JsonDocument document, HttpResponseMessage message)> source)             => source.Select(t => t.document);                  public static IObservable<string> SelectString(this IObservable<(JsonDocument document, HttpResponseMessage message)> source)             => source.SelectDocument(document => document.RootElement.GetString().Observe());                  public static IObservable<T> SelectDocument<T>(this IObservable<(JsonDocument document, HttpResponseMessage message)> source,Func<JsonDocument,IObservable<T>> selector)             => source.SelectMany(t => selector(t.document).FinallySafe(() => t.document.Dispose()));         public static IObservable<JsonElement> SelectMany(this IObservable<(JsonDocument document,HttpResponseMessage message)> source,bool dispose=true)              => source.SelectMany(t => t.document.SelectMany(dispose));         private static IObservable<T> WhenResponseObject<T>(this IObservable<HttpResponseMessage> source,             object obj, Func<HttpResponseMessage,IObservable<T>> deserializeResponse)              => source.SelectMany(responseMessage => deserializeResponse.DeserializeResponse()(responseMessage)                 .DoOnComplete(() => ObjectSentSubject.OnNext((responseMessage,  obj))));          record ResponseResult {             public HttpResponseMessage Message{ get; }                          public ResponseResult(HttpResponseMessage message)                  => Message = message;              public ResponseResult() {             }         }         public static IObservable<T> SendRequest<T>(this HttpClient client, HttpMethod httpMethod,string url,              T obj = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null) where T : class,new()             => client.SendRequest(new HttpRequestMessage(httpMethod, url),obj,deserializeResponse);                  public static IObservable<T> Send<T>(this HttpMethod httpMethod, string requestUrl, string key = null,             string secret = null, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null) where T : class,new()              => HttpClient.Send(httpMethod, requestUrl,null,key,secret,deserializeResponse);                  public static IObservable<T> Send<T>(this HttpMethod httpMethod, string requestUrl, Func<HttpResponseMessage, IObservable<T>> deserializeResponse = null         , string key = null, string secret = null) where T : class,new()              => HttpClient.Send(httpMethod, requestUrl,null,key,secret,deserializeResponse);          private static IObservable<T> SendRequest<T>(this IObservable<HttpResponseMessage> source,             object obj, Func<HttpResponseMessage, IObservable<T>> deserializeResponse) where T : class, new()              => source.WhenResponseObject(obj, httpResponseMessage =>                     deserializeResponse(httpResponseMessage) ?? Deserialize<T>(obj)(httpResponseMessage));          private static IObservable<T> Send<T>(this IObservable<HttpResponseMessage> source,             object obj, Func<HttpResponseMessage, IObservable<T>> deserializeResponse) where T:class,new()              => source.WhenResponseObject(obj, httpResponseMessage =>                 deserializeResponse?.Invoke(httpResponseMessage) ?? Deserialize<T>(obj)(httpResponseMessage));          private static Func<HttpResponseMessage, IObservable<T>> Deserialize<T>(object obj) where T:class,new()              => message => message.DeserializeJson<T>(obj?.GetType());         private static IObservable<T> DeserializeJson<T>(this HttpResponseMessage responseMessage,Type returnType) where T:class,new()              => returnType != null ? responseMessage.DeserializeJson(returnType).ToObservable().Cast<T>()                     .If(obj => obj?.GetType().IsArray ?? false, arg => arg.Cast<IEnumerable<T>>().ToNowObservable(),                         arg => arg.Observe()).Select(arg => arg) :                 responseMessage.DeserializeJson<T>().ToObservable(Transform.ImmediateScheduler).Select(arg => arg);           private static Func<HttpResponseMessage, IObservable<T>> DeserializeResponse<T>(this Func<HttpResponseMessage, IObservable<T>> deserializeResponse)              => deserializeResponse ?? (message =>  message.DeserializeJson<T>().ToObservable(Transform.ImmediateScheduler));          public static T SetContent<T>(this T message,  string content, string key = null, string secret = null,bool formDataContent=false) where T:HttpRequestMessage {             if (message.Method != HttpMethod.Get&&!string.IsNullOrEmpty(content) )                 message.Content = new StringContent(content, Encoding.UTF8, formDataContent ? "application/x-www-form-urlencoded" : "application/json");              return message.Sign(key, secret);         }          public static HttpRequestMessage NewHttpRequestMessage(this HttpMethod httpMethod, string requestUri,object o=null, string key=null,string secret=null)              => new HttpRequestMessage(httpMethod,requestUri).SetContent(o.Serialize(),key,secret);              }          public class HttpResponseException:HttpRequestException {         public HttpResponseMessage HttpResponseMessage{ get; }          public HttpResponseException(string paramName, HttpResponseMessage httpResponseMessage) : base(paramName) => HttpResponseMessage = httpResponseMessage;     }       }using System; using System.IO; using System.Reactive.Linq; using System.Reactive.Threading.Tasks; using System.Text.Json; using Xpand.Extensions.JsonExtensions; using Xpand.Extensions.Reactive.Transform.System.Net; using Xpand.Extensions.Reactive.Utility; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.Reactive.Transform.System.Text.Json {     public static class JsonExtension {         public static IObservable<JsonElement> SelectMany(this IObservable<JsonElement> source)             => source.SelectMany(document => document.SelectMany());         public static IObservable<T> WhenJsonElement<T>(this string source, Func<JsonElement, IObservable<T>> selector)             => Observable.Using(() => source.MemoryStream(),stream => stream.WhenJsonDocument(document => selector(document.RootElement))).SelectMany();          public static IObservable<(T[] objects, JsonDocument document)> WhenJsonDocument<T>(this IObservable<Stream> source, Func<JsonDocument, IObservable<T>> selector)             => source.SelectMany(stream => stream.WhenJsonDocument(selector));         public static IObservable<(T[] objects, JsonDocument document)> WhenJsonDocument<T>(this Stream stream,Func<JsonDocument,IObservable<T>> selector)              => JsonDocument.ParseAsync(stream).ToObservable().SelectMany(document => selector(document)                     .BufferUntilCompleted().Pair(document)                     .FinallySafe(document.Dispose)             );                  public static IObservable<JsonDocument> WhenJsonDocument(this Stream stream)              => JsonDocument.ParseAsync(stream).ToObservable();         public static IObservable<JsonDocument> WhenJsonDocument(this byte[] bytes)              => Observable.Using(() => new MemoryStream(bytes),stream => JsonDocument.ParseAsync(stream).ToObservable());           public static bool IsDisposed(this JsonElement element) {             try {                 var _ = element.YieldJsonElementArray();                 return false;             }             catch (ObjectDisposedException) {                 return true;             }         }          public static bool IsDisposed(this JsonDocument document)              => document.RootElement.IsDisposed();     } }using System; using System.Reactive; using System.Reactive.Linq; using System.Reactive.Threading.Tasks;  namespace Xpand.Extensions.Reactive.Utility{     public static partial class Utility {         public static IObservable<T> AsyncFinally<T>(this IObservable<T> source, Func<IObservable<object>> action)             => source.AsyncFinally(async () => await action().ToTask());          public static IObservable<T> AsyncFinally<T>(this IObservable<T> source, Func<System.Threading.Tasks.Task> action)              => source                 .Materialize()                 .SelectMany(async n => {                     switch (n.Kind){                         case NotificationKind.OnCompleted:                         case NotificationKind.OnError:                             await action();                             return n;                         case NotificationKind.OnNext:                             return n;                         default:                             throw new NotImplementedException();                     }                 })                 .Dematerialize();     } }using System; using System.Collections.Concurrent; using System.Reactive.Linq; using System.Reactive.Subjects;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {                  public static IObservable<T2> Cache<T, T2,TKey>(this IObservable<T> source,             ConcurrentDictionary<TKey, IConnectableObservable<object>> storage, TKey key,             Func<T, IObservable<T2>> secondSelector, TimeSpan? interval) where T2 : class             => source.SelectMany(message => {                     if (interval.HasValue) {                         if (storage.TryGetValue(key, out var value)) {                             return value.FirstAsync().Cast<T2>();                         }                         var publish = Observable.Interval(interval.Value)                             .SelectMany(_ => secondSelector(message))                             .Publish().RefCount().Replay(1);                         var connection = publish.Connect();                         storage.TryAdd(key, publish);                         return publish.FirstAsync().Finally(() =>connection.Dispose() ).Cast<T2>();                     }                      return secondSelector(message);                 });     } }using System; using System.Collections.Generic; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> Defer<T>(this object o, IObservable<T> execute)             => Observable.Defer(() => execute);                  public static IObservable<Unit> DeferAction<T>(this T o, Action<T> execute)             => Observable.Defer(() => {                 execute(o);                 return Observable.Empty<Unit>();             });                  public static IObservable<T> Defer<T,TObject>(this TObject o, Func<TObject,IObservable<T>> selector)             => Observable.Defer(() => selector(o));                  public static IObservable<T> Defer<T>(this object o, Func<IObservable<T>> selector)             => Observable.Defer(selector);                  public static IObservable<T> Defer<T>(this object o, Func<IEnumerable<T>> selector)             => Observable.Defer(() => selector().ToNowObservable());                  public static IObservable<T> DelaySubscription<T>(this IObservable<T> source, TimeSpan delay, IScheduler scheduler = null)              => scheduler == null ? Observable.Timer(delay).SelectMany(_ => source) : Observable.Timer(delay, scheduler).SelectMany(_ => source);          public static IObservable<T> DelayRandomly<T>(this IObservable<T> source, int maxValue, int minValue = 0)             => source.SelectMany(arg => {                 var value = Random.Next(minValue, maxValue);                 return value == 0 ? arg.Observe() : Observable.Timer(TimeSpan.FromSeconds(value)).To(arg);             });     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq; using System.Threading; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static SynchronizationContextScheduler Scheduler(this SynchronizationContext context) => new(context);                  public static IObservable<T> Do<T>(this T self,Action execute) {             execute();             return self.Observe();         }                    public static IObservable<T> DoAfter<T>(this T self,TimeSpan delay,Action execute)              => self.Observe().Delay(delay);          public static IObservable<T> TryDo<T>(this IObservable<T> source, Action<T> tryDo)             => source.Do(obj => {                 try {                     tryDo(obj);                 }                 catch {                     // ignored                 }             });                  public static IObservable<T> DoOnError<T>(this IObservable<T> source, Action<Exception> onError)              => source.Do(_ => { }, onError);          public static IObservable<T> DoSafe<T>(this IObservable<T> source, Action<T> action)             => source.Do(obj => {                 try {                     action(obj);                 }                 catch (Exception) {                     // ignored                 }             });                  public static IObservable<T> DoOnPrevious<T>(this IObservable<T> source, Action<T> onPrevious)             => source.Select(x => (Item: x, HasValue: true))                 .Append((default, false))                 .Scan((previous, current) => {                     if (previous.HasValue) onPrevious(previous.Item);                     return current;                 })                 .Where(entry => entry.HasValue)                 .Select(entry => entry.Item);          public static IObservable<T> DoAfterSubscribe<T>(this IObservable<T> source, Action action)              => Observable.Create<T>(observer => {                 var disposable = source.Subscribe(observer);                 action();                 return disposable;             });          public static IObservable<T> DoOnSubscribe<T>(this IObservable<T> source, Action action)              => Observable.Defer(() => {                 action();                 return source;             });          public static IObservable<T> DoOnComplete<T>(this IObservable<T> source, Action onComplete)             => source.Do(_ => { }, onComplete);          public static IObservable<TSource> DoOnFirst<TSource>(this IObservable<TSource> source, Action<TSource> action)             => source.DoWhen((i, _) => i == 0, action);                  public static IObservable<TSource> DoOnLast<TSource>(this IObservable<TSource> source, Action<TSource> action)             => source.TakeLast(1).Do( action);                  public static IObservable<TSource> DoWhen<TSource>(this IObservable<TSource> source, Func<TSource, bool> predicate, Action<TSource> action)             => source.Do(source1 => {                 if (predicate(source1)) {                     action(source1);                 }             });         public static IObservable<TSource> DoWhen<TSource>(this IObservable<TSource> source, Func<int,TSource, bool> predicate, Action<TSource> action)             => source.Select((source1, i) => {                 if (predicate(i,source1)) {                     action(source1);                 }                 return source1;             });         public static IObservable<TSource> DoWhen<TSource>(this IObservable<TSource> source, Func<int,TSource, bool> predicate, Action<TSource,int> action)             => source.Select((source1, i) => {                 if (predicate(i,source1)) {                     action(source1,i);                 }                 return source1;             });                  /// <summary>         /// Invokes an action sequentially for each element in the observable sequence,         /// on the specified scheduler, skipping and dropping elements that are received         /// during the execution of a previous action, except from the latest element.         /// </summary>         public static IObservable<TSource> DroppingDo<TSource>(this IObservable<TSource> source, Action<TSource> action, IScheduler scheduler = null)              => Observable.Defer(() => {                 Tuple<TSource> latest = null;                 return source.Select(item => {                         var previous = Interlocked.Exchange(ref latest, Tuple.Create(item));                         if (previous != null) return Observable.Empty<TSource>();                         return Observable.Defer(() => {                             var current = Interlocked.Exchange(ref latest, null);                             var unBoxed = current.Item1;                             return Observable.Start(() => {                                 action(unBoxed);                                 return unBoxed;                             }, scheduler ??= System.Reactive.Concurrency.Scheduler.Default);                         });                     })                     .Concat();             });      } }using System; using System.Reactive.Disposables; using System.Reactive.Linq; using System.Runtime.CompilerServices;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         /// <summary>         /// Invokes a specified action after the source observable sequence terminates         /// successfully or exceptionally. The action is invoked before the propagation         /// of the source's completion, and any exception thrown by the action is         /// propagated to the observer. The action is also invoked if the observer         /// is unsubscribed before the termination of the source sequence.         /// </summary>         public static IObservable<T> FinallySafe<T>(this IObservable<T> source, Action finallyAction,[CallerMemberName]string caller="" )              => Observable.Create<T>(observer => {                 var finallyOnce = Disposable.Create(finallyAction);                 var subscription = source.Subscribe(observer.OnNext, error => {                     try {                         finallyOnce.Dispose();                     }                     catch (Exception ex) {                         observer.OnError(ex);                         return;                     }                      observer.OnError(error);                 }, () => {                     try {                         finallyOnce.Dispose();                     }                     catch (Exception ex) {                         ex.Source = caller;                         observer.OnError(ex);                         return;                     }                      observer.OnCompleted();                 });                 return new CompositeDisposable(subscription, finallyOnce);             });           public static IObservable<T> DoFinallySafe<T>(this IObservable<T> source, Action finallyAction)              => source.FinallySafe(() => {                 try {                     finallyAction();                 }                 catch (Exception) {                     // ignored                 }             });     } }using System; using System.Reactive; using System.Reactive.Concurrency; using System.Reactive.Disposables; using System.Reactive.Linq; using System.Threading;  namespace Xpand.Extensions.Reactive.Utility{     public static partial class Utility {         public static IObservable<TSource> ObserveLatestOn<TSource>(this IObservable<TSource> source, SynchronizationContext context)             => source.ObserveLatestOn(new SynchronizationContextScheduler(context));         public static IObservable<TSource> ObserveLatestOnContext<TSource>(this IObservable<TSource> source)             => source.ObserveLatestOn(SynchronizationContext.Current);                  public static IObservable<TSource> ObserveLatest<TSource>(this IObservable<TSource> source)             => source.ObserveLatestOn(System.Reactive.Concurrency.Scheduler.CurrentThread);         public static IObservable<TSource> ObserveLatestOn<TSource>(this IObservable<TSource> source, IScheduler scheduler)              => Observable.Create<TSource>(observer => {                 Notification<TSource> pendingNotification = null;                 var cancelable = new MultipleAssignmentDisposable();                 var sourceSubscription = source.Materialize()                     .Subscribe(notification => {                         var previousNotification = Interlocked.Exchange(ref pendingNotification, notification);                         if (previousNotification != null) return;                         cancelable.Disposable = scheduler.Schedule(() => {                             var notificationToSend = Interlocked.Exchange(ref pendingNotification, null);                             notificationToSend!.Accept(observer);                         });                     });                 return new CompositeDisposable(sourceSubscription, cancelable);             });     } }using System; using System.Reactive.Linq; using System.Threading;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> ObserveOn<T>(this IObservable<T> source, SynchronizationContext synchronizationContext,Func<bool> state)             => !state() ? source : source.ObserveOn(synchronizationContext);     } }using System; using System.Reactive.Linq; using System.Threading; using Xpand.Extensions.Reactive.Conditional;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> ObserveOnContext<T>(this IObservable<T> source, SynchronizationContext synchronizationContext)              => source.ObserveOn(synchronizationContext);          public static IObservable<T> ObserveOnContext<T>(this IObservable<T> source, bool throwIfNull)              => source.If(_ => throwIfNull && SynchronizationContext.Current == null,                 () => Observable.Throw<T>(new NullReferenceException(nameof(SynchronizationContext))), () => source);          public static IObservable<T> ObserveOnContext<T>(this IObservable<T> source) {             var synchronizationContext = SynchronizationContext.Current;             return synchronizationContext != null ? source.ObserveOn(synchronizationContext) : source;         }     } }using System; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> ObserveOnDefault<T>(this IObservable<T> source)             => source.ObserveOn(DefaultScheduler.Instance);     } }using System; using System.Reactive.Linq; using System.Threading; using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.Reactive.Utility{ 	public static partial class Utility {         public static IObservable<T> ObserveOnWindows<T>(this IObservable<T> source, SynchronizationContext synchronizationContext) => 			AppDomain.CurrentDomain.IsHosted() ? source : source.ObserveOn(synchronizationContext); 	} }using System; using System.Reactive; using System.Reactive.Disposables; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> OnDispose<T>(this IObservable<T> source, Action<NotificationKind> disposed)             => Observable.Create<T>(o => {                 Notification<T> last = null;                 var disposable = Disposable.Create(() => disposed(last == null ? NotificationKind.OnNext : last.Kind));                 return new CompositeDisposable(                     source.Materialize().Do(x => last = x).Dematerialize().Subscribe(o), disposable);             });     } }using System; using System.Collections.Generic; using System.Globalization; using System.Reactive.Concurrency; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         /// <summary>         /// Periodically repeats the observable sequence exposing a responses or failures.         /// </summary>         /// <typeparam name="T">The type of the sequence response values.</typeparam>         /// <param name="source">The source observable sequence to re-subscribe to after each <paramref name="period"/>.</param>         /// <param name="period">The period of time to wait before subscribing to the <paramref name="source"/> sequence. Subsequent subscriptions will occur this period after the previous sequence completes.</param>         /// <param name="scheduler">The <see cref="IScheduler"/> to use to schedule the polling.</param>         /// <returns>Returns an infinite observable sequence of values or errors.</returns>         public static IObservable<Try<T>> Poll<T>(this IObservable<T> source, TimeSpan period, IScheduler scheduler)              => Observable.Timer(period, scheduler)                 .SelectMany(_ => source)                  .Select(Try<T>.Create)                  .Catch<Try<T>, Exception>(ex => Observable.Return(Try<T>.Fail(ex)))                  .Repeat();     }      public abstract class Try<T> {         private Try() { }         public static Try<T> Create(T value) => new Success(value);         public static Try<T> Fail(Exception value) => new Error(value);         public abstract TResult Switch<TResult>(Func<T, TResult> caseValue, Func<Exception, TResult> caseError);         public abstract void Switch(Action<T> caseValue, Action<Exception> caseError);         private sealed class Success : Try<T>, IEquatable<Success> {             private readonly T _value;             public Success(T value) => _value = value;             public override TResult Switch<TResult>(Func<T, TResult> caseValue, Func<Exception, TResult> caseError) => caseValue(_value);             public override void Switch(Action<T> caseValue, Action<Exception> caseError) => caseValue(_value);             public bool Equals(Success other)                  => ReferenceEquals(other, this) || other != null && EqualityComparer<T>.Default.Equals(_value, other._value);             public override bool Equals(object obj) => Equals(obj as Success);             public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(_value);             public override string ToString() => string.Format(CultureInfo.CurrentCulture, "Success({0})", _value);         }         private sealed class Error : Try<T>, IEquatable<Error> {             private readonly Exception _exception;             public Error(Exception exception) => _exception = exception ?? throw new ArgumentNullException(nameof(exception));             public override TResult Switch<TResult>(Func<T, TResult> caseValue, Func<Exception, TResult> caseError) => caseError(_exception);             public override void Switch(Action<T> caseValue, Action<Exception> caseError) => caseError(_exception);             public bool Equals(Error other) => ReferenceEquals(other, this) || other != null && Equals(_exception, other._exception);             private static bool Equals(Exception a, Exception b)                  => a == null && b == null || a != null && b != null &&                     (a.GetType() == b.GetType() && (string.Equals(a.Message, b.Message) && Equals(a.InnerException, b.InnerException)));             public override bool Equals(object obj) => Equals(obj as Error);             public override int GetHashCode() => EqualityComparer<Exception>.Default.GetHashCode(_exception);             public override string ToString() => string.Format(CultureInfo.CurrentCulture, "Error({0})", _exception);         }     } }using System; using System.Reactive.Linq; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> StartSequential<T>(this IObservable<T> source)             => source.SelectManySequential(arg => Observable.Start(() => arg));         public static IObservable<T> Start<T>(this IObservable<T> source)             => source.SelectMany(arg => Observable.Start(() => arg));     } }using System; using System.Reactive.Concurrency; using System.Reactive.Disposables; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility{     public static partial class Utility {         public static IObservable<T> Unsubscribed<T>(this IObservable<T> source, Action unsubscribed)              => Observable.Create<T>(o => new CompositeDisposable(source.Subscribe(o), Disposable.Create(unsubscribed)));                  public static IObservable<T> ReplayConnect<T>(this IObservable<T> source, IScheduler scheduler,             int bufferSize = 0)             => source.SubscribeReplay(scheduler, bufferSize);         public static IObservable<T> SubscribeReplay<T>(this IObservable<T> source, IScheduler scheduler,int bufferSize = 0)              => source.SubscribeOn(scheduler ?? System.Reactive.Concurrency.Scheduler.Default).SubscribeReplay(bufferSize);          public static IObservable<T> SubscribeReplay<T>(this IObservable<T> source, int bufferSize = 0){             var replay = bufferSize > 0 ? source.Replay(bufferSize) : source.Replay();             replay.Connect();             return replay;         }         public static IObservable<T> ReplayConnect<T>(this IObservable<T> source, int bufferSize = 0)              => source.SubscribeReplay(bufferSize);                  public static IObservable<T> SubscribeOnDefault<T>(this IObservable<T> source)             => source.SubscribeOn(DefaultScheduler.Instance);                  public static IObservable<T> PublishConnect<T>(this IObservable<T> source)              => source.SubscribePublish();                   public static IObservable<T> SubscribePublish<T>(this IObservable<T> source){             var publish = source.Publish();             publish.Connect();             return publish;         }     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T2> Switch<T,T2>(this IObservable<T> source, Func<T, IObservable<T2>> selector)             => source.Select(selector).Switch();     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> Take<T>(this IObservable<T> source, int count, bool ignoreZeroCount)             => ignoreZeroCount && count == 0 ? source : source.Take(count);     } }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {                  public static IObservable<TSource> Timeout<TSource>(             this IObservable<TSource> source, TimeSpan dueTime, string timeoutMessage)              => source.Timeout(dueTime, Observable.Throw<TSource>(new TimeoutException(timeoutMessage)));     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Diagnostics; using System.IO; using System.Linq; using System.Reactive.Linq; using System.Threading; using EnumsNET; using Fasterflect; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.Tracing; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.Reactive.Utility{     public enum ObservableTraceStrategy{         None,         OnNext,         OnError,         OnNextOrOnError,         All,         Default,     }      public static partial class Utility{         private static ConcurrentDictionary<Type, Func<object, string>> Serialization{ get; }         private static readonly Random Random;          public static Func<object, string> Serializer = o => o.ToString();         static Utility() {             Serialization = new ConcurrentDictionary<Type, Func<object, string>>();             Random = new Random((int) DateTime.Now.Ticks);         }          public static bool AddTraceSerialization(Type type) => Serialization.TryAdd(type, Serializer);          public static bool AddTraceSerialization<T>(Func<T,string> function) => Serialization.TryAdd(typeof(T), o => function((T) o));           private static readonly Dictionary<string, RXAction> RXActions = Enums.GetValues<RXAction>()             .ToDictionary(action => action.AsString(),action => action);          public static IObservable<TSource> Trace<TSource>(this IObservable<TSource> source, string name = null,             TraceSource traceSource = null,             Func<TSource, string> messageFactory = null, Func<Exception, string> errorMessageFactory = null,             Action<ITraceEvent> traceAction = null,             ObservableTraceStrategy traceStrategy = ObservableTraceStrategy.OnNextOrOnError, string memberName = "",             string sourceFilePath = "", int sourceLineNumber = 0)             => Observable.Create<TSource>(observer => {                     if (traceStrategy.Is(ObservableTraceStrategy.All))                         traceSource.Action("Subscribe", "", traceAction.Push(traceSource), messageFactory,                             errorMessageFactory, memberName, name, sourceFilePath, sourceLineNumber);                     var disposable = source.Subscribe(                         v => traceSource.OnNext(traceAction, traceStrategy, v, observer, messageFactory,                             errorMessageFactory, memberName, name, sourceFilePath, sourceLineNumber),                         e => traceSource.OnError(name, messageFactory, errorMessageFactory, traceAction, traceStrategy,                             memberName, sourceFilePath, sourceLineNumber, e, observer),                         () => traceSource.OnCompleted(name, messageFactory, errorMessageFactory, traceAction, traceStrategy,                             memberName, sourceFilePath, sourceLineNumber, observer));                     return () => traceSource.Dispose(name, messageFactory, errorMessageFactory, traceAction, traceStrategy,                         memberName, sourceFilePath, sourceLineNumber, disposable);                 });          private static void Dispose<TSource>(this TraceSource traceSource,string name,  Func<TSource, string> messageFactory,             Func<Exception, string> errorMessageFactory, Action<ITraceEvent> traceAction, ObservableTraceStrategy traceStrategy, string memberName,             string sourceFilePath, int sourceLineNumber, IDisposable disposable){             if (traceStrategy.Is(ObservableTraceStrategy.All))                 traceSource.Action("Dispose", "", traceAction.Push(traceSource), messageFactory, errorMessageFactory,                     memberName, name, sourceFilePath, sourceLineNumber);             disposable.Dispose();         }          private static void OnCompleted<TSource>(this TraceSource traceSource,string name,  Func<TSource, string> messageFactory,             Func<Exception, string> errorMessageFactory, Action<ITraceEvent> traceAction, ObservableTraceStrategy traceStrategy, string memberName,             string sourceFilePath, int sourceLineNumber, IObserver<TSource> observer){             if (traceStrategy.Is(ObservableTraceStrategy.All))                 traceSource.Action("OnCompleted", "", traceAction.Push(traceSource), messageFactory, errorMessageFactory,                     memberName, name, sourceFilePath, sourceLineNumber);             observer.OnCompleted();         }          private static void OnError<TSource>(this TraceSource traceSource,string name,  Func<TSource, string> messageFactory,             Func<Exception, string> errorMessageFactory, Action<ITraceEvent> traceAction, ObservableTraceStrategy traceStrategy, string memberName,             string sourceFilePath, int sourceLineNumber, Exception e, IObserver<TSource> observer){             if (traceStrategy.Is(ObservableTraceStrategy.OnError)){                 traceSource.Action("OnError", e, traceAction.TraceError(traceSource), messageFactory, errorMessageFactory,                     memberName, name, sourceFilePath, sourceLineNumber);             }              observer.OnError(e);         }          private static void OnNext<TSource>(this TraceSource traceSource, Action<ITraceEvent> traceAction,             ObservableTraceStrategy traceStrategy, TSource v, IObserver<TSource> observer,             Func<TSource, string> messageFactory, Func<Exception, string> errorMessageFactory, string memberName,             string name, string sourceFilePath, int sourceLineNumber){             if (traceStrategy.Is(ObservableTraceStrategy.OnNext)){                 traceSource.Action("OnNext", v, traceAction.Push(traceSource),messageFactory,errorMessageFactory,memberName,name,sourceFilePath,sourceLineNumber);             }             observer.OnNext(v);         }          private static void Action<TSource>(this TraceSource traceSource, string m, object v, Action<ITraceEvent> ta,             Func<TSource, string> messageFactory = null, Func<Exception, string> errorMessageFactory = null,             string memberName = "", string name="",string sourceFilePath = "", int sourceLineNumber = 0) {             if (traceSource?.Switch.Level == SourceLevels.Off){                 return;             }             string value = null;             if (v!=null){                 value = CalculateValue(v, o => messageFactory.GetMessageValue( errorMessageFactory, o)).Change<string>();             }             var mName = memberName;             if (m == "OnNext"){                 mName = new[]{memberName," =>",GetSourceName<TSource>()}.JoinString();             }              var fullValue = AllValues(name, sourceFilePath, sourceLineNumber, mName, m, value).JoinString();             var traceEventMessage = new TraceEventMessage() {                 Action = m, RXAction = RXActions[m], Line = sourceLineNumber, DateTime = DateTime.Now,                 Method = mName, Location = Path.GetFileNameWithoutExtension(sourceFilePath), Source = traceSource?.Name,                 Value = fullValue,SourceFilePath=sourceFilePath, Message = value??fullValue,                 Timestamp =DateTime.Now.Ticks,Thread = Thread.CurrentThread.ManagedThreadId,TraceEventType =TraceEventType.Information              };             if (traceEventMessage.RXAction == RXAction.OnNext) {                 traceEventMessage.ResultType = traceEventMessage.Method.Substring(traceEventMessage.Method.IndexOf(">", StringComparison.Ordinal) + 1);                 traceEventMessage.Method = traceEventMessage.Method.Substring(0, traceEventMessage.Method.IndexOf(" ", StringComparison.Ordinal));             }             ta(traceEventMessage);         }          private static string[] AllValues(string name, string sourceFilePath, int sourceLineNumber, string mName, string m, string value)              => string.IsNullOrEmpty(name) ? new[] { Path.GetFileNameWithoutExtension(sourceFilePath), ".", mName, "(", sourceLineNumber.ToString(), "): ", m, "(", value, ")" }                 : new[] { name, ".", Path.GetFileNameWithoutExtension(sourceFilePath), ".", mName, "(", sourceLineNumber.ToString(), "): ", m, "(", value, ")" };          public static bool Is(this ObservableTraceStrategy source,ObservableTraceStrategy target)              => source == ObservableTraceStrategy.All || source switch {                 ObservableTraceStrategy.OnNext => new[]                     { ObservableTraceStrategy.OnNext, ObservableTraceStrategy.Default,ObservableTraceStrategy.OnNextOrOnError }.Contains(target),                 ObservableTraceStrategy.OnError => new[]                     { ObservableTraceStrategy.OnError, ObservableTraceStrategy.Default,ObservableTraceStrategy.OnNextOrOnError }.Contains(target),                 ObservableTraceStrategy.None => new[] { ObservableTraceStrategy.None }.Contains(target),                 ObservableTraceStrategy.OnNextOrOnError => new []{ObservableTraceStrategy.OnNext,ObservableTraceStrategy.OnError, ObservableTraceStrategy.Default,ObservableTraceStrategy.All }.Contains(target),                 _ => throw new NotImplementedException()             };          private static string GetMessageValue<TSource>(this Func<TSource, string> messageFactory, Func<Exception, string> errorMessageFactory, object o){             try{                 return o switch{                     TSource t => (messageFactory?.Invoke(t) ?? o).ToString(),                     Exception e => (errorMessageFactory?.Invoke(e) ?? o).ToString(),                     _ => o.ToString()                 };             }             catch (Exception e){                 return e.Message;             }         }          private static string GetSourceName<TSource>() =>  	        typeof(TSource).IsGenericType ? string.Join(",", typeof(TSource).GetGenericArguments().Select(type => type.Name)) : typeof(TSource).Name;          private static object CalculateValue(object v, Func<object, string> messageFactory) =>             messageFactory != null ? messageFactory(v) : v.GetType().FromHierarchy(_ => _.BaseType)                 .Select(_ => Serialization.TryGetValue(_, out var func) ? func(v) : null).FirstOrDefault()?? v;          private static Action<ITraceEvent> TraceError(this Action<ITraceEvent> traceAction, TraceSource traceSource) => 	        traceAction ?? (s => { 		        if (traceSource != null){                     traceSource.Push(s); 		        } 		        else{                     throw new NotImplementedException(); 			        // System.Diagnostics.Trace.TraceError(s); 		        } 	        });           private static Action<ITraceEvent> Push(this Action<ITraceEvent> traceAction, TraceSource traceSource)              => traceAction ?? (s => { 		        if (traceSource != null){ 			        traceSource.Push(s); 		        } 		        else{ throw new NotImplementedException(); }             });     }     [DebuggerDisplay("{" + nameof(ApplicationTitle) + "}-{" + nameof(Location) + "}-{" + nameof(RXAction) + ("}-{" + nameof(Method) + "}{"+nameof(Value)+"}"))]     public class TraceEventMessage:ITraceEvent{         public TraceEventMessage(ITraceEvent traceEvent) => traceEvent.MapProperties(this);          public TraceEventMessage(){                      }          public string ApplicationTitle{ get; set; }         public string Source{ get; set; }         public TraceEventType TraceEventType{ get; set; }         public string Location{ get; set; }         public string Method{ get; set; }         public int Line{ get; set; }         public string Value{ get; set; }         public string Action{ get; set; }         public RXAction RXAction{ get; set; }         public string Message{ get; set; }         public string CallStack{ get; set; }         public string LogicalOperationStack{ get; set; }         public DateTime DateTime{ get; set; }         public int ProcessId{ get; set; }         public int Thread{ get; set; }         public long Timestamp{ get; set; }         public string ResultType{ get; set; }         public string SourceFilePath { get; set; }     }    }using System; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<TResult> Use<T, TResult>(this T source, Func<T, IObservable<TResult>> selector)             where T : IDisposable             => Observable.Using(() => source, selector);     } }using System; using System.Diagnostics; using System.Reactive.Linq;  namespace Xpand.Extensions.Reactive.Utility {     public static partial class Utility {         public static IObservable<T> WhenDebuggerNotAttached<T>(this IObservable<T> source)             => source.Where(_ => !Debugger.IsAttached);         public static IObservable<T> WhenDebuggerAttached<T>(this IObservable<T> source)             => source.Where(_ => Debugger.IsAttached);     } }using System; using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions{     public static partial class ActionExtensions{         public static ParametrizedAction AsParametrizedAction(this ActionBase action) => action as ParametrizedAction;     } }using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions{     public static partial class ActionExtensions{         public static PopupWindowShowAction AsPopupWindowShowAction(this ActionBase action) => action as PopupWindowShowAction;     } }using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions{     public static partial class ActionExtensions{         public static SimpleAction AsSimpleAction(this ActionBase action) => action as SimpleAction;         public static SimpleAction ToSimpleAction(this ActionBase action) => ((SimpleAction)action);     } }using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions{     public static partial class ActionExtensions{         public static SingleChoiceAction AsSingleChoiceAction(this ActionBase action) => action as SingleChoiceAction;     } }using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {         public static bool Available(this ActionBase actionBase)              => actionBase.Active.ResultValue && actionBase.Enabled.ResultValue;     } }using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {         public static bool DataIs(this ChoiceActionItem item, object value)             => ReferenceEquals(item.Data, value);     } }using System; using System.Collections; using System.Collections.Generic; using System.Diagnostics.CodeAnalysis; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions; using DevExpress.ExpressApp.Utils; using Fasterflect; using Xpand.Extensions.AppDomainExtensions; using Xpand.Extensions.XAF.XafApplicationExtensions;  namespace Xpand.Extensions.XAF.ActionExtensions{          public static partial class ActionExtensions{         public static BoolList Clone(this BoolList boolList){             var list = new BoolList();             foreach (var key in boolList.GetKeys()){                 list.SetItemValue(key,boolList[key]);             }              return list;         }          public static void ExecuteIfAvailable(this SingleChoiceAction actionBase, ChoiceActionItem selectedItem) {             if (actionBase.Available()) {                 actionBase.DoExecute(selectedItem);             }         }         public static void ExecuteIfAvailable(this SimpleAction actionBase) {             if (actionBase.Available()) {                 actionBase.DoExecute();             }         }         public static void ExecuteIfAvailable(this ParametrizedAction actionBase) {             if (actionBase.Available()) {                 actionBase.DoExecute(actionBase.Value);             }         }          public static void DoExecute(this SingleChoiceAction action, object data)              => action.DoExecute(action.Items.FirstOrDefault(item => item.Data==data));          public static void DoExecute(this SingleChoiceAction action,ChoiceActionItem selectedItem, params object[] objectSelection) {             action.DoExecute( () => action.DoExecute(selectedItem), objectSelection);         }          public static void DoExecute(this ActionBase action, Action execute, object[] objectSelection){             if (objectSelection.Any()) {                 var context = action.SelectionContext;                 action.SelectionContext = new SelectionContext(objectSelection.Single());                 execute();                 action.SelectionContext = context;             }             else {                 execute();             }         }          [SuppressMessage("ReSharper", "ArrangeTypeMemberModifiers")]         [SuppressMessage("ReSharper", "UnusedMember.Local")]         sealed class SelectionContext:ISelectionContext {             public SelectionContext(object currentObject) {                 CurrentObject = currentObject;                 SelectedObjects = new List<object>(){currentObject};                 OnCurrentObjectChanged();                 OnSelectionChanged();             }             public object CurrentObject { get; set; }             public IList SelectedObjects { get; set; }             public SelectionType SelectionType => SelectionType.MultipleSelection;             public string Name => null;             public bool IsRoot => false;             public event EventHandler CurrentObjectChanged;             public event EventHandler SelectionChanged;             public event EventHandler SelectionTypeChanged;             [SuppressMessage("ReSharper", "ArrangeTypeMemberModifiers")]             void OnSelectionTypeChanged() => SelectionTypeChanged?.Invoke(this, EventArgs.Empty);             private void OnSelectionChanged() => SelectionChanged?.Invoke(this, EventArgs.Empty);             private void OnCurrentObjectChanged() => CurrentObjectChanged?.Invoke(this, EventArgs.Empty);         }          public static void DoExecute(this SimpleAction action, params object[] selection)              => action.DoExecute(() => action.DoExecute(),selection);          public static bool DoTheExecute(this ActionBase actionBase,bool force=false) {             BoolList active = null;             BoolList enable = null;             if (force&& (!actionBase.Active||!actionBase.Enabled)){                 active = actionBase.Active.Clone();                 enable = actionBase.Enabled.Clone();                 if (!actionBase.Active){                     actionBase.Active.Clear();                 }                 if (!actionBase.Enabled){                     actionBase.Enabled.Clear();                 }             }             if (!actionBase.Active||!actionBase.Enabled)                 return false;             var simpleAction = actionBase as SimpleAction;             simpleAction?.DoExecute();             var singleChoiceAction = actionBase as SingleChoiceAction;             singleChoiceAction?.DoExecute(singleChoiceAction.SelectedItem??singleChoiceAction.Items.FirstOrDefault());              if (actionBase is PopupWindowShowAction popupWindowShowAction) {                 if (popupWindowShowAction.Application.GetPlatform() == Platform.Win) {                     var helper = (IDisposable)Activator.CreateInstance(AppDomain.CurrentDomain.GetAssemblyType("DevExpress.ExpressApp.Win.PopupWindowShowActionHelper"),popupWindowShowAction);                     var view = actionBase.View();                     void OnClosing(object sender, EventArgs args) {                         helper.Dispose();                         view.Closing -= OnClosing;                     }                     view.Closing += OnClosing;                     helper.CallMethod("ShowPopupWindow");                 }                 else {                     popupWindowShowAction.DoExecute((Window)popupWindowShowAction.Controller.Frame);                 }             }              var parametrizedAction = actionBase as ParametrizedAction;             parametrizedAction?.DoExecute(parametrizedAction.Value);             if (active != null){                 foreach (var key in active.GetKeys()){                     active.SetItemValue(key,active[key]);                 }             }             if (enable != null){                 foreach (var key in enable.GetKeys()){                     enable.SetItemValue(key,enable[key]);                 }             }             return true;         }      } }using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {         public static Frame Frame(this ActionBase action) => action.Controller?.Frame;     } }using System; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions; using DevExpress.ExpressApp.SystemModule; using Xpand.Extensions.XAF.XafApplicationExtensions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {          public static DialogController NewDialogController(this ActionBaseEventArgs e, Type objectType,ViewType viewType) {             e.ShowViewParameters.CreatedView =viewType == ViewType.ListView? e.Application().NewListView(objectType):e.Application().NewDetailView(space => space.CreateObject(objectType));             e.ShowViewParameters.CreateAllControllers = true;             e.ShowViewParameters.TargetWindow = TargetWindow.NewModalWindow;             var dialogController = e.Application().CreateController<DialogController>();             e.ShowViewParameters.Controllers.Add(dialogController);             return dialogController;         }     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {         public static IEnumerable<T> SelectedObjects<T>(this ActionBase actionBase) =>             actionBase.SelectionContext.SelectedObjects.Cast<T>();     } }using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using System.Linq; using DevExpress.ExpressApp.Actions; using EnumsNET;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {                  public static void SetImage(this ActionBase action,CommonImage imageName) {             action.BeginUpdate();             action.ImageName = imageName.AsString(EnumFormat.Description);             action.EndUpdate();         }          public static CommonImage CommonImage(this ActionBase action)              => Enums.GetValues<CommonImage>().FirstOrDefault(image => image.AsString(EnumFormat.Description)==action.ImageName);     }      [SuppressMessage("ReSharper", "InconsistentNaming")]     public enum CommonImage {         [Description("Action_Refresh")]         Refresh,         [Description("New")]         New,         [Description("Action_Debug_Start")]         Start,         [Description("Stop")]         Stop,         [Description("ConvertTo")]         ConvertTo,         [Description("BO_Folder")]         Folder,         [Description("Language")]         Language,         [Description("Find")]         Find,         [Description("Actions_Bookmark")]         Mark     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions {     public static partial class ActionExtensions {         public static void SetTargetCriteria<T>(this ActionBase action, Expression<Func<T, bool>> lambda)             => action.TargetObjectsCriteria = CriteriaOperator.FromLambda(lambda).ToString();     } }using System; using DevExpress.ExpressApp.Actions;  namespace Xpand.Extensions.XAF.ActionExtensions;  public static partial class ActionExtensions {     public static TAction Update<TAction>(this TAction action, Action<TAction> update) where TAction : ActionBase {         action.BeginUpdate();         try {             update(action);         }         finally {             action.EndUpdate();         }         return action;     } }using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions; using Xpand.Extensions.XAF.FrameExtensions;  namespace Xpand.Extensions.XAF.ActionExtensions{     public static partial class ActionExtensions{         public static View View(this ActionBase actionBase) => actionBase.View<View>();         public static XafApplication Application(this ActionBaseEventArgs actionBase) => actionBase.Action.Application;         public static View View(this ActionBaseEventArgs actionBase) => actionBase.Action.View();         public static T ParentObject<T>(this ActionBaseEventArgs actionBase) => actionBase.Frame().ParentObject<T>();         public static Frame Frame(this ActionBaseEventArgs actionBase) => actionBase.Action.Controller.Frame;          public static T View<T>(this ActionBase actionBase) where T : View => actionBase.Controller.Frame?.View as T;              } }using System; using System.IO; using System.Linq; using System.Reflection; using ConcurrentCollections; using DevExpress.ExpressApp.Utils.CodeGeneration; using Fasterflect; using HarmonyLib; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.XAF.Harmony;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{ 	    static readonly ConcurrentHashSet<string> References=new();         static AppDomainExtensions()  	        => new HarmonyMethod(typeof(AppDomainExtensions).Method(nameof(ModifyCSCodeCompilerReferences),Flags.Static|Flags.AnyVisibility)) 		        .PreFix(typeof(CSCodeCompiler).GetMethod(nameof(CSCodeCompiler.Compile)),false);          public static void AddModelReference(this AppDomain appDomain, params string[] name){ 	        var locations = AppDomain.CurrentDomain.GetAssemblies()                 .Where(assembly => name.Contains(assembly.GetName().Name))                 .Select(assembly => assembly.Location); 	        foreach (var location in locations){ 		        References.Add(location); 	        }         }                   public static void AddModelReference(this AppDomain appDomain, params Assembly[] assemblies){ 	        foreach (var assembly in assemblies){ 		        References.Add(assembly.Location); 	        }         }                   internal static void ModifyCSCodeCompilerReferences(string sourceCode, ref string[] references, string assemblyFile)  	        => references = references.Concat(References).DistinctWith(Path.GetFileName).ToArray();     } }using System.Linq; using Fasterflect;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         public static System.Reflection.Assembly AssemblyDevExpressExpressAppWeb(this IXAFAppDomain appDomain) => appDomain.AppDomain             .GetAssemblies().FirstOrDefault(_ => _.GetName().Name.StartsWith("DevExpress.ExpressApp.Web.v"));          public static System.Type TypeClientSideEventsHelper(this System.Reflection.Assembly assembly) => assembly             .GetType("DevExpress.ExpressApp.Web.Utils.ClientSideEventsHelper");          public static MethodInvoker AsssignClientHanderSafe(this System.Type type) => type             .Methods(Flags.Static|Flags.Instance|Flags.Public,"AssignClientHandlerSafe").First(info => info.Parameters().Count==4).DelegateForCallMethod();     } }namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         public static object CurrentRequestPage(this IXAFAppDomain xafAppDomain) => xafAppDomain.WebWindowType()             ?.GetProperty("CurrentRequestPage")?.GetValue(null);     } }using System.Linq;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         private static System.Reflection.Assembly _dxWebAssembly;          public static System.Reflection.Assembly DXWebAssembly(this IXAFAppDomain xafAppDomain) => _dxWebAssembly ??=              xafAppDomain.AppDomain.GetAssemblies().FirstOrDefault(assembly => assembly.GetName().Name.StartsWith("DevExpress.ExpressApp.Web.v"));     } }using System.Linq;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         private static object _errorHandlling;         private static System.Type _errorHandlingType;         public static object ErrorHandling(this IXAFAppDomain xafAppDomain){             _errorHandlingType ??= xafAppDomain.DXWebAssembly()?.GetTypes()                 .First(type => type.FullName == "DevExpress.ExpressApp.Web.ErrorHandling");             return _errorHandlling ??= _errorHandlingType?.GetProperty("Instance")?.GetValue(null);         }     } }using System; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.AppDomainExtensions {     public static partial class AppDomainExtensions {         public static bool IsDesignTime(this AppDomain appDomain, params string[] name)              => DesignerOnlyCalculator.IsRunFromDesigner;         public static bool IsRunTime(this AppDomain appDomain, params string[] name)              => !DesignerOnlyCalculator.IsRunFromDesigner;     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{                  public static XafApplication WebApplication(this IXAFAppDomain xafAppDomain) => 	        (XafApplication) xafAppDomain.WebApplicationType()?.GetProperty("Instance")?.GetValue(null);     } }using System.Linq;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         private static System.Type _webApplicationType;         public static System.Type WebApplicationType(this IXAFAppDomain xafAppDomain) => _webApplicationType ??=             xafAppDomain.DXWebAssembly()                 ?.GetTypes().First(type => type.FullName == "DevExpress.ExpressApp.Web.WebApplication");     } }using System.Linq;  namespace Xpand.Extensions.XAF.AppDomainExtensions{     public static partial class AppDomainExtensions{         private static System.Type _webWindowType;         public static System.Type WebWindowType(this IXAFAppDomain xafAppDomain) => _webWindowType ??= xafAppDomain             .DXWebAssembly()             ?.GetTypes().First(type => type.FullName == "DevExpress.ExpressApp.Web.WebWindow");     } }namespace Xpand.Extensions.XAF.AppDomainExtensions{     public interface IXAFAppDomain{         System.AppDomain AppDomain{ get; }         }      class XAFAppDomain:IXAFAppDomain{         public XAFAppDomain(System.AppDomain appDomain) => AppDomain = appDomain;          public System.AppDomain AppDomain{ get;  }     }     public static partial class AppDomainExtensions{         public static IXAFAppDomain XAF(this System.AppDomain appDomain) => new XAFAppDomain(appDomain);      }   }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.SystemModule; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.XAF.XafApplicationExtensions;  namespace Xpand.Extensions.XAF.ApplicationModulesManagerExtensions{     public static partial class ApplicationModulesManagerExtensions{         public static IEnumerable<XafApplication> WhereApplication(this ApplicationModulesManager manager)              => manager.Modules.OfType<SystemModule>().Select(module => module.Application).WhereNotDefault().Select(application => application);          public static IServiceProvider ServiceProvider(this ApplicationModulesManager manager)             => manager.Application()?.ServiceProvider ?? manager.ControllersManager.ServiceProvider();                  public static XafApplication Application(this ApplicationModulesManager manager)              => manager.Modules.OfType<SystemModule>().First().Application;                  public static T Module<T>(this ApplicationModulesManager manager) where T:ModuleBase              => manager.Modules.OfType<T>().FirstOrDefault();     } }using System.Collections.Generic; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Model.Core; using Fasterflect;  namespace Xpand.Extensions.XAF.ApplicationModulesManagerExtensions {     public static partial class ApplicationModulesManagerExtensions {         public static ModelApplicationBase CreateModel(this ApplicationModulesManager manager,             IEnumerable<string> aspects, ModelStoreBase modelDifferenceStore = null) {             ApplicationModelManager applicationModelManager = new ApplicationModelManager();              var application = manager.Application();             var modelAssemblyFilePath = application.CallMethod("GetModelAssemblyFilePath") as string;             applicationModelManager.Setup(XafTypesInfo.Instance, manager.DomainComponents, manager.Modules,                 manager.ControllersManager.Controllers,                 application.ResourcesExportedToModel, aspects, modelDifferenceStore, modelAssemblyFilePath);             return applicationModelManager.CreateModelApplication(new ModelApplicationBase[0]);         }     } }using System; using System.Collections.Generic; using System.Linq;  namespace Xpand.Extensions.XAF.ApplicationModulesManagerExtensions {     public static partial class ApplicationModulesManagerExtensions {         public static IEnumerable<Type> ExportedTypes(this DevExpress.ExpressApp.ApplicationModulesManager manager)             => manager.Modules.SelectMany(m => m.GetExportedTypes().Concat(m.AdditionalExportedTypes).Distinct());     } }using System; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Property,AllowMultiple = true)]     public class ColumnSummaryAttribute:Attribute {         public SummaryType SummaryType{ get; }          public ColumnSummaryAttribute( SummaryType summaryType) {             SummaryType = summaryType;         }     } }using System.ComponentModel; using System.Runtime.InteropServices;  namespace Xpand.Extensions.XAF.Attributes {     [EditorBrowsable(EditorBrowsableState.Never)]     [StructLayout(LayoutKind.Sequential, Size = 1)]     public struct EditorAliases {         public const string UploadFile = "UploadFile";         public const string Tag = "Tag";         public const string MarkupContent = "MarkupContent";         public const string DisplayText = "DisplayText";         public const string BlazorLookup = "BlazorLookup";          } }using System;  namespace Xpand.Extensions.XAF.Attributes{     public class FireChangedAttribute:Attribute {         public string[] Properties{ get; }          public FireChangedAttribute(params string[] properties) {             Properties = properties;         }     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Class|AttributeTargets.Property,AllowMultiple = true)]     public class HiddenActionAttribute:Attribute {         public string[] Actions{ get; }          public HiddenActionAttribute(params string[] actions) => Actions = actions;     }          public class HideModificationActionsAttribute:HiddenActionAttribute {         public HideModificationActionsAttribute() : base("Save","New","SaveAndNew","Delete","SaveAndClose"){         }     } }namespace Xpand.Extensions.XAF.Attributes {     public interface ICloneModelViewAttribute {         string ViewId { get; }     } }using System;  namespace Xpand.Extensions.XAF.Attributes {     [AttributeUsage(AttributeTargets.Property)]     public class IgnoreDataLockingAttribute:Attribute{     } }using System;  namespace Xpand.Extensions.XAF.Attributes {     [AttributeUsage(AttributeTargets.Property)]     public class ImgPropertyAttribute:Attribute {         public ImgPropertyAttribute(int width=20) => Width = width;          public int DetailViewWidth { get; set; }         public int Width { get; }     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Property)]     public class InvisibleInAllListViewsAttribute:Attribute {     } }using System;  namespace Xpand.Extensions.XAF.Attributes {     public enum OperationLayer {         Model, Appearance     }     [AttributeUsage(AttributeTargets.Property)]     public class InvisibleInAllViewsAttribute:Attribute {         public OperationLayer Layer { get; }          public InvisibleInAllViewsAttribute(OperationLayer layer = OperationLayer.Model)              => Layer = layer;     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Property)]     public class LinkUnlinkPropertyAttribute:Attribute {         public string PropertyName{ get; }          public LinkUnlinkPropertyAttribute(string propertyName) => PropertyName = propertyName;     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Class)]     public class ListViewShowFooterAttribute:Attribute {              } }using System;  namespace Xpand.Extensions.XAF.Attributes{     public class MapTypeMembersAttribute:Attribute{         public Type Source{ get; }          public MapTypeMembersAttribute(Type source) => Source = source;     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     public class ModelLookupPropertyAttribute:Attribute {         public ModelLookupPropertyAttribute(string property) => Property = property;          public string Property { get; }     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Class)]     public class NonPersistentChangesEnabledAttribute:Attribute {              } }namespace Xpand.Extensions.XAF.Attributes{     public enum ObjectModification{         All,         New,         NewOrUpdated,         NewOrDeleted,         Updated,         UpdatedOrDeleted,         Deleted     } }using System;  namespace Xpand.Extensions.XAF.Attributes {     [AttributeUsage(AttributeTargets.Property)]     public class ReadOnlyCollectionAttribute:Attribute,IReadOnlyAttribute {         public bool AllowEdit { get; }         public bool AllowDelete { get; }         public bool AllowNew { get; }          public bool DisableListViewProcess { get; }          public ReadOnlyCollectionAttribute(bool allowEdit=false,bool allowDelete=false,bool allowNew=false,bool disableListViewProcess=false) {             DisableListViewProcess = disableListViewProcess;             AllowEdit = allowEdit;             AllowDelete = allowDelete;             AllowNew = allowNew;         }     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.Attributes {     public interface IReadOnlyAttribute {         bool AllowEdit { get; }         bool AllowDelete { get; }         bool AllowNew { get; }         bool DisableListViewProcess { get; }     }      [AttributeUsage(AttributeTargets.Class)]     public class ReadOnlyObjectViewAttribute:Attribute, IReadOnlyAttribute {         public ViewType ViewType { get; }         public bool AllowEdit { get; }         public bool AllowDelete { get; }         public bool AllowNew { get; }         public bool DisableListViewProcess { get; }          public ReadOnlyObjectViewAttribute(ViewType viewType=ViewType.Any,bool allowEdit=false,bool allowDelete=false,bool allowNew=false,bool disableListViewProcess=false) {             ViewType = viewType;             AllowEdit = allowEdit;             AllowDelete = allowDelete;             AllowNew = allowNew;             DisableListViewProcess = disableListViewProcess;         }     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Property)]     public class ReadOnlyPropertyAttribute:Attribute {         public bool AllowClear { get; }         public ReadOnlyPropertyAttribute(bool allowClear=false) {             AllowClear = allowClear;         }     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     public interface IReloadWhenChange {         Action<string> WhenPropertyChanged { get; }     }     public class ReloadWhenChangeAttribute:Attribute {         public Type[] Types{ get; }         public ReloadWhenChangeAttribute(params Type[] types) => Types = types;          public string ObjectPropertyChangeMethodName{ get; }          public ReloadWhenChangeAttribute(string objectPropertyChangeMethodName) => ObjectPropertyChangeMethodName = objectPropertyChangeMethodName;     } }using System;  namespace Xpand.Extensions.XAF.Attributes{     [AttributeUsage(AttributeTargets.Class)]     public class ShowInstanceDetailViewAttribute:Attribute {              } }using System;  namespace Xpand.Extensions.XAF.Attributes {     [AttributeUsage(AttributeTargets.Property)]     public class UrlPropertyAttribute:Attribute {         public bool IsEmail { get; set; }     } }using System;  namespace Xpand.Extensions.XAF.Attributes {     [AttributeUsage(AttributeTargets.Property)]     public class VisibleInAllViewsAttribute:Attribute {     } }using System; using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using EnumsNET;  namespace Xpand.Extensions.XAF.Attributes.Custom {     [SuppressMessage("ReSharper", "IdentifierTypo")]     [SuppressMessage("ReSharper", "InconsistentNaming")]     public enum DisplayDateType {         [Description("")]         None,         [Description("dd/MM/yy")]         ddMMyy     }     [SuppressMessage("ReSharper", "IdentifierTypo")]     [SuppressMessage("ReSharper", "InconsistentNaming")]     public enum DisplayTimeType {         [Description("hh:mm:ss")]         hh_mm_ss,         [Description("mm:ss")]         mm_ss,         [Description("hh:mm")]         hh_mm,         [Description("mm:ss:fff")]         mm_ss_fff     }     public class DisplayDateAndTime : Attribute, ICustomAttribute {         private readonly string _dateString;         private readonly string _timeString;         public DisplayDateAndTime():this(DisplayDateType.ddMMyy) { }          public DisplayDateAndTime(DisplayDateType displayDateType = DisplayDateType.ddMMyy,DisplayTimeType displayTimeType=DisplayTimeType.hh_mm_ss) {             _dateString = displayDateType.AsString(EnumFormat.Description);             _timeString = displayTimeType.AsString(EnumFormat.Description);         }         string ICustomAttribute.Name => "DisplayFormat;EditMask;EditMaskType";          string ICustomAttribute.Value => $"{{0: {_dateString}{_timeString}}};{_dateString} {_timeString};DateTime";     } }using System;  namespace Xpand.Extensions.XAF.Attributes.Custom {     public class DisplayFormatAttribute : Attribute, ICustomAttribute {         readonly string _value;          public DisplayFormatAttribute(string value) {             _value = value;         }          string ICustomAttribute.Name => "DisplayFormat";          string ICustomAttribute.Value => _value;     } }namespace Xpand.Extensions.XAF.Attributes.Custom {     public interface ICustomAttribute {         string Name { get; }         string Value { get; }     } }using System;  namespace Xpand.Extensions.XAF.Attributes.Custom {     public class NumericFormatAttribute : Attribute, ICustomAttribute {         string ICustomAttribute.Name => "DisplayFormat;EditMask";          string ICustomAttribute.Value => "{0:##0.#};0.000#######";     } }using System; using System.Collections; using System.Linq.Expressions; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.CollectionSourceExtensions{     public static partial class CollectionSourceExtensions{ 	    public static void AddRange(this CollectionSourceBase collectionSourceBase, IEnumerable objects){ 			foreach (var o in objects){ 				collectionSourceBase.Add(o); 			} 		} 	} }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Fasterflect; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.CollectionSourceExtensions {     public static partial class CollectionSourceExtensions {         public static List<object> Objects<T>(this T collection) where T : DynamicCollection              => ((List<object>) collection.GetPropertyValue("Objects"));          public static T AddObjects<T,T2>(this T collection, T2[] objects,bool notifyLoaded=false) where T : DynamicCollection {             if (objects.Any()) {                 var list = collection.Objects();                 list.AddRange(objects.SkipLastN(1).Cast<object>());                 collection.Add(objects.Last());             }             if (notifyLoaded) {                 collection.CallMethod("RaiseLoaded");             }             return collection;         }     } }#if XAF192  using DevExpress.Data.Filtering; using DevExpress.Data.Filtering.Helpers; using DevExpress.Xpo; using DevExpress.Xpo.DB; using System; using System.Collections; using System.Collections.Generic;   using System.ComponentModel;   using System.Linq;   using DevExpress.ExpressApp.DC;  namespace DevExpress.ExpressApp {       public abstract class DynamicCollectionBase :      ICancelAddNew,     IBindingList,     ICollection,     IEnumerable,     IList,     ITypedList,     IDisposable   {     protected IObjectSpace objectSpace;     protected Type objectType;     protected CriteriaOperator criteria;     protected List<SortProperty> sorting;     private bool inTransaction;     protected int topReturnedObjectsCount;     private bool deleteObjectOnRemove;     private List<object> objects;     protected XafPropertyDescriptorCollection propertyDescriptorCollection;     private bool allowNew;     private bool allowEdit;     private bool allowRemove;     private object newObject;     private int newObjectIndex;     private bool isDisposed;      private void ClearObjects()     {       if (this.objects != null)         this.objects.Clear();       this.objects = (List<object>) null;     }      private void RemoveObject(object obj, int index)     {       this.objects.RemoveAt(index);       this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));       if (!this.deleteObjectOnRemove)         return;       this.objectSpace.Delete(obj);     }      private void ObjectSpace_ObjectReloaded(object sender, ObjectManipulatingEventArgs e)     {       if (this.objects == null || e.Object == null || !this.objectType.IsAssignableFrom(e.Object.GetType()))         return;       int newIndex = this.objects.IndexOf(e.Object);       if (newIndex < 0)         return;       this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemChanged, newIndex, -1));     }      /// <summary>     ///   <para>Occurs after the collection was populated with objects.</para>     /// </summary>     public event EventHandler Loaded;      private void RaiseLoaded()     {       EventHandler loaded = this.Loaded;       if (loaded == null)         return;       loaded((object) this, EventArgs.Empty);     }      private void InitObjects()     {       if (this.objects != null)         return;       this.objects = new List<object>();       try       {         foreach (object obj in this.GetObjects())         {           if (!this.objectSpace.IsObjectToDelete(obj))             this.objects.Add(obj);         }         this.RaiseLoaded();       }       catch (Exception ex)       {         throw this.WrapException(ex);       }     }      protected abstract IEnumerable GetObjects();      protected virtual Exception WrapException(Exception exception) => exception;      protected internal void RaiseListChangedEvent(ListChangedEventArgs eventArgs)     {       ListChangedEventHandler listChanged = this.ListChanged;       if (listChanged == null)         return;       listChanged((object) this, eventArgs);     }      protected virtual IList<IMemberInfo> GetDefaultDisplayableMembers(       ITypeInfo typeInfo)     {       List<IMemberInfo> memberInfoList = new List<IMemberInfo>();       foreach (IMemberInfo member in typeInfo.Members)       {         if (member.IsVisible || member == member.Owner.KeyMember)           memberInfoList.Add(member);       }       return (IList<IMemberInfo>) memberInfoList;     }      protected List<object> Objects     {       get       {         this.InitObjects();         return this.objects;       }     }      /// <summary>     ///   <para>Initializes a new instance of the <see cref="T:DevExpress.ExpressApp.DynamicCollectionBase" /> class with specified settings.</para>     /// </summary>     /// <param name="objectSpace">An Object Space for processing the collection objects.</param>     /// <param name="objectType">A type of objects in the collection.</param>     /// <param name="criteria">The filter criteria. The collection contains only objects that match this criteria.</param>     /// <param name="sorting">A list of <see cref="T:DevExpress.Xpo.SortProperty" /> objects that specify the sort order for the collection.</param>     /// <param name="inTransaction">true if the specified criteria and sorting parameters are applied to all objects (in the database and retrieved); otherwise, false.</param>     public DynamicCollectionBase(       IObjectSpace objectSpace,       Type objectType,       CriteriaOperator criteria,       IList<SortProperty> sorting,       bool inTransaction)     {       this.objectSpace = objectSpace;       this.objectType = objectType;       this.criteria = criteria;       this.sorting = new List<SortProperty>();       if (sorting != null)         this.sorting.AddRange((IEnumerable<SortProperty>) sorting);       this.inTransaction = inTransaction;       this.propertyDescriptorCollection = new XafPropertyDescriptorCollection(objectSpace.TypesInfo.FindTypeInfo(objectType));       foreach (IMemberInfo displayableMember in (IEnumerable<IMemberInfo>) this.GetDefaultDisplayableMembers(this.propertyDescriptorCollection.TypeInfo))         this.propertyDescriptorCollection.CreatePropertyDescriptor(displayableMember, displayableMember.Name);       this.newObjectIndex = -1;       this.allowNew = true;       this.allowEdit = true;       this.allowRemove = true;       objectSpace.ObjectReloaded += new EventHandler<ObjectManipulatingEventArgs>(this.ObjectSpace_ObjectReloaded);     }      /// <summary>     ///   <para>Disposes of all resources this <see cref="T:DevExpress.ExpressApp.DynamicCollectionBase" /> object uses. This method is implemented to support the <see cref="T:System.IDisposable" /> interface.</para>     /// </summary>     public void Dispose()     {       this.isDisposed = true;       this.ListChanged = (ListChangedEventHandler) null;       if (this.objects != null)       {         this.objects.Clear();         this.objects = (List<object>) null;       }       if (this.objectSpace != null)       {         this.objectSpace.ObjectReloaded -= new EventHandler<ObjectManipulatingEventArgs>(this.ObjectSpace_ObjectReloaded);         this.objectSpace = (IObjectSpace) null;       }       this.propertyDescriptorCollection = (XafPropertyDescriptorCollection) null;     }      /// <summary>     ///   <para>Clears the collection. The <see cref="E:DevExpress.ExpressApp.DynamicCollection.FetchObjects" /> event will occur on the next access to this collection.</para>     /// </summary>     public void Reload()     {       if (!this.IsLoaded)         return;       this.ClearObjects();       this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.Reset, 0));     }      /// <summary>     ///   <para>Returns the Object Space used to manipulate the collection's objects.</para>     /// </summary>     /// <value>An Object Space used to manipulate the collection's objects.</value>     public IObjectSpace ObjectSpace => this.objectSpace;      /// <summary>     ///   <para>Returns the type of objects that the <see cref="P:DevExpress.ExpressApp.FetchObjectsEventArgs.Objects" /> collection can contain.</para>     /// </summary>     /// <value>A type of objects that the <see cref="P:DevExpress.ExpressApp.FetchObjectsEventArgs.Objects" /> collection can contain.</value>     public Type ObjectType => this.objectType;      /// <summary>     ///   <para>Specifies criteria used to filter objects in the collection.</para>     /// </summary>     /// <value>A criteria used to filter objects in the collection.</value>     public CriteriaOperator Criteria     {       get => this.criteria;       set       {         if ((object) this.criteria == (object) value)           return;         this.criteria = value;         this.Reload();       }     }      /// <summary>     ///   <para>Specifies the list of <see cref="T:DevExpress.Xpo.SortProperty" /> objects that specify the sort order for the collection.</para>     /// </summary>     /// <value>A list of <see cref="T:DevExpress.Xpo.SortProperty" /> objects that specify the sort order for the collection.</value>     public IList<SortProperty> Sorting     {       get => (IList<SortProperty>) this.sorting.AsReadOnly();       set       {         this.sorting.Clear();         if (value != null)           this.sorting.AddRange((IEnumerable<SortProperty>) value);         this.Reload();       }     }      /// <summary>     ///   <para>Specifies if the specified <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Criteria" /> and <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Sorting" /> parameters are applied to all objects (in the database and retrieved).</para>     /// </summary>     /// <value>true if the specified <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Criteria" /> and <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Sorting" /> parameters are applied to all objects (in the database and retrieved); otherwise, false.</value>     public bool InTransaction => this.inTransaction;      /// <summary>     ///   <para>Specifies the maximum number of objects that can be retrieved from the collection.</para>     /// </summary>     /// <value>The maximum number of objects that can be retrieved from the collection.</value>     public int TopReturnedObjectsCount     {       get => this.topReturnedObjectsCount;       set => this.topReturnedObjectsCount = value;     }      /// <summary>     ///   <para>For internal use.</para>     /// </summary>     /// <value></value>     public string DisplayableProperties     {       get => this.propertyDescriptorCollection.DisplayableMembers;       set       {         if (!(this.propertyDescriptorCollection.DisplayableMembers != value))           return;         this.propertyDescriptorCollection.DisplayableMembers = value;         this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.PropertyDescriptorChanged, -1, -1));       }     }      /// <summary>     ///   <para>Specifies whether objects are deleted from a storage when they are removed from the collection.</para>     /// </summary>     /// <value>true if objects are deleted from a storage when they are removed from the collection; otherwise, false.</value>     public bool DeleteObjectOnRemove     {       get => this.deleteObjectOnRemove;       set => this.deleteObjectOnRemove = value;     }      /// <summary>     ///   <para>Indicates whether the collection was populated with objects.</para>     /// </summary>     /// <value>true if the collection was populated with objects; otherwise, false.</value>     public bool IsLoaded => this.objects != null;      void ICancelAddNew.CancelNew(int itemIndex)     {       if (this.newObject == null || this.newObjectIndex != itemIndex)         return;       this.objects.Remove(this.newObject);       this.objectSpace.RemoveFromModifiedObjects(this.newObject);       this.newObject = (object) null;       this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemDeleted, this.newObjectIndex));       this.newObjectIndex = -1;     }      void ICancelAddNew.EndNew(int itemIndex)     {       if (this.newObject == null || this.newObjectIndex != itemIndex)         return;       this.objectSpace.SetModified(this.newObject);       this.newObject = (object) null;       this.newObjectIndex = -1;     }      void IBindingList.AddIndex(PropertyDescriptor property)     {     }      object IBindingList.AddNew()     {       if (!this.allowNew)         throw new Exception("AddNew is not allowed.");       this.InitObjects();       this.newObject = this.objectSpace.CreateObject(this.objectType);       this.objects.Add(this.newObject);       this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemAdded, this.objects.Count - 1));       this.newObjectIndex = this.objects.Count - 1;       return this.newObject;     }      void IBindingList.ApplySort(       PropertyDescriptor memberDescriptor,       ListSortDirection direction)     {       this.sorting.Clear();       this.sorting.Add(new SortProperty(memberDescriptor.Name, direction == ListSortDirection.Ascending ? SortingDirection.Ascending : SortingDirection.Descending));       this.Reload();     }      void IBindingList.RemoveSort()     {       if (this.sorting.Count <= 0)         return;       this.sorting.Clear();       this.Reload();     }      void IBindingList.RemoveIndex(PropertyDescriptor property)     {     }      int IBindingList.Find(PropertyDescriptor property, object key)     {       this.InitObjects();       for (int index = 0; index < this.objects.Count; ++index)       {         object obj = property.GetValue(this.objects[index]);         if (obj != null)         {           if (obj.Equals(key))             return index;         }         else if (key == null)           return index;       }       return -1;     }      /// <summary>     ///   <para>Specifies whether new objects can be added to the collection. This property is implemented to support the <see cref="T:System.ComponentModel.IBindingList" /> interface.</para>     /// </summary>     /// <value>true if new objects can be added to the collection; otherwise, false.</value>     public bool AllowNew     {       get => this.allowNew;       set => this.allowNew = value;     }      /// <summary>     ///   <para>Specifies whether the collection is read-only. This property is implemented to support the <see cref="T:System.ComponentModel.IBindingList" /> interface.</para>     /// </summary>     /// <value>false if the collection is read-only; otherwise, true.</value>     public bool AllowEdit     {       get => this.allowEdit;       set => this.allowEdit = value;     }      /// <summary>     ///   <para>Specifies whether objects can be removed from the collection. This property is implemented to support the <see cref="T:System.ComponentModel.IBindingList" /> interface.</para>     /// </summary>     /// <value>true if objects can be removed from the collection; otherwise, false.</value>     public bool AllowRemove     {       get => this.allowRemove;       set => this.allowRemove = value;     }      bool IBindingList.IsSorted => this.sorting.Count > 0;      bool IBindingList.SupportsSorting => true;      PropertyDescriptor IBindingList.SortProperty => this.sorting.Count > 0 ? ((ITypedList) this).GetItemProperties((PropertyDescriptor[]) null).Find(this.sorting[0].PropertyName, false) : (PropertyDescriptor) null;      ListSortDirection IBindingList.SortDirection => this.sorting.Count > 0 && this.sorting[0].Direction == SortingDirection.Descending ? ListSortDirection.Descending : ListSortDirection.Ascending;      bool IBindingList.SupportsSearching => true;      bool IBindingList.SupportsChangeNotification => true;      /// <summary>     ///   <para>Occurs when the collection contents are changed. This event is implemented to support the <see cref="T:System.ComponentModel.IBindingList" /> interface.</para>     /// </summary>     public event ListChangedEventHandler ListChanged;      /// <summary>     ///   <para>Adds the specified object to the collection. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="obj">An object to be added to the collection.</param>     /// <returns>An index of the added object. -1 if the object was not added to the collection.</returns>     public int Add(object obj)     {       this.InitObjects();       int newIndex = this.objects.IndexOf(obj);       if (newIndex < 0)       {         this.objects.Add(obj);         newIndex = this.objects.Count - 1;         this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemAdded, newIndex));       }       return newIndex;     }      /// <summary>     ///   <para>Inserts the specified object into the collection at the specified position. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="index">An index where this method inserts the specified object.</param>     /// <param name="obj">An object to insert into the collection.</param>     public void Insert(int index, object obj)     {       this.InitObjects();       int num = this.objects.IndexOf(obj);       if (num == index || num + 1 == index)         return;       this.objects.Insert(index, obj);       if (num < 0)         this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemAdded, index));       else if (num < index)       {         this.objects.RemoveAt(num);         this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemMoved, index - 1, num));       }       else       {         this.objects.RemoveAt(num + 1);         this.RaiseListChangedEvent(new ListChangedEventArgs(ListChangedType.ItemMoved, index, num));       }     }      private void CheckAllowRemove()     {       if (!this.allowRemove)         throw new Exception("Remove is not allowed.");     }      /// <summary>     ///   <para>Removes the specified object from the collection. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="obj">An object to remove.</param>     public void Remove(object obj)     {       this.CheckAllowRemove();       this.InitObjects();       int index = this.objects.IndexOf(obj);       if (index < 0)         return;       this.RemoveObject(obj, index);     }      /// <summary>     ///   <para>Removes an object from the specified index in the collection. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="index">An index of an object to be removed from the collection.</param>     public void RemoveAt(int index)     {       this.CheckAllowRemove();       this.InitObjects();       if (index < 0 || index >= this.objects.Count)         return;       this.RemoveObject(this.objects[index], index);     }      /// <summary>     ///   <para>Removes all objects from the collection. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     public void Clear()     {       this.CheckAllowRemove();       this.Reload();     }      /// <summary>     ///   <para>Checks whether the collection contains the specified object. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="obj">An object this method checks.</param>     /// <returns>true if the collection contains the specified object; otherwise, false.</returns>     public bool Contains(object obj)     {       this.InitObjects();       return this.objects.Contains(obj);     }      /// <summary>     ///   <para>Determines the index of the specified object in the collection. This method is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="obj">An object whom index this method determines.</param>     /// <returns>An index of the specified object. -1 if the collection does not contain this object.</returns>     public int IndexOf(object obj)     {       this.InitObjects();       return this.objects.IndexOf(obj);     }      /// <summary>     ///   <para>Specifies whether the collection is read-only. This property is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <value>true if the collection is read-only; otherwise, false.</value>     public bool IsReadOnly => false;      /// <summary>     ///   <para>Indicates whether the collection has a fixed size. This property is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <value>true if the collection has a fixed size; otherwise, false.</value>     public bool IsFixedSize => false;      /// <summary>     ///   <para>Gets or sets an object at the specified index. This property is implemented to support the <see cref="T:System.Collections.IList" /> interface.</para>     /// </summary>     /// <param name="index">An index of the object to be returned.</param>     /// <value>An object at the specified index.</value>     public object this[int index]     {       get       {         this.InitObjects();         return index >= 0 && index < this.objects.Count ? this.objects[index] : (object) null;       }       set => throw new Exception("List is read only");     }      /// <summary>     ///   <para>Copies the collection to the specified array. This method is implemented to support the <see cref="T:System.Collections.ICollection" /> interface.</para>     /// </summary>     /// <param name="array">A target array.</param>     /// <param name="index">The array's index that is the first position for collection objects.</param>     public void CopyTo(Array array, int index)     {       this.InitObjects();       ((ICollection) this.objects).CopyTo(array, index);     }      /// <summary>     ///   <para>Returns the count of objects in the collection. This property is implemented to support the <see cref="T:System.Collections.ICollection" /> interface.</para>     /// </summary>     /// <value>The count of objects in the collection.</value>     public int Count     {       get       {         if (this.isDisposed)           return 0;         this.InitObjects();         return this.objects.Count;       }     }      /// <summary>     ///   <para>Specifies whether the collection has been disposed of. For internal use.</para>     /// </summary>     /// <value>true, if the collection has been disposed of; otherwise, false.</value>     public bool IsDisposed => this.isDisposed;      /// <summary>     ///   <para>Indicates whether access to the collection is synchronized (thread safe). This property is implemented to support the <see cref="T:System.Collections.ICollection" /> interface.</para>     /// </summary>     /// <value>true if access to the collection is synchronized (thread safe); otherwise, false.</value>     public bool IsSynchronized => false;      /// <summary>     ///   <para>Gets an object that can be used to synchronize access to the collection. This property is implemented to support the <see cref="T:System.Collections.ICollection" /> interface.</para>     /// </summary>     /// <value>An object that can be used to synchronize access to the collection.</value>     public object SyncRoot => (object) this;      IEnumerator IEnumerable.GetEnumerator()     {       this.InitObjects();       return (IEnumerator) this.objects.GetEnumerator();     }      PropertyDescriptorCollection ITypedList.GetItemProperties(       PropertyDescriptor[] listAccessors)     {       if (listAccessors != null && listAccessors.Length != 0)         throw new Exception("listAccessors != null");       return (PropertyDescriptorCollection) this.propertyDescriptorCollection;     }      string ITypedList.GetListName(PropertyDescriptor[] listAccessors) => "";   }    /// <summary>   ///   <para>A proxy collection that allows you to filter and sort an original collection without its change.</para>   /// </summary>   public class DynamicCollection : DynamicCollectionBase   {     private static IEnumerable emptyEnumerable = (IEnumerable) new object[0];      /// <summary>     ///   <para>Initializes a new instance of the <see cref="T:DevExpress.ExpressApp.DynamicCollection" /> class with specified settings.</para>     /// </summary>     /// <param name="objectSpace">An Object Space for processing collection objects.</param>     /// <param name="objectType">A type of objects in the collection.</param>     /// <param name="criteria">The filter criteria. The collection contains only objects that match this criteria.</param>     /// <param name="sorting">A list of <see cref="T:DevExpress.Xpo.SortProperty" /> objects that specify the sort order for the collection.</param>     /// <param name="inTransaction">true if the specified criteria and sorting parameters are applied to all objects (in the database and retrieved); otherwise, false.</param>     public DynamicCollection(       IObjectSpace objectSpace,       Type objectType,       CriteriaOperator criteria,       IList<SortProperty> sorting,       bool inTransaction)       : base(objectSpace, objectType, criteria, sorting, inTransaction)     {     }      /// <summary>     ///   <para>Initializes a new instance of the <see cref="T:DevExpress.ExpressApp.DynamicCollection" /> class with specified settings.</para>     /// </summary>     /// <param name="objectSpace">An Object Space for processing the collection objects.</param>     /// <param name="objectType">A type of objects in the collection.</param>     public DynamicCollection(IObjectSpace objectSpace, Type objectType)       : base(objectSpace, objectType, (CriteriaOperator) null, (IList<SortProperty>) null, false)     {     }      /// <summary>     ///   <para>Occurs when the DynamicCollection contents are accessed for the first time, when this collection is reloaded, or its <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Criteria" /> and <see cref="P:DevExpress.ExpressApp.DynamicCollectionBase.Sorting" /> parameters are changed. Handle this event and set the <see cref="P:DevExpress.ExpressApp.FetchObjectsEventArgs.Objects" /> argument the DynamicCollection contents.</para>     /// </summary>     public event EventHandler<FetchObjectsEventArgs> FetchObjects;      protected override IEnumerable GetObjects()     {       FetchObjectsEventArgs e = new FetchObjectsEventArgs(this.ObjectType, this.Criteria, this.Sorting, this.TopReturnedObjectsCount, this.InTransaction);       EventHandler<FetchObjectsEventArgs> fetchObjects = this.FetchObjects;       if (fetchObjects != null)         fetchObjects((object) this, e);       if (e.Objects == null)         return DynamicCollection.emptyEnumerable;       if (!e.ShapeData)         return e.Objects;       ExpressionEvaluator filterEvaluator = this.objectSpace.GetExpressionEvaluator(this.ObjectType, this.Criteria);       IEnumerable<object> source = e.Objects.Cast<object>().Where<object>((Func<object, bool>) (o => filterEvaluator.Fit(o)));       if (this.Sorting != null)       {         foreach (SortProperty sortProperty in (IEnumerable<SortProperty>) this.Sorting)         {           ExpressionEvaluator sortingEvaluator = this.objectSpace.GetExpressionEvaluator(this.ObjectType, sortProperty.Property);           source = sortProperty.Direction != SortingDirection.Ascending ? (IEnumerable<object>) source.OrderByDescending<object, object>((Func<object, object>) (o => sortingEvaluator.Evaluate(o))) : (IEnumerable<object>) source.OrderBy<object, object>((Func<object, object>) (o => sortingEvaluator.Evaluate(o)));         }       }       if (this.TopReturnedObjectsCount > 0)         source = source.Take<object>(this.TopReturnedObjectsCount);       return (IEnumerable) source;     }   }    public class FetchObjectsEventArgs:EventArgs {     public FetchObjectsEventArgs(Type objectType, CriteriaOperator criteria, IList<SortProperty> sorting, int topReturnedObjectsCount, bool inTransaction) {       throw new NotImplementedException();     }      public IEnumerable Objects { get; }     public bool ShapeData { get; set; }   } }  #endifusing System; using System.Collections; using System.Collections.Generic; using System.ComponentModel; using System.Linq; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.CollectionSourceExtensions{     public static partial class CollectionSourceExtensions{         public static IEnumerable<object> Objects(this CollectionSourceBase collectionSourceBase) => collectionSourceBase.Objects<object>();          public static IEnumerable<T> Objects<T>(this CollectionSourceBase collectionSourceBase) { 	        if (collectionSourceBase.Collection is IEnumerable collection) 		        return collection.Cast<T>(); 	        if (collectionSourceBase.Collection is IListSource listSource) 		        return listSource.GetList().Cast<T>(); 	        if (collectionSourceBase is PropertyCollectionSource propertyCollectionSource) { 		        var masterObject = propertyCollectionSource.MasterObject; 		        return masterObject != null ? ((IEnumerable)propertyCollectionSource.MemberInfo.GetValue(masterObject)).Cast<T>() : Enumerable.Empty<T>(); 	        } 	        return collectionSourceBase.Collection is QueryableCollection queryableCollection 		        ? ((IEnumerable<T>)queryableCollection.Queryable).ToArray() : throw new NotImplementedException($"{collectionSourceBase}");         }     } }using System; using System.Linq.Expressions; using System.Runtime.CompilerServices; using DevExpress.Data.Filtering; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.CollectionSourceExtensions {     public static partial class CollectionSourceExtensions {         public static void SetCriteria<T>(this CollectionSourceBase collectionSourceBase, string key, Expression<Func<T, bool>> lambda)              => collectionSourceBase.Criteria[key]=CriteriaOperator.FromLambda(lambda);         public static void SetCriteria<T>(this CollectionSourceBase collectionSourceBase, Expression<Func<T, bool>> lambda,[CallerMemberName]string callMemberName="")              => collectionSourceBase.SetCriteria(callMemberName,lambda);                  public static void SetFilter<T>(this ProxyCollection collection, Expression<Func<T, bool>> lambda)              => collection.Filter = CriteriaOperator.FromLambda(lambda);     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using DevExpress.Persistent.Base;  namespace Xpand.Extensions.XAF.CriteriaOperatorExtensions {     public static partial class CriteriaOperatorExtensions {         class StringProcessor : CriteriaProcessorBase {               protected override void Process(OperandValue theOperand) {                   base.Process(theOperand);                   if (theOperand.Value != null) {                       var typeInfo = XafTypesInfo.Instance.FindTypeInfo(theOperand.Value.GetType());                       if (typeInfo is{ DefaultMember:{ } }) {                           theOperand.Value = typeInfo.DefaultMember.GetValue(theOperand.Value).ToString();                           return;                       }                       theOperand.Value = theOperand.Value.ToString();                   }               }           }          public static string UserFriendlyString(this CriteriaOperator criteriaOperator) {             new StringProcessor().Process(criteriaOperator);             return criteriaOperator?.ToString();         }          public static CriteriaOperator ToCriteria<T>(this Expression<Func<T, bool>> expression)              => CriteriaOperator.FromLambda(expression);                  public static CriteriaOperator ToCriteria(this string s) => CriteriaOperator.Parse(s);     } }using System.Collections.Generic; using DevExpress.Data.Filtering; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.CriteriaOperatorExtensions {     public static partial class CriteriaOperatorExtensions {         public static GroupOperator Group(this IEnumerable<CriteriaOperator> source,GroupOperatorType operatorType=GroupOperatorType.And)              => new(operatorType, source.WhereNotDefault());     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Editors;  namespace Xpand.Extensions.XAF.DetailViewExtensions {     public static partial class DetailViewExtensions {         public static IEnumerable<DashboardViewItem> DashboardViewerItem(this DetailView detailView)             => detailView.GetItems<DashboardViewItem>().Where(item => item.Model.View.Id == "DashboardViewer_DetailView");     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Editors; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.DetailViewExtensions {     public static partial class DetailViewExtensions {         public static IEnumerable<Frame> FrameContainers(this DetailView view, params Type[] objectTypes)              => view.GetItems<IFrameContainer>().WhereNotDefault(container => container.Frame)                 .Where(container => objectTypes.Contains(container.Frame.View.ObjectTypeInfo.Type) )                 .Select(container => container.Frame);     } }using System; using System.Linq.Expressions; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Editors;  namespace Xpand.Extensions.XAF.DetailViewExtensions{     public static partial class DetailViewExtensions{         public static ListPropertyEditor GetListPropertyEditor<TObject>(this DetailView detailView, Expression<Func<TObject, object>> memberName)             => detailView.GetPropertyEditor<ListPropertyEditor, TObject>(memberName);     } }using System; using System.Linq; using System.Linq.Expressions; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Editors; using Xpand.Extensions.ExpressionExtensions;  namespace Xpand.Extensions.XAF.DetailViewExtensions{     public static partial class DetailViewExtensions{ 	    public static TEditor GetPropertyEditor<TEditor, TObject>(this DetailView detailView, Expression<Func<TObject, object>> memberName)  		    where TEditor : class => detailView.GetPropertyEditor(memberName.MemberExpressionName()) as TEditor;  	    public static PropertyEditor GetPropertyEditor<TObject>(this DetailView detailView, Expression<Func<TObject, object>> memberName)  		    => detailView.GetPropertyEditor(memberName.MemberExpressionName()) ;  	    public static PropertyEditor GetPropertyEditor(this DetailView detailView, string memberName) => detailView             .GetItems<PropertyEditor>().First(editor => editor.MemberInfo.Name ==memberName);     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.DetailViewExtensions {     public static partial class DetailViewExtensions {         public static T SetCurrentObject<T>(this DetailView detailView, Func<IObjectSpace, T> selector) where T:class             => (T)(detailView.CurrentObject = selector(detailView.ObjectSpace));     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Actions; using DevExpress.ExpressApp.SystemModule; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.FrameExtensions{     public partial class FrameExtensions {                  public static void ExecuteRefreshAction(this Frame frame) => frame.GetController<RefreshController>().RefreshAction.DoExecute();          public static T ParentObject<T>(this Frame frame) => frame.As<NestedFrame>().ViewItem.View.CurrentObject.As<T>();          public static NestedFrame AsNestedFrame(this Frame frame) => frame.As<NestedFrame>();          public static NestedFrame ToNestedFrame(this Frame frame) => frame.Cast<NestedFrame>();          public static ActionBase Action(this Frame frame, string id)              => frame.Actions(id).FirstOrDefault();         public static SimpleAction SimpleAction(this Frame frame, string id)              => frame.Actions<SimpleAction>(id).FirstOrDefault();         public static SingleChoiceAction SingleChoiceAction(this Frame frame, string id)              => frame.Actions<SingleChoiceAction>(id).FirstOrDefault();         public static ParametrizedAction ParametrizedAction(this Frame frame, string id)              => frame.Actions<ParametrizedAction>(id).FirstOrDefault();         public static T Action<T>(this Frame frame, string id) where T:ActionBase             => frame.Actions<T>(id).FirstOrDefault();          public static IEnumerable<ActionBase> Actions(this Frame frame,params string[] actionsIds)              => frame.Actions<ActionBase>(actionsIds);         public static (TModule module,Frame frame) Action<TModule>(this Frame frame) where TModule:ModuleBase              => (frame.Application.Modules.FindModule<TModule>(),frame);          public static IEnumerable<T> Actions<T>(this Frame frame,params string[] actionsIds) where T : ActionBase              => frame.Controllers.Cast<Controller>().SelectMany(controller => controller.Actions).OfType<T>()                 .Where(_ => !actionsIds.Any()|| actionsIds.Any(s => s==_.Id));     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.FrameExtensions{     public static partial class FrameExtensions{         public static Controller GetController(this Frame frame, System.Type controllerType)  	        => (Controller) frame.CallMethod(new[]{controllerType}, "GetController");                  public static Controller GetController(this Frame frame, string controllerName)  	        => frame.Controllers.Cast<Controller>().FirstOrDefault(controller => controller.Name==controllerName);                  public static IEnumerable<T> GetControllers<T>(this Frame frame) where T:Controller 	        => frame.GetControllers(typeof(T)).Cast<T>();     } }using System; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.XAF.ViewExtensions;  namespace Xpand.Extensions.XAF.FrameExtensions {     public partial class FrameExtensions {         public static bool Is<T>(this T frame, params Nesting[] nesting) where T : Frame              => nesting.Any(item => item == Nesting.Any || frame is NestedFrame && item == Nesting.Nested ||                                          !(frame is NestedFrame) && item == Nesting.Root);         public static bool Is<T>(this T frame, params string[] viewIds) where T : Frame              => viewIds.Contains(frame.View?.Id);          public static bool Is<T>(this T frame, params ViewType[] viewTypes) where T : Frame              => viewTypes.Any(item =>item==ViewType.Any|| frame.View is ObjectView objectView && objectView.Is(item));                  public static bool Is<T>(this T frame, params Type[] types) where T : Frame              => types.Any(item => frame.View is ObjectView objectView && objectView.Is(objectType:item));     } }using System; using DevExpress.ExpressApp; using Xpand.Extensions.XAF.XafApplicationExtensions;  namespace Xpand.Extensions.XAF.FrameExtensions{     public partial class FrameExtensions{         public static void SetDetailView(this Frame frame, Type objectType)              => frame.SetView(frame.Application.NewView(frame.Application.FindDetailViewId(objectType)));     } }using System; using DevExpress.Data.Filtering; using DevExpress.ExpressApp.SystemModule; using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.XAF.FunctionOperators{     public class IsAssignableFromOperator : ICustomFunctionOperator{         public const string OperatorName = "IsAssignableFrom";         private static readonly IsAssignableFromOperator Instance = new IsAssignableFromOperator();          static IsAssignableFromOperator() => CustomFunctionOperatorHelper.Register(Instance);          public Type ResultType(params Type[] operands) => typeof(bool);          public object Evaluate(params object[] operands){             var fullName = operands[1].ToString();             var type = AppDomain.CurrentDomain.GetAssemblyType(fullName);             return type != null && type.IsAssignableFrom((Type) operands[0]);         }          public string Name{ get; } = OperatorName;     } }using DevExpress.Data.Filtering; using DevExpress.ExpressApp.SystemModule;  namespace Xpand.Extensions.XAF.FunctionOperators{     public class PropertyExistsOperator : ICustomFunctionOperator{         public const string OperatorName = "PropertyExists";         private static readonly PropertyExistsOperator Instance = new PropertyExistsOperator();          static PropertyExistsOperator() => CustomFunctionOperatorHelper.Register(Instance);          public System.Type ResultType(params System.Type[] operands) => typeof(bool);          public object Evaluate(params object[] operands) => operands[0].GetType().GetProperty((string) operands[1])!=null;          public string Name{ get; } = OperatorName;     } }using System.Reflection; using HarmonyLib; using Xpand.Extensions.Harmony;  namespace Xpand.Extensions.XAF.Harmony {     public static partial class HarmonyExtensions {         public static void Finalize(this HarmonyMethod harmonyMethod, MethodInfo method, bool onlyRuntime )             => method.Patch(harmonyMethod.Finalize, onlyRuntime);     } }using System.Reflection; using HarmonyLib; using Xpand.Extensions.Harmony;  namespace Xpand.Extensions.XAF.Harmony {     public static partial class HarmonyExtensions {         public static void PostFix(this HarmonyMethod harmonyMethod, MethodInfo method, bool onlyRuntime )             => method.Patch(harmonyMethod.PostFix, onlyRuntime);     } }using System; using System.Reflection; using DevExpress.ExpressApp.Model.Core; using HarmonyLib; using Xpand.Extensions.Harmony;  namespace Xpand.Extensions.XAF.Harmony {     public static partial class HarmonyExtensions {         static void Patch(this MethodInfo method,Action<MethodInfo> patch, bool onlyRuntime = true) {             // if (onlyRuntime && DesignerOnlyCalculator.IsRunTime || !onlyRuntime)                  patch(method);         }          public static void PreFix(this HarmonyMethod harmonyMethod, MethodInfo method, bool onlyRuntime )             => method.Patch(harmonyMethod.PreFix, onlyRuntime);     } }using System.Reflection; using HarmonyLib; using Xpand.Extensions.Harmony;  namespace Xpand.Extensions.XAF.Harmony {     public static partial class HarmonyExtensions {         public static void Transpile(this HarmonyMethod harmonyMethod, MethodInfo method, bool onlyRuntime)             => method.Patch(harmonyMethod.Transpile, onlyRuntime);     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core; using DevExpress.ExpressApp.Model.NodeGenerators;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void AddLayer(this ModelApplicationBase application, ModelNode layer)             => ModelApplicationHelper.AddLayer(application, (ModelApplicationBase) layer);          public static void AddLayerBeforeLast(this ModelApplicationBase application, ModelApplicationBase layer) {             ModelApplicationBase lastLayer = application.LastLayer;             ModelApplicationHelper.RemoveLayer(application);             ModelApplicationHelper.AddLayer(application, layer);             ModelApplicationHelper.AddLayer(application, lastLayer);         }     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.DataAccess.Excel; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public partial class ModelExtensions{         public static ModelNode AddNode<T>(this IModelNode node, string id,bool checkForDuplicates) where T:IModelNode{             if (!checkForDuplicates||(((ModelNode) node)[id] == null)) {                 return (ModelNode) (IModelNode)node.AddNode<T>(id);             }             throw new DuplicateNameValidationException($"{node}");         }          public static IEnumerable<T> EnsureNodes<T>(this IModelNode node, params string[] ids) where T: class, IModelNode              => ids.Select(id => node.GetNode(id) as T ?? node.AddNode<T>());                  public static T EnsureNode<T>(this IModelNode node, params string[] ids) where T: class, IModelNode              => node.EnsureNodes<T>().First();                  public static ModelNode AddNode(this IModelNode node, string id = null) => node.AddNode(node.ModelListType(), id);          public static ModelNode AddNode(this IModelNode node, Type type,string id=null) => node.AddNode(XafTypesInfo.Instance.FindTypeInfo(type),id);          public static ModelNode AddNode(this IModelNode node, ITypeInfo typeInfo,string id=null) => ((ModelNode) node).AddNode(id?? Guid.NewGuid().ToString(), typeInfo.Type);     } }using System; using DevExpress.ExpressApp.Model.Core; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static object ChangedValue(this ModelValueInfo modelValueInfo, object value, Type destinationType) {             var typeConverter = modelValueInfo.TypeConverter;             return typeConverter != null ? typeConverter.ConvertFrom(value) : value.Change(destinationType);         }     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Core; using DevExpress.ExpressApp.Model; using Fasterflect;  namespace Xpand.Extensions.XAF.ModelExtensions{ 	public static partial class ModelExtensions{ 		public static Type ControllerType(this IModelController controller, ControllersManager manager) => 			((IEnumerable<Controller>) manager.GetPropertyValue("Controllers")).Where(_ => _.Name == controller.Name) 			.Select(_ => _.GetType()).FirstOrDefault(); 	} }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions {     public class DesignerCalculator:IModelIsVisible{         public bool IsVisible(IModelNode node, string propertyName) => DesignerOnlyCalculator.IsRunFromDesigner;     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{ 	public partial class ModelExtensions{ 		public static IEnumerable<IModelMemberViewItem> DomainComponentItems(this IModelObjectView modelObjectView, Type propertyEditorType = null) => modelObjectView != null 				? modelObjectView.MemberViewItems(propertyEditorType).Where(editor => editor.ModelMember.MemberInfo.MemberTypeInfo.IsDomainComponent) 				: Enumerable.Empty<IModelMemberViewItem>(); 	} }using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void DontUseCaching(this ModelNode node)              => node.SetValue(ModelValueNames.NeedsCachingKey, false);     } }using System; using System.Collections.Generic; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public partial class ModelExtensions{         static readonly Lazy<FastModelEditorHelper> FastModelEditorHelperLazy=new Lazy<FastModelEditorHelper>(() => new FastModelEditorHelper());         public static bool IsPropertyVisible(this IModelNode node,string propertyName) =>              FastModelEditorHelperLazy.Value.IsPropertyModelBrowsableVisible((ModelNode)node,propertyName);          public static T GetPropertyAttribute<T>(this IModelNode node,string propertyName) where T:Attribute =>              FastModelEditorHelperLazy.Value.GetPropertyAttribute<T>((ModelNode)node,propertyName);          public static IList<T> GetPropertyAttributes<T>(this IModelNode node,string propertyName) where T:Attribute =>              FastModelEditorHelperLazy.Value.GetPropertyAttributes<T>((ModelNode)node,propertyName);     } }using System; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelListView FindLookupListView(this IModelApplication modelApplication, Type objectType) => modelApplication             .GetModelClass(objectType)?.DefaultLookupListView;     } }using System; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core; using DevExpress.ExpressApp.Utils;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelClass GetModelClass(this IModelApplication modelApplication, Type objectType){             var model = modelApplication;             IModelClass modelClass = null;             if ((objectType != null) && model?.BOModel != null){                 ITypeInfo typeInfo = XafTypesInfo.Instance.FindTypeInfo(objectType);                 modelClass = model.BOModel.GetClass(typeInfo != null ? typeInfo.Type : objectType);                 if (modelClass == null){                     var interfaceType = ModelAutoGeneratedRuleNodesHelper.GetAssociatedDomainComponentType(objectType);                     if (interfaceType != null){                         modelClass = model.BOModel.GetClass(interfaceType);                     }                 }             }              return modelClass;         }                  public static IModelClass GetModelClass(this ITypeInfo typeInfo)              => CaptionHelper.ApplicationModel.GetModelClass(typeInfo.Type);         public static IModelClass GetModelClass(this Type type)              => CaptionHelper.ApplicationModel.GetModelClass(type);     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelView FindModelView(this IModelApplication modelApplication, System.String viewId) => modelApplication?.Application.Views?[viewId];     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.NodeGenerators;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void GenerateNodes(this IModelListView listView)             => ModelListViewNodesGenerator.GenerateNodes(listView, listView.ModelClass);     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model.Core; using Fasterflect;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static List<ModelNode> GetLayers(this ModelApplicationBase modelApplicationBase) => ((List<ModelNode>)modelApplicationBase.GetPropertyValue("Layers"));          public static ModelApplicationBase GetLayer(this ModelApplicationBase modelApplicationBase, int index) =>              (ModelApplicationBase) ((List<ModelNode>)modelApplicationBase.GetPropertyValue("Layers"))[index];          public static ModelApplicationBase GetLayer(this ModelApplicationBase modelApplicationBase, string id) =>              (ModelApplicationBase) modelApplicationBase.GetLayers().FirstOrDefault(wrapper => wrapper.Id == id);     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelListView GetLookupListView(this IModelMemberViewItem modelMember) =>              (IModelListView) (modelMember.View??modelMember.Application.FindLookupListView(modelMember.ModelMember.MemberInfo.MemberType));     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static string GetMemberCaption(this IModelClass modelClass, string memberName) =>              modelClass.FindMember(memberName)?.Caption ?? modelClass.TypeInfo.FindMember(memberName).Name;     } }using System; using System.Linq; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static Tuple<ModelValueInfo, IModelNode> GetModelValueInfo(this IModelNode modelNode,             string propertyName) {             if (propertyName.Contains(".")) {                 var split = propertyName.Split('.');                 var strings = string.Join(".", split.Skip(1));                 var node = ((IModelNode)modelNode.GetValue(split.First()));                 return node.GetModelValueInfo(strings);             }              var modelValueInfo = ((ModelNode)modelNode).GetValueInfo(propertyName);             return new Tuple<ModelValueInfo, IModelNode>(modelValueInfo, modelNode);         }     } }using System; using System.Collections; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static ModelNode GetNodeByPath(this IModelNode node, string path){             string[] separator = {"/"};             var strArray = path.Split(separator, StringSplitOptions.RemoveEmptyEntries);             var node2 = strArray[0] == "Application" ? node.Root : node.GetNode(strArray[0]);             for (var i = 1; i < strArray.Length; i++){                 if (node2 == null) return null;                 node2 = node2 is IEnumerable ? ((ModelNode) node2)[strArray[i]] : node2.GetNode(strArray[i]);             }              return (ModelNode) node2;         }     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static TNode GetParent<TNode>(this IModelNode modelNode) where TNode : class{             if (modelNode is TNode node)                 return node;             var parent = modelNode.Parent;             while (!(parent is TNode)) {                 parent = parent.Parent;                 if (parent == null)                     break;             }             return (TNode) parent;         }      } }using DevExpress.ExpressApp.Model; using Xpand.Extensions.XAF.XafApplicationExtensions;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static Platform GetPlaform(this IModelApplication application)              => application.Sources().Modules.GetPlatform();     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static object GetValue(this IModelNode modelNode, string propertyName) => ((ModelNode) modelNode).GetValue(propertyName);     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static string Id(this IModelNode modelNode,string id=null) {             if (id != null) {                 ((ModelNode)modelNode).Id = id;             }             return ((ModelNode)modelNode).Id;         }     } }using DevExpress.ExpressApp.Model.Core; using Fasterflect;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static ModelApplicationBase InsertLayer(this ModelApplicationBase application, string id){             var modelApplication = application.CreatorInstance.CreateModelApplication();             modelApplication.Id = id;             application.InsertLayer(modelApplication);             return modelApplication;         }          public static void InsertLayer(this ModelApplicationBase application,  ModelApplicationBase layer) => application.InsertLayer(application.LayersCount-1,layer);          public static void InsertLayer(this ModelApplicationBase application, int index, ModelApplicationBase layer) => application.CallMethod("InsertLayerAtInternal", layer, index);     } }using System.Linq; using DevExpress.ExpressApp.Model; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static IModelLayoutViewItem LayoutItem(this IModelPropertyEditor modelPropertyEditor)             => ((IModelViewItem)modelPropertyEditor).LayoutItem();              public static IModelLayoutViewItem LayoutItem(this IModelMemberViewItem modelPropertyEditor)             => ((IModelViewItem)modelPropertyEditor).LayoutItem();          public static IModelLayoutViewItem LayoutItem(this IModelViewItem modelViewItem)             => modelViewItem.GetParent<IModelDetailView>().Layout.GetItems<IModelLayoutGroup>(item => item)                 .SelectMany().OfType<IModelLayoutViewItem>().FirstOrDefault(element => element.ViewItem.Id == modelViewItem.Id);     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static ModelApplicationBase Master(this IModelApplication application)              => (ModelApplicationBase) ((ModelApplicationBase) application).Master;     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static IModelNode MergeWith(this IModelNode node, string xml) {             var modelXmlReader = new ModelXmlReader();             var modelApplicationBase = node.Application.NewModelApplication();             modelXmlReader.ReadFromString(modelApplicationBase, "",xml);             node.MergeWith(modelApplicationBase);             return node;         }         public static IModelNode MergeWith(this IModelNode node, IModelNode sourceNode)             => ((ModelNode) node).Merge((ModelNode) sourceNode);     } }using System; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions {     public partial class ModelExtensions {         public static ViewType ViewType(this IModelView view)             => view switch {                 IModelListView => DevExpress.ExpressApp.ViewType.ListView,                 IModelDetailView => DevExpress.ExpressApp.ViewType.DetailView,                 IModelDashboardView => DevExpress.ExpressApp.ViewType.DashboardView,                 _ => throw new NotImplementedException(view.GetType().FullName)             };     } }using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public partial class ModelExtensions{         public static System.Type ModelListItemType(this System.Type type) => type.ModelListType().GenericTypeArguments.First();          public static System.Type ModelListItemType(this IModelNode modelNode) => modelNode.ModelListType().GenericTypeArguments.First();          public static System.Type ModelListType(this IModelNode modelNode) => modelNode.GetType().ModelListType();          public static System.Type ModelListType(this System.Type type) => type.GetInterfaces().FirstOrDefault(_ =>_.IsGenericType && _.GetGenericTypeDefinition() == typeof(IModelList<>));     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static ModelApplicationBase NewModelApplication(this ModelNode application, string id=null){             var modelApplication = application.CreatorInstance.CreateModelApplication();             if (id != null) modelApplication.Id = id;             return modelApplication;         }          public static ModelApplicationBase NewModelApplication(this IModelApplication application, string id=null)              => ((ModelApplicationBase) application).NewModelApplication(id);     } }using System.Collections.Generic; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IEnumerable<IModelNode> Nodes(this IModelNode node){             for (int i = 0; i < node.NodeCount; i++){                 yield return node.GetNode(i);             }         }     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public partial class ModelExtensions{         public static IEnumerable<IModelCommonMemberViewItem> CommonMemberViewItems(this IModelObjectView modelObjectView,string id=null){             var viewItems = modelObjectView is IModelDetailView modelDetailView                 ? modelDetailView.Items.OfType<IModelCommonMemberViewItem>()                 : ((IModelListView) modelObjectView).Columns;             return id != null ? viewItems.Cast<IModelNode>().Where(item => item.Id() == id).Cast<IModelCommonMemberViewItem>() : viewItems;         }     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelMemberViewItem[] OrderForView(this IEnumerable<IModelMemberViewItem> modelMemberViewItems) => modelMemberViewItems             .OrderBy(x => x.Caption).ToArray().OrderBy(x => x.Index).ToArray();     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{ 	public partial class ModelExtensions{ 		public static IEnumerable<IModelPropertyEditor> PropertyEditorItems(this IModelObjectView modelObjectView, Type propertyEditorType = null) => modelObjectView 			.MemberViewItems(propertyEditorType).OfType<IModelPropertyEditor>(); 	} }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static void ReadFromModel(this IModelNode modelNode,IModelNode readFrom){             var modelApplication = (ModelApplicationBase) readFrom.Application;             for (var i = 0; i < modelApplication.AspectCount; i++){                 var aspect = modelApplication.GetAspect(i);                 var xml = new ModelXmlWriter().WriteToString(readFrom, i);                                  if (!string.IsNullOrEmpty(xml)) {                     new ModelXmlReader().ReadFromString(modelNode, aspect, xml);                 }             }         }      } }using System.IO; using DevExpress.ExpressApp.Model; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void ReadFromStream(this IModelNode modelNode, Stream stream, string aspect = "")             => new ModelXmlReader().ReadFromString(modelNode, aspect, stream.ReadToEnd());     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void ReadFromString(this IModelNode modelNode, string xml, string aspect = "")             => new ModelXmlReader().ReadFromString(modelNode, aspect, xml);     } }using System; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public partial class ModelExtensions{         public static T ReadViewInLayer<T>(this IModelApplication modelApplication, T modelView, string newViewId) where T:IModelView{             var modelViews =modelApplication.Application.Views?? modelApplication.AddNode<IModelViews>();             if (modelViews[modelView.Id]!=null)                 throw new NotSupportedException($"{modelView.Id} already exists");             IModelView newNode;             switch (modelView){                 case IModelDetailView _:                     newNode = modelViews.AddNode<IModelDetailView>();                     break;                 case IModelListView _:                     newNode = modelViews.AddNode<IModelListView>();                     break;                 case IModelDashboardView _:                     newNode = modelViews.AddNode<IModelDashboardView>();                     break;                 default:                     throw new NotImplementedException();             }                          newNode.ReadFromModel( modelView);             newNode.Id = newViewId;             return (T) newNode;         }      } }using System; using System.Collections.Generic; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         private static void RefreshLayers(ModelApplicationBase application,             Func<ModelApplicationBase, ModelApplicationBase> func){             var modelApplicationBases = new List<ModelApplicationBase>();             var lastLayer = application.LastLayer;             ModelApplicationHelper.RemoveLayer(application);             var afterSetup = application.LastLayer;             ModelApplicationHelper.RemoveLayer(application);             while (application.LastLayer.Id != "Unchanged Master Part"){                 ModelApplicationBase modelApplicationBase = application.LastLayer;                 modelApplicationBase = func.Invoke(modelApplicationBase);                 if (modelApplicationBase != null)                     modelApplicationBases.Add(modelApplicationBase);                 ModelApplicationHelper.RemoveLayer(application);             }              modelApplicationBases.Reverse();             foreach (var modelApplicationBase in modelApplicationBases){                 ModelApplicationHelper.AddLayer(application, modelApplicationBase);             }              ModelApplicationHelper.AddLayer(application, afterSetup);             ModelApplicationHelper.AddLayer(application, lastLayer);         }     } }using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static void RemoveLayer(this ModelApplicationBase application) => ModelApplicationHelper.RemoveLayer(application);          public static void RemoveLayer(this ModelApplicationBase application, string id) => RefreshLayers(application, @base => @base.Id == id ? null : @base);     } }using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static void ReplaceLayer(this ModelApplicationBase application, ModelApplicationBase layer) =>              RefreshLayers(application, @base => application.LastLayer.Id == layer.Id ? layer : @base);     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.SystemModule;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void SetFilterCriteria<T>(this IModelListView view, Expression<Func<T, bool>> lambda)             => view.Filter = CriteriaOperator.FromLambda(lambda).ToString();         public static void SetCriteria<T>(this IModelListView view, Expression<Func<T, bool>> lambda)             => view.Criteria = CriteriaOperator.FromLambda(lambda).ToString();         public static void SetCriteria<T>(this IModelListViewFilterItem item, Expression<Func<T, bool>> lambda)             => item.Criteria = CriteriaOperator.FromLambda(lambda).ToString();     } }using System; using DevExpress.ExpressApp.Model; using Fasterflect;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static void SetValue(this IModelNode modelNode, string propertyName, Type propertyType, object value) {             if (propertyType == null) {                 var modelValueInfo = modelNode.GetModelValueInfo(propertyName).Item1;                 var changedValue = modelValueInfo.ChangedValue(value, modelValueInfo.PropertyType);                 modelNode.CallMethod(new[] { modelValueInfo.PropertyType }, "SetValue", propertyName, changedValue);             }             else                 modelNode.CallMethod(new[] { propertyType }, "SetValue", propertyName, value);         }     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         public static IModelSources Sources(this IModelApplication application) => ((IModelSources)application);     } }using System.Collections.Generic; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static CalculatedModelNodeList<T> ToCalculatedModelNodeList<T>(this IEnumerable<T> source) where T : IModelNode              =>source!=null? new(source):new CalculatedModelNodeList<T>();     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions {     public partial class ModelExtensions {         public static IEnumerable<ITypeInfo> TypeInfos(this IModelBOModel boModel)              => boModel.Select(c => c.TypeInfo);     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;   namespace Xpand.Extensions.XAF.ModelExtensions{          public partial class ModelExtensions{         public static IEnumerable<IModelMemberViewItem> MemberViewItems(this IModelView modelObjectView, Type propertyEditorType=null)             => !(modelObjectView is IModelObjectView) ? Enumerable.Empty<IModelMemberViewItem>()                 : (modelObjectView is IModelListView modelListView ? modelListView.Columns : ((IModelDetailView) modelObjectView).Items.OfType<IModelMemberViewItem>())                 .Where(item => propertyEditorType == null || propertyEditorType.IsAssignableFrom(item.PropertyEditorType));     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static IModelMemberViewItem[] VisibleMemberViewItems(this IModelObjectView modelObjectView) => modelObjectView.MemberViewItems().VisibleMemberViewItems().ToArray();          public static IModelMemberViewItem[] VisibleMemberViewItems(this IEnumerable<IModelMemberViewItem> modelMemberViewItems) => modelMemberViewItems             .Where(item => !item.Index.HasValue || item.Index > -1).ToArray();     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions {     public static partial class ModelExtensions {         private static HashSet<string> _modelNodePropertyInfos;          static ModelExtensions() {             _modelNodePropertyInfos = new HashSet<string>(typeof(ModelNode).GetProperties().Select(info => info.Name).Concat(new []{"Removed"}));         }         public static IEnumerable<ModelValueInfo> WhenNotModelNode(this IEnumerable<ModelValueInfo> source) => source.Where(info => !_modelNodePropertyInfos.Contains(info.Name));     } }using DevExpress.ExpressApp.Model; using DevExpress.ExpressApp.Model.Core;  namespace Xpand.Extensions.XAF.ModelExtensions{     public static partial class ModelExtensions{         public static string Xml(this IModelNode modelNode) => ((ModelNode) modelNode).Xml;     } }using System.ComponentModel; using System.Linq; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using DevExpress.Persistent.Base;  namespace Xpand.Extensions.XAF.ModelExtensions.Shapes {     [KeyProperty(nameof(ListViewId))]     [ModelDisplayName(nameof(ListView))]     public interface IModelListViewKey : IModelNode {         [Required]         [DataSourceProperty(nameof(ListViews))]         IModelListView ListView{ get; set; }         [Browsable(false)]         string ListViewId { get; set; }         [Browsable(false)]         IModelList<IModelListView> ListViews{ get; }     }           public interface IModelListViewKeys:IModelList<IModelListViewKey>,IModelNode{     }       [DomainLogic(typeof(IModelListViewKey))]     public class ModelListViewKeyLogic{         public static IModelListView Get_ListView(IModelListViewKey feature) =>!string.IsNullOrEmpty(feature.ListViewId)? (IModelListView) feature.Application.Views[feature.ListViewId]:null;          public static void Set_ListView(IModelListViewKey listViewFeature, IModelListView listView) => listViewFeature.ListViewId = listView?.Id;          public static IModelList<IModelListView> Get_ListViews(IModelListViewKey modelListViewFeature)              => modelListViewFeature.Application.Views.OfType<IModelListView>().ToCalculatedModelNodeList();     }      public interface IModelListViewColumns:IModelNode,IModelList<IModelListViewColumn> { }      [KeyProperty(nameof(Key))]     public interface IModelListViewColumn : IModelNode {         [Browsable(false)]         string Key { get; set; }         [Required][DataSourceProperty(nameof(ListViews))]         IModelListView ListView { get; set; }         [Browsable(false)]         IModelList<IModelListView> ListViews{ get; }         [DataSourceProperty(nameof(ListView)+".Columns")]         [Required]         IModelColumn Column { get; set; }     }      [DomainLogic(typeof(IModelListViewColumn))]     public class ModelListViewColumnLogic{         public static IModelListView Get_ListView(IModelListViewColumn listViewColumn)              =>!string.IsNullOrEmpty(listViewColumn.Key)? (IModelListView) listViewColumn.Application.Views[listViewColumn.Key.Split('-')[0]]:null;                  public static IModelColumn Get_Column(IModelListViewColumn listViewColumn)              =>listViewColumn.ListView?.Columns[listViewColumn.Key.Split('-')[1]];          public static void Set_ListView(IModelListViewColumn listViewColumn, IModelListView listView)              => listViewColumn.Key = $"{listView.Id}-{listViewColumn.Column?.Id}";                  public static void Set_Column(IModelListViewColumn listViewColumn, IModelColumn modelColumn)              => listViewColumn.Key = $"{listViewColumn.ListView?.Id}-{modelColumn.Id}";          public static IModelList<IModelListView> Get_ListViews(IModelListViewColumn modelListViewColumn)              => modelListViewColumn.Application.Views.OfType<IModelListView>().ToCalculatedModelNodeList();     }  }using System; using System.Collections.Concurrent; using System.ComponentModel; using System.Linq; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using DevExpress.Persistent.Base;   namespace Xpand.Extensions.XAF.ModelExtensions.Shapes{               public interface IModelObjectViewDependency:IModelNode{         [Required][DataSourceProperty(nameof(ObjectViews))]         IModelObjectView ObjectView{ get; set; }         [Browsable(false)]         IModelList<IModelObjectView> ObjectViews{ get; }     }     [DomainLogic(typeof(IModelObjectViewDependency))]     public static class ModelObjectViewDependencyLogic {         public static readonly ConcurrentDictionary<Type,Type> ObjectViewsMap=new();          public static void AddObjectViewMap(Type modelType,Type entityType )              => ObjectViewsMap.TryAdd(modelType, entityType);          public static IModelList<IModelObjectView> Get_ObjectViews(this IModelObjectViewDependency dependency){             var key = ObjectViewsMap.Keys.First(type => type.IsInstanceOfType(dependency.Parent.Parent));             return new CalculatedModelNodeList<IModelObjectView>(dependency.Application.Views.OfType<IModelObjectView>()                 .Where(view =>!view.ModelClass.TypeInfo.IsAbstract&& ObjectViewsMap[key].IsAssignableFrom(view.ModelClass.TypeInfo.Type)));         }       } }using System; using System.IO; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.XAF.ModuleExtensions{     public static partial class ModulebaseExtensions{         public static void AddModulesFromPath(this ModuleBase module,string pattern){             var moduleTypes = Directory.GetFiles(AppDomain.CurrentDomain.ApplicationPath(), pattern)                 .Select(System.Reflection.Assembly.LoadFile)                 .SelectMany(assembly => assembly.GetTypes()).Where(type =>!type.IsAbstract&& typeof(ModuleBase).IsAssignableFrom(type));             module.RequiredModuleTypes.AddRange(moduleTypes);         }      }  }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.AssemblyExtensions; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.XAF.ModuleExtensions{     public static partial class ModulebaseExtensions{         public static IEnumerable<(string id,string model)> EmbeddedModels(this ModuleBase module){             var assembly = module.GetType().Assembly;             var defaultModelName = $"{ModelStoreBase.ModelDiffDefaultName}.xafml";             return assembly.GetName().PublicKeyToken() != AssemblyInfo.PublicKeyToken                 ? assembly.GetManifestResourceNames().Where(s => s.EndsWith(".xafml"))                     .Where(s => !s.EndsWith(defaultModelName))                     .Select(s => (id:s,model:assembly.GetManifestResourceStream(s).ReadToEnd()))                 : Enumerable.Empty<(string id,string model)>();         }     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.NonPersistentObjects {     [DomainComponent]     [XafDefaultProperty(nameof(Key))]     public class KeyValuePairObject:NonPersistentBaseObject {         public KeyValuePairObject(KeyValuePair<string, string> pair) {             Key = pair.Key;             Value = pair.Value;         }          private string _key;         private string _value;          public string Key {             get => _key;             set {                 if (value == _key) return;                 _key = value;                 OnPropertyChanged();             }         }          public string Value {             get => _value;             set {                 if (value == _value) return;                 _value = value;                 OnPropertyChanged();             }         }          public KeyValuePairObject(string key) {             Key = key;         }      }      public static class KeyValuePairObjectExtensions {         public static IEnumerable<KeyValuePairObject> ToKeyValuePairObjects(this  Dictionary<string,string> source)              => source.Select(pair => new KeyValuePairObject(pair));     }   }#if XAF192 using DevExpress.ExpressApp.Data; using DevExpress.ExpressApp.DC; using DevExpress.Persistent.Base; using System; using System.Collections.Generic; using System.ComponentModel; using System.Linq; using System.Runtime.CompilerServices; namespace DevExpress.ExpressApp { 	public interface ICustomPropertyStore { 		object GetCustomPropertyValue(IMemberInfo memberInfo); 		bool SetCustomPropertyValue(IMemberInfo memberInfo, object value); 		bool UpdateCalculatedPropertiesOnChanged { get; set; } 	} 	[DomainComponent] 	[EditorBrowsable(EditorBrowsableState.Never)] 	public abstract class NonPersistentEntityObject : IXafEntityObject, INotifyPropertyChanged, ICustomPropertyStore { 		[Browsable(false), EditorBrowsable(EditorBrowsableState.Never)] 		public static Boolean DefaultUpdateCalculatedPropertiesOnChanged = true; 		private static Dictionary<Type, object> defaultValues; 		private Boolean updateCalculatedPropertiesOnChanged = DefaultUpdateCalculatedPropertiesOnChanged; 		private Dictionary<IMemberInfo, object> customPropertyStore; 		private Lazy<ITypeInfo> typeInfo; 		public NonPersistentEntityObject() { 			typeInfo = new Lazy<ITypeInfo>(GetTypeInfo); 		} 		protected virtual ITypeInfo GetTypeInfo() { 			return XafTypesInfo.Instance.FindTypeInfo(GetType()); 		} 		#region IXafEntityObject 		public virtual void OnCreated() { 		} 		public virtual void OnSaving() { 		} 		public virtual void OnLoaded() { 		} 		#endregion 		#region INotifyPropertyChanged 		protected virtual void OnPropertyChanged(String propertyName) { 			PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); 		} 		protected bool SetPropertyValue<T>(ref T propertyValue, T newValue, [CallerMemberName]string propertyName = null) { 			if(EqualityComparer<T>.Default.Equals(propertyValue, newValue)) { 				return false; 			} 			propertyValue = newValue; 			OnPropertyChanged(propertyName); 			return true; 		} 		public event PropertyChangedEventHandler PropertyChanged; 		#endregion 		#region ICustomPropertyStore 		private Dictionary<IMemberInfo, object> CustomPropertyStore { 			get { 				if(customPropertyStore == null) 					customPropertyStore = new Dictionary<IMemberInfo, object>(); 				return customPropertyStore; 			} 		} 		private object CreateDefValue(IMemberInfo memberInfo) { 			object result = null; 			if(memberInfo.MemberTypeInfo.IsValueType) { 				if (defaultValues == null) { 					defaultValues = new Dictionary<Type, object>(); 				} 				if(!defaultValues.TryGetValue(memberInfo.MemberType, out result)) { 					result = Activator.CreateInstance(memberInfo.MemberType); 					defaultValues[memberInfo.MemberType] = result; 				} 			} 			return result; 		} 		private object GetCustomPropertyValue(IMemberInfo memberInfo) { 			object theValue = null; 			if(customPropertyStore != null) { 				customPropertyStore.TryGetValue(memberInfo, out theValue); 			} 			if(theValue == null) { 				theValue = CreateDefValue(memberInfo); 				if(theValue != null) { 					CustomPropertyStore[memberInfo] = theValue; 				} 			} 			return theValue; 		} 		object ICustomPropertyStore.GetCustomPropertyValue(IMemberInfo memberInfo) { 			return GetCustomPropertyValue(memberInfo); 		} 		bool ICustomPropertyStore.SetCustomPropertyValue(IMemberInfo memberInfo, object value) { 			object oldValue = GetCustomPropertyValue(memberInfo); 			if(CanSkipAssignment(oldValue, value)) { 				return false; 			} 			if(ReferenceEquals(value, null)) { 				CustomPropertyStore.Remove(memberInfo); 			} 			else { 				CustomPropertyStore[memberInfo] = value; 			} 			OnPropertyChanged(memberInfo.Name); 			return true; 		} 		private bool CanSkipAssignment(object oldValue, object newValue) { 			if(ReferenceEquals(oldValue, newValue)) 				return true; 			else if(oldValue is ValueType && newValue is ValueType && Equals(oldValue, newValue)) 				return true; 			else if(oldValue is string && newValue is string && Equals(oldValue, newValue)) 				return true; 			else 				return false; 		} 		public void SetMemberValue(string propertyName, object newValue) { 			typeInfo.Value.FindMember(propertyName).SetValue(this, newValue); 		} 		public object GetMemberValue(string propertyName) { 			return typeInfo.Value.FindMember(propertyName).GetValue(this); 		} 		protected Boolean UpdateCalculatedPropertiesOnChanged { 			get { return updateCalculatedPropertiesOnChanged; } 			set { updateCalculatedPropertiesOnChanged = value; } 		} 		Boolean ICustomPropertyStore.UpdateCalculatedPropertiesOnChanged { 			get { return UpdateCalculatedPropertiesOnChanged; } 			set { UpdateCalculatedPropertiesOnChanged = value; } 		} 		#endregion 	} 	[DomainComponent] 	[EditorBrowsable(EditorBrowsableState.Never)] 	public abstract class NonPersistentObjectImpl : NonPersistentEntityObject, IObjectSpaceLink { 		private IObjectSpace objectSpace; 		protected override ITypeInfo GetTypeInfo() { 			return (ObjectSpace != null) ? ObjectSpace.TypesInfo.FindTypeInfo(GetType()) : base.GetTypeInfo(); 		} 		#region IObjectSpaceLink 		protected virtual void OnObjectSpaceChanging() { 		} 		protected virtual void OnObjectSpaceChanged() { 		} 		protected IObjectSpace ObjectSpace { 			get { return objectSpace; } 			set { 				if(objectSpace != value) { 					OnObjectSpaceChanging(); 					objectSpace = value; 					OnObjectSpaceChanged(); 				} 			} 		} 		IObjectSpace IObjectSpaceLink.ObjectSpace { 			get { return ObjectSpace; } 			set { ObjectSpace = value; } 		} 		#endregion 	} 	[DomainComponent] 	public abstract class NonPersistentBaseObject : NonPersistentObjectImpl { 		private Guid oid; 		public NonPersistentBaseObject() { 			this.oid = Guid.NewGuid(); 		} 		public NonPersistentBaseObject(Guid oid) { 			this.oid = oid; 		} 		[Key] 		[VisibleInListView(false), VisibleInDetailView(false), VisibleInLookupListView(false)] 		public Guid Oid { 			get { return oid; } 		} 	} 	[DomainComponent] 	public abstract class NonPersistentLiteObject : NonPersistentEntityObject { 		private Guid oid; 		public NonPersistentLiteObject() { 			this.oid = Guid.NewGuid(); 		} 		public NonPersistentLiteObject(Guid oid) { 			this.oid = oid; 		} 		[Key] 		[VisibleInListView(false), VisibleInDetailView(false), VisibleInLookupListView(false)] 		public Guid Oid { 			get { return oid; } 		} 	} } #endifusing System; using System.ComponentModel; using System.Diagnostics.CodeAnalysis; using System.Runtime.CompilerServices; using System.Text.Json.Serialization; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC;  using Xpand.Extensions.XAF.Attributes; using Xpand.Extensions.XAF.TypesInfoExtensions;  namespace Xpand.Extensions.XAF.NonPersistentObjects {     public abstract class NonPersistentBaseObject:DevExpress.ExpressApp.NonPersistentBaseObject,IReloadWhenChange {         public event EventHandler<EventArgs> ObjectSpaceChanged;         private bool _isDefaultPropertyAttributeInit;         private IMemberInfo _defaultPropertyMemberInfo;                  [SuppressMessage("ReSharper", "OptionalParameterHierarchyMismatch")]         protected override void OnPropertyChanged([CallerMemberName] string memberName = "") => base.OnPropertyChanged(memberName);          [Browsable(false)][JsonIgnore]         public new IObjectSpace ObjectSpace => base.ObjectSpace;          public override string ToString() {             if(!_isDefaultPropertyAttributeInit) {                 string defaultPropertyName = string.Empty;                 var info = XafTypesInfo.Instance.FindTypeInfo(GetType());                 var xafDefaultPropertyAttribute = info.FindAttribute<XafDefaultPropertyAttribute>();                 if(xafDefaultPropertyAttribute != null) {                     defaultPropertyName = xafDefaultPropertyAttribute.Name;                 } else {                     var defaultPropertyAttribute = info.FindAttribute<DefaultPropertyAttribute>();                     if(defaultPropertyAttribute != null) {                         defaultPropertyName = defaultPropertyAttribute.Name;                     }                 }                 if(!string.IsNullOrEmpty(defaultPropertyName)) {                     _defaultPropertyMemberInfo = GetType().ToTypeInfo().FindMember(defaultPropertyName);                 }                 _isDefaultPropertyAttributeInit = true;             }             if(_defaultPropertyMemberInfo != null) {                 try {                     return _defaultPropertyMemberInfo.GetValue(this)?.ToString();                 }                 catch {                     // ignored                 }             }              return base.ToString();         }                  protected bool SetPropertyValue<T>(string propertyName ,ref T propertyValue, T newValue )              => base.SetPropertyValue(ref propertyValue, newValue, propertyName);          protected override void OnObjectSpaceChanged() {             base.OnObjectSpaceChanged();             if (ObjectSpace != null) {                 OnObjectSpaceChanged(EventArgs.Empty);                 }         }          protected virtual void OnObjectSpaceChanged(EventArgs e) => ObjectSpaceChanged?.Invoke(this, e);                   Action<string> IReloadWhenChange.WhenPropertyChanged => OnPropertyChanged;     }  }using System; using System.Collections.Generic; using System.ComponentModel; using DevExpress.ExpressApp.DC; using DevExpress.Persistent.Base; using Xpand.Extensions.XAF.Attributes;  namespace Xpand.Extensions.XAF.NonPersistentObjects {      [XafDefaultProperty(nameof(Caption))]     [DomainComponent]     public class ObjectString:NonPersistentBaseObject ,ICheckedListBoxItemsProvider {                           public event EventHandler<CheckListboxItemsProviderArgs> CheckedListBoxItems;          public ObjectString(string name) {             Name = name;             Caption = name;                      }          public ObjectString() {             _instance = this;         }         [Browsable(false)]         public object Owner { get; set; }         ObjectString _instance;         [DataSourceProperty(nameof(DataSource))]         [DisplayName("Name")][VisibleInListView(false)][VisibleInLookupListView(false)]         public ObjectString Instance {             get => _instance;             set => SetPropertyValue(ref _instance, value);         }          string _name;         // [DevExpress.ExpressApp.Data.Key]         [InvisibleInAllViews]         public string Name {             get => _name;             set => SetPropertyValue(ref _name, value);         }          string _caption;                  [VisibleInDetailView(false)]         [DisplayName("Name")]         public string Caption {             get => _caption;             set => SetPropertyValue(ref _caption, value);         }          protected override void OnPropertyChanged(string memberName = "") {             base.OnPropertyChanged(memberName);             if (memberName == nameof(Instance)) {                 Caption = Instance?.Caption;                 Name = Instance?.Name;             }         }          public static implicit operator string(ObjectString objectString) {             return objectString?.Name;         }          public Dictionary<object, string> GetCheckedListBoxItems(string targetMemberName) {             var args = new CheckListboxItemsProviderArgs(targetMemberName);             OnCheckedListBoxItems(args);             return args.Objects;         }          public event EventHandler ItemsChanged;          protected virtual void OnItemsChanged() => ItemsChanged?.Invoke(this, EventArgs.Empty);          protected virtual void OnCheckedListBoxItems(CheckListboxItemsProviderArgs e) => CheckedListBoxItems?.Invoke(this, e);          [Browsable(false)] public IList<ObjectString> DataSource { get; } = new List<ObjectString>();           // [Browsable(false)] public Type DataSourceType { get; } = typeof(ObjectString);          // public void SetDatasource(IList objectStrings) => DataSource=objectStrings;     }      public class CheckListboxItemsProviderArgs:EventArgs {         public string TargetMemberName { get; }          public CheckListboxItemsProviderArgs(string targetMemberName) {             TargetMemberName = targetMemberName;             Objects = new Dictionary<object, string>();         }          public Dictionary<object, string> Objects { get;  }     }    }using System; using System.ComponentModel; using System.Runtime.Serialization; using DevExpress.ExpressApp.DC; using Xpand.Extensions.StringExtensions; using Xpand.Extensions.XAF.Attributes; using Xpand.Extensions.XAF.ObjectExtensions;  namespace Xpand.Extensions.XAF.NonPersistentObjects {     [DomainComponent]     [DefaultProperty(nameof(Name))]     public class ObjectType:NonPersistentBaseObject{         private string _name;         private Type _type;          public ObjectType(Type type) {             Type = type;             Name = type?.Name.CompoundName();         }          // [DevExpress.ExpressApp.Data.Key]         [VisibleInAllViews]         // [IgnoreDataMember]         public string Name {             get => _name;             set {                 if (value == _name) return;                 _name = value;                 OnPropertyChanged();             }         }          [Browsable(false)]         public Type Type {             get => _type;             set {                 if (value == _type) return;                 _type = value;                 OnPropertyChanged();             }         }     } }using System.Collections; using System.Linq; using DevExpress.ExpressApp.Utils; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.StringExtensions;  namespace Xpand.Extensions.XAF.ObjectExtensions{     public static partial class ObjectExtensions{         public static string CompoundName(this object obj)              => ((IEnumerable)obj?.ToString().EnsureEndWith("").Split('.')                 .Select(s => CaptionHelper.ConvertCompoundName(s.Split('_').Select(s1 => s1.FirstCharacterToUpper())                     .JoinString())).ToArray()).Join(".");     } }using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Utils;  namespace Xpand.Extensions.XAF.ObjectExtensions{     public static partial class ObjectExtensions{         public static ITypeInfo GetTypeInfo(this object obj) => obj != null ? XafTypesInfo.Instance.FindTypeInfo(obj.GetType()) : null;     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectExtensions {     public static partial class ObjectExtensions {         public static object KeyValue(this IObjectSpaceLink source)             => source.ObjectSpace.GetKeyValue(source);         public static T KeyValue<T>(this IObjectSpaceLink source)             => (T)source.ObjectSpace.GetKeyValue(source);     } }using System.Collections.Concurrent; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.ObjectExtensions {     public static partial class ObjectExtensions {         public static Dictionary<object, T> ToBODictionary<T>(this IEnumerable<T> source) where T : IObjectSpaceLink              => source.ToDictionary(link => link.KeyValue(), link => link);          public static Dictionary<TKey, TLink> ToDictionary<TKey,TLink>(this IEnumerable<TLink> source) where TLink : IObjectSpaceLink              => source.ToDictionary(link => link.KeyValue<TKey>(), link => link);          public static Dictionary<string, TLink> ToStringDictionary<TLink>(this IEnumerable<TLink> source,             IEqualityComparer<string> comparer=null) where TLink : IObjectSpaceLink              => source.ToDictionary(link => link.KeyValue<string>(), link => link,comparer);                  public static ConcurrentDictionary<object, T> ToBOConcurrentDictionary<T>(this IEnumerable<T> source) where T : IObjectSpaceLink              => source.ToConcurrentDictionary(link => link.KeyValue(), link => link);          public static ConcurrentDictionary<TKey, TLink> ToConcurrentDictionary<TKey,TLink>(this IEnumerable<TLink> source) where TLink : IObjectSpaceLink              => source.ToConcurrentDictionary(link => link.KeyValue<TKey>(), link => link);              } }using System; using DevExpress.ExpressApp; using Fasterflect; using Xpand.Extensions.XAF.NonPersistentObjects;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static IObjectSpace AdditionalObjectSpace(this IObjectSpace objectSpace, Type type)             => (IObjectSpace)objectSpace.CallMethod("GetCertainObjectSpace", type);     } }using System; using DevExpress.ExpressApp; using Fasterflect; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {          public static partial class ObjectSpaceExtensions {         public static NonPersistentObjectSpace AsNonPersistentObjectSpace(this IObjectSpace objectSpace)             => objectSpace as NonPersistentObjectSpace;         public static NonPersistentObjectSpace ToNonPersistentObjectSpace(this IObjectSpace objectSpace)             => objectSpace.Cast<NonPersistentObjectSpace>();     } }using System; using DevExpress.ExpressApp; using DevExpress.Persistent.Validation;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static void CommitChangesAndValidate(this IObjectSpace objectSpace) {             var ruleSetValidationResult =                 Validator.RuleSet.ValidateAllTargets(objectSpace, objectSpace.ModifiedObjects, ContextIdentifier.Save);             if (ruleSetValidationResult.ValidationOutcome == ValidationOutcome.Error)                 throw new Exception(ruleSetValidationResult.GetFormattedErrorMessage());             objectSpace.CommitChanges();         }     } }using System.Data; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static IDbCommand CreateCommand(this IObjectSpace objectSpace)             => !(objectSpace is BaseObjectSpace baseObjectSpace) ? null : baseObjectSpace.Connection.CreateCommand();     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.Data; using System.Diagnostics.CodeAnalysis; using System.Linq; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using Xpand.Extensions.XAF.TypesInfoExtensions;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static T EnsureObjectByKey<T>(this IObjectSpace objectSpace, object key,bool inTransaction=false)             => objectSpace.GetObjectByKey<T>(key)??objectSpace.EnsureInTransaction<T>(key,inTransaction) ?? objectSpace.NewObject<T>(key);                  public static T EnsureObject<T>(this IObjectSpace objectSpace, Expression<Func<T, bool>> criteriaExpression,Action<T> initialize=null,Action<T> update=null,bool inTransaction=false) where T : class {             var o = objectSpace.FirstOrDefault(criteriaExpression,inTransaction);             if (o != null) {                 update?.Invoke(o);                 return o;             }             var ensureObject = objectSpace.CreateObject<T>();             initialize?.Invoke(ensureObject);             update?.Invoke(ensureObject);             return ensureObject;         }          public static T EnsureObject<T>(this IObjectSpace space, Dictionary<string, T> dictionary, string id){             var ensureObject = dictionary.GetValueOrDefault(id);             if (ensureObject == null) {                 ensureObject = space.CreateObject<T>();                 if (ensureObject == null) {                     throw new NoNullAllowedException(typeof(T).FullName);                 }                 dictionary.Add(id, ensureObject);             }             else {                 if (!space.IsNewObject(ensureObject)){                     ensureObject = space.GetObjectFromKey(ensureObject);                     if (ensureObject == null) {                         throw new NoNullAllowedException(typeof(T).Name);                     }                 }             }             return ensureObject;         }         [SuppressMessage("ReSharper", "HeapView.CanAvoidClosure")]         public static T EnsureObject<T>(this IObjectSpace space, ConcurrentDictionary<string, T> dictionary, string id) {             var add = dictionary.GetOrAdd(id, _ => {                 var o = space.CreateObject<T>();                 typeof(T).ToTypeInfo().KeyMember.SetValue(o,id);                 return o;             });             return space.IsNewObject(add)?add: space.GetObject(add);         }          public static T EnsureObject<T>(this IObjectSpace objectSpace, CriteriaOperator criteria,Action<T> initialize=null,bool inTransaction=false) where T : class {             var o = objectSpace.FindObject<T>(criteria,inTransaction);             if (o != null) {                 return o;             }             var ensureObject = objectSpace.CreateObject<T>();             initialize?.Invoke(ensureObject);             return ensureObject;         }                  private static T EnsureInTransaction<T>(this IObjectSpace objectSpace,object key,bool inTransaction)              => inTransaction ? objectSpace.GetObjects<T>(CriteriaOperator                     .Parse($"{objectSpace.TypesInfo.FindTypeInfo(typeof(T)).KeyMember.Name}=?", key), true)                 .FirstOrDefault() : default;          public static object EnsureObjectByKey(this IObjectSpace objectSpace, Type objectType, object key) {             if (objectSpace.GetObjectByKey(objectType, key) != null)                 return objectSpace.GetObjectByKey(objectType, key);             var ensureObjectByKey = objectSpace.CreateObject(objectType);             objectType.ToTypeInfo().KeyMember.SetValue(ensureObjectByKey,key);             return ensureObjectByKey;         }     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using Xpand.Extensions.ExpressionExtensions;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static object Evaluate(this IObjectSpace objectSpace, Type objectType, string field,             Aggregate aggregate, CriteriaOperator filter = null)             => objectSpace.Evaluate(objectType, CriteriaOperator.Parse($"{aggregate}({field})"), filter);                  public static object Evaluate<T>(this IObjectSpace objectSpace,  Expression<Func<T,object>> field,             Aggregate aggregate, Func<Expression<Func<T, bool>>> filter = null) {             filter ??= () => arg => true;             return objectSpace.Evaluate(typeof(T), CriteriaOperator.Parse($"{aggregate}({field.MemberExpressionName()})"), CriteriaOperator.FromLambda(filter()));         }     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static int ExecuteNonQueryCommand(this IObjectSpace objectSpace, string commandText) {             using var command = objectSpace.CreateCommand();             command.CommandText = commandText;             return command.ExecuteNonQuery();         }     } }using System.Data; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static IDataReader ExecuteReaderCommand(this IObjectSpace objectSpace, string commandText) {             using var command = objectSpace.CreateCommand();             command.CommandText = commandText;             return command.ExecuteReader();         }     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static object ExecuteScalarCommand(this IObjectSpace objectSpace, string commandText) {             using var command = objectSpace.CreateCommand();             command.CommandText = commandText;             return command.ExecuteScalar();         }     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static T GetObject<T>(this T link, IObjectSpace objectSpace)             => objectSpace.GetObject(link);         public static T GetObject<T>(this T link, IObjectSpaceLink objectSpaceLink)             => link.GetObject(objectSpaceLink.ObjectSpace);         public static T GetObjectFromKey<T>(this IObjectSpace objectSpace, T instance)             => (T)objectSpace.GetObjectByKey(instance.GetType(), objectSpace.GetKeyValue(instance));     } }using System.Linq; using DevExpress.Data.Filtering; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static bool IsObjectFitForCriteria(this IObjectSpace objectSpace,CriteriaOperator criteria,params object[] objects)              => ReferenceEquals(criteria, null) || objects.All(o => {                 var isObjectFitForCriteria = objectSpace.IsObjectFitForCriteria(o, criteria);                 return isObjectFitForCriteria.HasValue && isObjectFitForCriteria.Value;             });          public static bool Match(this IObjectSpaceLink objectSpaceLink, CriteriaOperator criteria)             => objectSpaceLink.ObjectSpace.IsObjectFitForCriteria(criteria, objectSpaceLink);         public static bool Match(this IObjectSpaceLink objectSpaceLink, string criteria)             => objectSpaceLink.Match(objectSpaceLink.ObjectSpace.ParseCriteria(criteria));     } }using System; using System.Linq; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static bool Any<T>(this IObjectSpace objectSpace) => objectSpace.GetObjectsQuery<T>().Any();          public static object NewObject(this IObjectSpace objectSpace,Type type, object key) {             var o = objectSpace.CreateObject(type);             objectSpace.TypesInfo.FindTypeInfo(type).KeyMember.SetValue(o, key);             return o;         }          public static T NewObject<T>(this IObjectSpace objectSpace, object key) {             var o = objectSpace.CreateObject<T>();             objectSpace.TypesInfo.FindTypeInfo(typeof(T)).KeyMember.SetValue(o, key);             return o;         }               } }using DevExpress.ExpressApp; using Xpand.Extensions.XAF.NonPersistentObjects;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static ObjectString NewObjectString(this IObjectSpace objectSpace, string name, string caption = null) {             var objectString = objectSpace.CreateObject<ObjectString>();             objectString.Name = name;             objectString.Caption = caption ?? name;             return objectString;         }     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static T ReloadObject<T>(this T objectSpaceLink) where T:IObjectSpaceLink             => (T)objectSpaceLink.ObjectSpace.ReloadObject(objectSpaceLink);     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static void RemoveFromModifiedObjects(this IObjectSpaceLink objectSpaceLink)             => objectSpaceLink.ObjectSpace.RemoveFromModifiedObjects(objectSpaceLink);     } } using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static void SetIsModified(this IObjectSpace objectSpace, bool value)             => objectSpace.CallMethod(nameof(SetIsModified), value);     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static IEnumerable<IObjectSpace> YieldAll(this IObjectSpace objectSpace)             => objectSpace is not CompositeObjectSpace compositeObjectSpace                 ? objectSpace.YieldItem()                 : objectSpace.YieldItem().Concat(compositeObjectSpace.AdditionalObjectSpaces);     } }using DevExpress.ExpressApp; using Fasterflect;  using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.ObjectSpaceProviderExtensions{     public static class ObjectSpaceProviderExtensions{         public static string GetConnectionString(this IObjectSpaceProvider objectSpaceProvider){             var connection = objectSpaceProvider.GetPropertyValue("DataLayer")?.GetPropertyValue("Connection");             return (string) (connection != null ? connection.GetPropertyValue("ConnectionString")                 : objectSpaceProvider.GetPropertyValue("DataStoreProvider").GetPropertyValue("ConnectionString"));         }          public static bool IsMiddleTier(this IObjectSpaceProvider objectSpaceProvider)             => objectSpaceProvider.IsInstanceOf("DevExpress.ExpressApp.Security.ClientServer.MiddleTierServerObjectSpaceProvider");      } }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.XAF")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.XAF")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.Security; using Fasterflect; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static ISecurityStrategyBase[] AddAnonymousType(this ISecurityStrategyBase securityStrategy, params Type[] types)              => securityStrategy.AddAnonymousTypeCore(types).ToArray();          static IEnumerable<ISecurityStrategyBase> AddAnonymousTypeCore(             this ISecurityStrategyBase securityStrategy, params Type[] types) {             foreach (var strategyBase in securityStrategy.WhenSecurityStrategy()) {                 var anonymousAllowedTypes = strategyBase.GetPropertyValue("AnonymousAllowedTypes");                 strategyBase.SetPropertyValue("AllowAnonymousAccess", true);                 foreach (var type in types) {                     anonymousAllowedTypes.CallMethod("Add", type);                 }                  yield return strategyBase;             }         }     } }using System; using System.Collections.Generic; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Security; using DevExpress.ExpressApp.Updating; using DevExpress.Persistent.Base; using Fasterflect;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static void AddDefaultSecurityObjects(this ModuleUpdater updater,Func<ISecurityUserWithRoles,IEnumerable<IPermissionPolicyRole>> roles=null) {             var objectSpace = (IObjectSpace)updater.GetPropertyValue("ObjectSpace");             var sampleUser = objectSpace.GetUser("User");             var defaultRole = objectSpace.GetDefaultRole();             roles ??= (withRoles => (IEnumerable<IPermissionPolicyRole>) withRoles.GetPropertyValue("Roles"));              roles(sampleUser).CallMethod("Add", defaultRole);              var userAdmin = objectSpace.GetUser("Admin");             roles(userAdmin).CallMethod("Add", objectSpace.GetAdminRole("Administrators"));         }     } }using System; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using DevExpress.Persistent.Base; using Fasterflect;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static IPermissionPolicyRole GetAdminRole(this IObjectSpace objectSpace, string roleName) {             var roleType = (Type) SecuritySystem.Instance.GetPropertyValue("RoleType");             var administratorRole =                 (IPermissionPolicyRole) objectSpace.FindObject(roleType, new BinaryOperator("Name", roleName));             if (administratorRole == null) {                 administratorRole = (IPermissionPolicyRole) objectSpace.CreateObject(roleType);                 administratorRole.Name = roleName;                 administratorRole.IsAdministrative = true;             }              return administratorRole;         }     } }using System; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Security; using DevExpress.Persistent.Base; using Fasterflect;  using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.XAF.SecurityExtensions {          public static partial class SecurityExtensions {         private static readonly Type PermissionSettingHelperType;         private static readonly Type ActionPermissionRequest;         private static readonly Type AdministrativePermissionRequest;          static SecurityExtensions() {             PermissionSettingHelperType = AppDomain.CurrentDomain.GetAssemblyType("DevExpress.ExpressApp.Security.PermissionSettingHelper");             ActionPermissionRequest = AppDomain.CurrentDomain.GetAssemblyType("DevExpress.ExpressApp.Security.ActionPermissionRequest");             AdministrativePermissionRequest = AppDomain.CurrentDomain.GetAssemblyType("DevExpress.ExpressApp.Security.AdministrativePermissionRequest");         }                   public static IPermissionPolicyRole GetDefaultRole(this IObjectSpace objectSpace) => objectSpace.GetDefaultRole("Default");          public static IPermissionPolicyRole GetDefaultRole(this IObjectSpace objectSpace, string roleName) {             var defaultRole = objectSpace.GetRole(roleName);             if (objectSpace.IsNewObject(defaultRole)) {                 defaultRole.AddObjectPermission(SecuritySystem.UserType,SecurityOperations.ReadOnlyAccess, "[Oid] = CurrentUserId()", SecurityPermissionState.Allow);                 defaultRole.AddNavigationPermission(@"Application/NavigationItems/Items/Default/Items/MyDetails", SecurityPermissionState.Allow);                 defaultRole.AddMemberPermission(SecuritySystem.UserType,SecurityOperations.ReadWriteAccess, "ChangePasswordOnFirstLogon; StoredPassword", null, SecurityPermissionState.Allow);                 defaultRole.AddMemberPermission(SecuritySystem.UserType,SecurityOperations.Write, "StoredPassword", "[Oid] = CurrentUserId()", SecurityPermissionState.Allow);                 defaultRole.AddTypePermissionsRecursively(defaultRole.GetType(),SecurityOperations.Read, SecurityPermissionState.Deny);                 var modelDifferenceType = AppDomain.CurrentDomain.GetAssemblyType("DevExpress.Persistent.BaseImpl.ModelDifference");                 var modelDifferenceAspectType = AppDomain.CurrentDomain.GetAssemblyType("DevExpress.Persistent.BaseImpl.ModelDifferenceAspect");                 defaultRole.AddTypePermissionsRecursively(modelDifferenceType,SecurityOperations.Read, SecurityPermissionState.Deny);                 defaultRole.AddTypePermissionsRecursively(modelDifferenceAspectType,SecurityOperations.Read, SecurityPermissionState.Deny);                 defaultRole.AddTypePermissionsRecursively(modelDifferenceType,SecurityOperations.Create, SecurityPermissionState.Allow);                 defaultRole.AddTypePermissionsRecursively(modelDifferenceAspectType,SecurityOperations.Create, SecurityPermissionState.Allow);             }             return defaultRole;         }          static void AddTypePermissionsRecursively(this IPermissionPolicyRole role, Type targetType, string operations, SecurityPermissionState? state)             => PermissionSettingHelperType.Method(nameof(AddTypePermissionsRecursively), new[] {typeof(IPermissionPolicyRole), typeof(Type), typeof(string), typeof(SecurityPermissionState?),typeof(ITypesInfo)}, Flags.StaticPublic)                 .Call(null,role, targetType, operations, state,XafTypesInfo.Instance);          static IPermissionPolicyMemberPermissionsObject AddMemberPermission(this IPermissionPolicyRole role,             Type type, string operations, string members, string criteria, SecurityPermissionState? state)              => (IPermissionPolicyMemberPermissionsObject) PermissionSettingHelperType                 .Method(nameof(AddMemberPermission),                     new[] {typeof(IPermissionPolicyRole), typeof(Type), typeof(string), typeof(string), typeof(string), typeof(SecurityPermissionState)                     }, Flags.StaticPublic).Call(null,role, type, operations, members, criteria, state);          static IPermissionPolicyNavigationPermissionObject AddNavigationPermission(             this IPermissionPolicyRole role, string itemPath, SecurityPermissionState? state)              => (IPermissionPolicyNavigationPermissionObject) PermissionSettingHelperType.Method(nameof(AddNavigationPermission),                     new []{typeof(IPermissionPolicyRole),typeof(string),typeof(SecurityPermissionState)},Flags.StaticPublic)                 .Call(null,role, itemPath, state);          static IPermissionPolicyObjectPermissionsObject AddObjectPermission(this IPermissionPolicyRole role, Type type, string operations, string criteria, SecurityPermissionState? state)             => (IPermissionPolicyObjectPermissionsObject) PermissionSettingHelperType                 .Method(nameof(AddObjectPermission), new[] {typeof(IPermissionPolicyRole), typeof(Type), typeof(string), typeof(string), typeof(SecurityPermissionState)}, Flags.StaticPublic)                 .Call(null, role, type, operations, criteria, state);                  public static IPermissionPolicyRole GetRole(this IObjectSpace objectSpace, string roleName) {             var roleType =(Type)SecuritySystem.Instance.GetPropertyValue("RoleType");             var securityDemoRole = (IPermissionPolicyRole) (objectSpace.FindObject(roleType, new BinaryOperator("Name", roleName))??objectSpace.CreateObject(roleType));             securityDemoRole.SetPropertyValue("Name", roleName);             return securityDemoRole;         }       } }using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Security; using Fasterflect;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static T GetCurrentUser<T>(this XafApplication application) => (T) application.Security.User;         public static T GetCurrentUser<T>(this ISecurityStrategyBase security) => (T) security.User;          public static ISecurityUserWithRoles GetUser(this IObjectSpace objectSpace, string userName,             string passWord = "", params ISecurityRole[] roles)              => (ISecurityUserWithRoles) objectSpace.FindObject(SecuritySystem.UserType, new BinaryOperator("UserName", userName)) ??                CreateUser(objectSpace, userName, passWord, roles);          public static ISecurityUserWithRoles CreateUser(this IObjectSpace objectSpace, string userName, string passWord, ISecurityRole[] roles) {             var user2 = (ISecurityUserWithRoles)objectSpace.CreateObject(SecuritySystem.UserType);             var typeInfo = objectSpace.TypesInfo.FindTypeInfo(user2.GetType());             typeInfo.FindMember("UserName").SetValue(user2, userName);             user2.CallMethod("SetPassword",new[]{typeof(string)}, passWord);             var roleCollection = typeInfo.FindMember("Roles").GetValue(user2);             foreach (var role in roles) {                 roleCollection.CallMethod("BaseAdd",role);             }             return user2;         }      } }using System.Linq; using DevExpress.ExpressApp.Security; using Fasterflect;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static bool IsActionPermissionGranted(this ISecurityStrategyBase strategyBase, params string[] actions)             => actions.ToList().All(action =>                 (bool) strategyBase.CallMethod("IsGranted", ActionPermissionRequest.CreateInstance(action)));     } }using DevExpress.ExpressApp.Security; using Fasterflect;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static bool IsAdminPermissionGranted(this ISecurityStrategyBase strategyBase)             => (bool) strategyBase.CallMethod("IsGranted", AdministrativePermissionRequest.CreateInstance());     } }using DevExpress.ExpressApp.Security; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static bool IsSecurityStrategyComplex(this ISecurityStrategyBase strategyBase) => strategyBase             .IsInstanceOf("DevExpress.ExpressApp.Security.SecurityStrategyComplex");     } }using System;  namespace Xpand.Extensions.XAF.SecurityExtensions{     [AttributeUsage(AttributeTargets.Class)]     public class NonSecuredTypeAttribute : Attribute{     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Security; using Xpand.Extensions.TypeExtensions;  namespace Xpand.Extensions.XAF.SecurityExtensions {     public static partial class SecurityExtensions {         public static IEnumerable<ISecurityStrategyBase> WhenSecurityStrategy(             this ISecurityStrategyBase securityStrategy)              => securityStrategy?.GetType().InheritsFrom("DevExpress.ExpressApp.Security.SecurityStrategy") == true                 ? new[] {securityStrategy}                 : Enumerable.Empty<ISecurityStrategyBase>();     } }using System; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {          public static void AddAttributeNotExists(this IBaseInfo baseInfo, Attribute attribute) {             if (baseInfo.FindAttributes<Attribute>().All(attribute1 => attribute1.Match(attribute))) {                 baseInfo.AddAttribute(attribute);             }         }     } }using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.Model; using Xpand.Extensions.XAF.Attributes.Custom;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static ICustomAttribute AddCustomAttribute(this IBaseInfo baseInfo, ICustomAttribute attribute) {             for (int index = 0; index < attribute.Name.Split(';').Length; index++) {                 string s = attribute.Name.Split(';')[index];                 var theValue = attribute.Value.Split(';')[index];                 baseInfo.AddAttribute(new ModelDefaultAttribute(s, theValue));             }              return attribute;         }     } }using System; using System.Collections.Generic; using System.Reflection; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static IEnumerable<Type> CollectExportedTypesFromAssembly(this Type type)             => type.Assembly.CollectExportedTypesFromAssembly();                  public static IEnumerable<Type> CollectExportedTypesFromAssembly(this Assembly assembly)             => ModuleHelper.CollectExportedTypesFromAssembly(assembly, type1 => type1.IsExportedType());     } }using DevExpress.ExpressApp.DC; using DevExpress.Persistent.Base;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static IMemberInfo FindDisplayableMember(this IMemberInfo memberInfo)              => ReflectionHelper.FindDisplayableMemberDescriptor(memberInfo);     } }using System; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; using DevExpress.ExpressApp.DC; using Xpand.Extensions.ExpressionExtensions; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.TypesInfoExtensions{ 	public static partial class TypesInfoExtensions { 		public static IEnumerable<IMemberInfo> Members<TAttribute>(this IEnumerable<(TAttribute attribute, IMemberInfo memberInfo)> source)  			=> source.Select(t => t.memberInfo); 		 		public static IEnumerable<(IMemberInfo info,object value)> MembersValue(this IEnumerable<IMemberInfo> source,object instance) 			=> source.Select(memberInfo => (memberInfo,value:memberInfo.GetValue(instance))); 		 		public static IEnumerable<(TAttribute attribute, IMemberInfo memberInfo)> AttributedMembers<TAttribute>(this IEnumerable<ITypeInfo> source)    			=> source.SelectMany(info => info.AttributedMembers<TAttribute>());  		public static IEnumerable<ITypeInfo> Types<TAttribute>(this IEnumerable<(TAttribute attribute, ITypeInfo typeInfo)> source)  			=> source.Select(t => t.typeInfo); 		 		public static IEnumerable<(TAttribute attribute, ITypeInfo typeInfo)> Attributed<TAttribute>(this IEnumerable<ITypeInfo> source)    			=> source.SelectMany(info => info.Attributed<TAttribute>()); 		 		public static IEnumerable<(TAttribute attribute, ITypeInfo typeInfo)> Attributed<TAttribute>(this IEnumerable<Type> source)    			=> source.Select(type => type.ToTypeInfo()).Attributed<TAttribute>(); 		 		public static IEnumerable<IMemberInfo> Members<TAttribute>(this IEnumerable<ITypeInfo> source)    			=> source.SelectMany(info => info.AttributedMembers<TAttribute>()).Members();  		public static IEnumerable<(TAttribute attribute,IMemberInfo memberInfo)> AttributedMembers<TAttribute>(this ITypeInfo info)   			=> info.Members.SelectMany(memberInfo => memberInfo.FindAttributes<Attribute>().OfType<TAttribute>().Select(attribute => (attribute, memberInfo))); 		 		public static IEnumerable<(TAttribute attribute,ITypeInfo typeInfo)> Attributed<TAttribute>(this ITypeInfo info,bool includeBaseTypes=false) { 			var infos = info.YieldItem(); 			if (includeBaseTypes) { 				infos = info.FromHierarchy(typeInfo => typeInfo.Base).Prepend(info); 			} 			return infos.Distinct().SelectMany(typeInfo => typeInfo.FindAttributes<Attribute>(includeBaseTypes).OfType<TAttribute>().Select(attribute => (attribute, info))); 		}  		public static IMemberInfo FindMember<T>(this ITypeInfo typeInfo,Expression<Func<T, object>> memberName)              => typeInfo.FindMember(memberName.MemberExpressionName()); 	} }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static IEnumerable<(TAttribute attribute, IMemberInfo info)> Members<TAttribute>(this ITypesInfo typesInfo) where TAttribute : Attribute             => typesInfo.PersistentTypes.SelectMany(info => info.Members).SelectMany(info => info.FindAttributes<TAttribute>().Select(attribute => (attribute, info)));     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static bool IsExportedType(this Type type) => ExportedTypeHelpers.IsExportedType(type);     } }using Xpand.Extensions.XAF.ObjectExtensions;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static bool IsPersistentType(this object instance) => instance.GetTypeInfo().IsPersistent;              } }using Swordfish.NET.Collections.Auxiliary; using Xpand.Extensions.XAF.ObjectExtensions;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static void MapTypeInfoOwnMembers(this object source, object target)             => source.GetTypeInfo().OwnMembers                 .ForEach(info => {                     var targetMember = target.GetTypeInfo().FindMember(info.Name);                     if (info.MemberType == targetMember?.MemberType) {                         targetMember?.SetValue(target, info.GetValue(source));                         }                 });     } }using System; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static void RemoveAttribute(this IBaseInfo info, Attribute attribute)              => ((BaseInfo) info).RemoveAttribute(attribute);     } }using System; using System.ComponentModel; using System.Diagnostics; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions{     public static partial class TypesInfoExtensions{ 	    public static bool RuntimeMode(this ITypesInfo typeInfo){             var devProcceses = new[]{".ExpressApp.ModelEditor", "devenv","Xpand.XAF.ModelEditor"};             var processName = Process.GetCurrentProcess().ProcessName;             var isInProccess = devProcceses.Any(s => processName.IndexOf(s, StringComparison.Ordinal) > -1);             return !isInProccess && LicenseManager.UsageMode != LicenseUsageMode.Designtime;         }     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions{     public static partial class TypesInfoExtensions{ 	    public static ITypeInfo ToTypeInfo(this Type type) => XafTypesInfo.Instance.FindTypeInfo(type); 	    public static IEnumerable<ITypeInfo> ToTypeInfo(this IEnumerable<Type> source) => source.Select(type => type.ToTypeInfo());     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions {     public static partial class TypesInfoExtensions {         public static object GetMemberValue(this IMemberInfo memberInfo, object instance) {             var value = memberInfo.GetValue(instance);             return memberInfo.MemberTypeInfo.IsDomainComponent ? memberInfo.MemberTypeInfo.KeyMember.GetValue(value) : value;         }                  public static IEnumerable<(string Name, object value)> NameValues(this IEnumerable<IMemberInfo> source, object instance)             => source.Values(instance).Select(t => (t.info.Name,t.value));                  public static IEnumerable<(IMemberInfo info, object value)> Values(this IEnumerable<IMemberInfo> source, object instance)             => source.Select(info => (info,value:info.GetValue(instance)));                  public static IEnumerable<string> ToDefaultValues(this IEnumerable<object> source, ITypeInfo typeInfo)             => source.Select(s =>typeInfo.IsDomainComponent? $"{typeInfo.DefaultMember.GetValue(s)}":$"{s}");     } }using System; using System.Linq; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.TypesInfoExtensions{ 	public static partial class TypesInfoExtensions{         public static Version XAFVersion(this ITypesInfo typesInfo)              => typeof(TypesInfoExtensions).Assembly.GetReferencedAssemblies().First(_ => _.Name.Contains("DevExpress")).Version; 	} }using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.ViewExtensions{ 	public static partial class ViewExtensions{ 		public static XafApplication Application(this CompositeView view) => (XafApplication) view.GetPropertyValue("Application"); 	} }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ViewExtensions{     public static partial class ViewExtensions{         public static DashboardView AsDashboardView(this View view) => view as DashboardView;     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ViewExtensions{     public static partial class ViewExtensions{ 	    public static DetailView AsDetailView(this View view) => view as DetailView; 	    public static DetailView ToDetailView(this View view) => (DetailView)view;     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ViewExtensions{     public static partial class ViewExtensions{         public static ListView AsListView(this View view) => view as ListView;         public static ListView ToListView(this View view) => ((ListView)view);     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ViewExtensions{     public static partial class ViewExtensions{         public static ObjectView AsObjectView(this View view) => view as ObjectView;     } }using System.Drawing; using DevExpress.ExpressApp; using Fasterflect; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.ViewExtensions {     public static partial class ViewExtensions {         public static ListView HideWhenMasterDetail(this ListView listView) {             var container = listView.LayoutManager.Container;             var fixedPanel = container.GetPropertyValue("FixedPanel");             fixedPanel.SetPropertyValue("Visible",false);             var width = fixedPanel.GetPropertyValue("MinimumSize").Cast<Size>().Width;             fixedPanel.SetPropertyValue("Width",width);             return listView;         }     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.ViewExtensions {     public static partial class ViewExtensions {                  public static bool Is(this View view, ViewType viewType = ViewType.Any, Nesting nesting = Nesting.Any,             Type objectType = null){             objectType ??= typeof(object);             return FitsCore(view, viewType) && FitsCore(view, nesting) && objectType.IsAssignableFrom(view.ObjectTypeInfo?.Type);         }          private static bool FitsCore(View view, ViewType viewType)              => view != null && (viewType == ViewType.ListView                 ? view is ListView : viewType == ViewType.DetailView                     ? view is DetailView : viewType != ViewType.DashboardView || view is DashboardView);          private static bool FitsCore(View view, Nesting nesting)              => nesting == Nesting.Nested ? !view.IsRoot : nesting != Nesting.Root || view.IsRoot;     } }using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.XAF.CollectionSourceExtensions;  namespace Xpand.Extensions.XAF.ViewExtensions {     public static partial class ViewExtensions {         public static IEnumerable<T> Objects<T>(this View view)              => view is DetailView ? ((T)view.CurrentObject).YieldItem().ToArray()             : view.ToListView().CollectionSource.Objects<T>();                           public static IEnumerable<object> Objects(this View view) => view.Objects<object>();     } }using System; using System.Diagnostics.CodeAnalysis; using System.Linq; using System.Linq.Expressions; using DevExpress.ExpressApp; using Fasterflect; using HarmonyLib; using Xpand.Extensions.LinqExtensions; using Xpand.Extensions.XAF.Harmony;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{                  public static int Count<T>(this XafApplication application, Expression<Func<T,bool>> expression=null) where T:class {             using var objectSpace = application.CreateObjectSpace();             return objectSpace.GetObjectsQuery<T>().Count(expression ?? (arg => true));         }          public static T Module<T>(this XafApplication application) where T:ModuleBase => application.Modules.OfType<T>().FirstOrDefault();          public static void AddNonSecuredType(this XafApplication application,params Type[] objectTypes){             if (application.Security != null && application.Security.GetType().FromHierarchy(type => type.BaseType)                     .Any(type => type.Name == "SecurityStrategy")){                 new HarmonyMethod(typeof(XafApplicationExtensions),nameof(IsSecuredType))                     .PreFix(application.Security.GetType().Method("IsSecuredType",Flags.Static|Flags.Public),true);                 // application.Security.GetType().Method("IsSecuredType",Flags.Static|Flags.Public)                     // .PatchWith(new HarmonyMethod(typeof(XafApplicationExtensions),nameof(IsSecuredType)));                 foreach (var securedType in objectTypes){                     _securedTypes.Add(securedType);                    }             }         }                   [SuppressMessage("ReSharper", "InconsistentNaming")]         private static bool IsSecuredType(ref bool __result, Type type){             if (_securedTypes.Contains(type)){                 __result = false;                 return false;             }              return true;         }     } }using DevExpress.ExpressApp; using DevExpress.ExpressApp.Core; using Fasterflect;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{ 	public static partial class XafApplicationExtensions{ 		public static ControllersManager ControllersManager(this XafApplication application) => 			(ControllersManager) application.GetPropertyValue("ControllersManager"); 	} }using System; using System.Collections.Generic; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Core; using DevExpress.ExpressApp.Model; using Fasterflect;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{ 	public static partial class XafApplicationExtensions{ 		static Controller CreateController(this ControllersManager controllersManager, Type controllerType,IModelApplication modelApplication){ 			var registeredControllers = ((Dictionary<Type, Controller>) controllersManager.GetFieldValue("registeredControllers")); 			return registeredControllers.TryGetValue(controllerType, out var sourceController) 				? sourceController.Clone(modelApplication,ServiceProvider(controllersManager)) : (Controller) controllerType.CreateInstance(); 		}  		public static IServiceProvider ServiceProvider(this ControllersManager controllersManager)  			=> (IServiceProvider)controllersManager.GetFieldValue("serviceProvider");  		public static Controller CreateController(this XafApplication application, Type controllerType){ 			var controllersManager = application.ControllersManager(); 			var result = controllersManager == null 				? (Controller)controllerType.CreateInstance() 				: controllersManager.CreateController(controllerType, application.Model); 			result.Application = application; 			return result; 		} 	} }using System; using System.Linq; using System.Runtime.CompilerServices; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Security;  namespace Xpand.Extensions.XAF.XafApplicationExtensions {     public static partial class XafApplicationExtensions {         public static IObjectSpace CreateObjectSpace(this XafApplication application, Type objectType, bool nonSecuredObjectSpace)             => application.ObjectSpaceProviders(objectType)                 .Select(provider => nonSecuredObjectSpace ? (provider is INonsecuredObjectSpaceProvider nonsecuredObjectSpaceProvider                         ? nonsecuredObjectSpaceProvider.CreateNonsecuredObjectSpace() : provider.CreateUpdatingObjectSpace(false))                     : provider.CreateObjectSpace())                 .First();          public static IObjectSpace CreateNonSecuredObjectSpace(this XafApplication application,Type objectType)             => application.CreateObjectSpace(true ,objectType,true);          public static IObjectSpace CreateObjectSpace(this XafApplication application, bool useObjectSpaceProvider,Type type=null,bool nonSecuredObjectSpace=false,             [CallerMemberName] string caller = "") {             if (type != null) {                 if (type.IsArray) {                     type = type.GetElementType();                 }                 if (!XafTypesInfo.Instance.FindTypeInfo(type).IsPersistent) {                     throw new InvalidOperationException($"{caller} {type?.FullName} is not a persistent object");                 }             }             if (!useObjectSpaceProvider)                 return application.CreateObjectSpace(type ?? typeof(object));             var applicationObjectSpaceProvider = application.ObjectSpaceProviders(type ?? typeof(object)).First();             IObjectSpace objectSpace;             if (!nonSecuredObjectSpace) {                 objectSpace = applicationObjectSpaceProvider.CreateObjectSpace();             }             else if (applicationObjectSpaceProvider is INonsecuredObjectSpaceProvider nonsecuredObjectSpaceProvider) {                 objectSpace= nonsecuredObjectSpaceProvider.CreateNonsecuredObjectSpace();             }             else {                 objectSpace= applicationObjectSpaceProvider.CreateUpdatingObjectSpace(false);                 }              if (objectSpace is CompositeObjectSpace compositeObjectSpace) {                 compositeObjectSpace.PopulateAdditionalObjectSpaces(application);             }             return objectSpace;         }     }      }using System; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Model; using Fasterflect; using Xpand.Extensions.ObjectExtensions;   namespace Xpand.Extensions.XAF.XafApplicationExtensions{          public static partial class XafApplicationExtensions{         public static DetailView NewDetailView(this XafApplication application,object currentObject,IModelDetailView modelDetailView=null,bool isRoot=true){             var objectSpace = application.CreateObjectSpace(currentObject.GetType());             modelDetailView ??= application.FindModelDetailView(currentObject.GetType());             var detailView = application.CreateDetailView(objectSpace, modelDetailView,isRoot);             detailView.CurrentObject = objectSpace.GetObject(currentObject);             return detailView;         }          public static DetailView NewDetailView<T>(this XafApplication application,Func<IObjectSpace,T> currentObjectFactory,IModelDetailView modelDetailView=null,bool isRoot=true){             var objectSpace = application.CreateObjectSpace(typeof(T));             var currentObject = currentObjectFactory(objectSpace);             modelDetailView ??= application.FindModelDetailView(currentObject.GetType());             var detailView = application.CreateDetailView(objectSpace, modelDetailView,isRoot);             detailView.CurrentObject = objectSpace.GetObject(currentObject);             return detailView;         }          public static ObjectView NewObjectView(this XafApplication application,             Type viewType,Type objectType) {             var objectSpace = application.CreateObjectSpace(objectType);             if (viewType == typeof(ListView)){                 var listViewId = application.FindListViewId(objectType);                 var collectionSource = application.CreateCollectionSource(objectSpace,objectType,listViewId);                 return application.CreateListView((IModelListView) application.Model.Views[listViewId], collectionSource, true);             }             var modelDetailView = application.Model.BOModel.GetClass(objectType).DefaultDetailView;             return application.CreateDetailView(objectSpace, modelDetailView,true);         }          public static TView NewView<TView>(this XafApplication application,  Type objectType) where TView:CompositeView              => (TView)application.NewView(typeof(DetailView).IsAssignableFrom(typeof(TView))?ViewType.DetailView : ViewType.ListView,objectType);                  public static ListView NewListView(this XafApplication application,  Type objectType)               => application.NewView<ListView>(objectType);                  public static DetailView NewDetailView(this XafApplication application,  Type objectType)               => application.NewView<DetailView>(objectType);          public static CompositeView NewView(this XafApplication application,ViewType viewType,Type objectType){ 	        var modelClass = application.Model.BOModel.GetClass(objectType); 	        return application.NewView((viewType == ViewType.ListView ? modelClass.DefaultListView.Id : modelClass.DefaultDetailView.Id));         }          public static CompositeView NewView(this XafApplication application,string viewId) => application.NewView(application.Model.Views[viewId]);          public static CompositeView NewView(this XafApplication application,IModelView modelView,IObjectSpace objectSpace=null)              => (CompositeView) (objectSpace==null?application.CallMethod("CreateView", modelView):application.CreateView(modelView, objectSpace));          static View CreateView(this XafApplication application,IModelView viewModel,IObjectSpace objectSpace) { 	        View view = null; 	        switch (viewModel){ 		        case IModelListView listViewModel:{ 			        var collectionSource = application.CreateCollectionSource(objectSpace, listViewModel.ModelClass.TypeInfo.Type, listViewModel.Id); 			        view = application.CreateListView(listViewModel, collectionSource, true); 			        break; 		        } 		        case IModelDetailView detailViewModel: 			        view = application.CreateDetailView(objectSpace, detailViewModel, true); 			        break; 		        case IModelDashboardView _: 			        view = application.CreateDashboardView(objectSpace, viewModel.Id, true); 			        break; 	        } 	        return view;         }            public static TObjectView NewObjectView<TObjectView>(this XafApplication application,Type objectType) where TObjectView:ObjectView              => (TObjectView) application.NewObjectView(typeof(TObjectView), objectType);     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static Window CreateViewWindow(this XafApplication application,bool isMain=true,params Controller[] controllers)              => application.CreateWindow(TemplateContext.View, controllers, isMain);                  public static Window CreateViewWindow(this XafApplication application,Func<View> viewFactory,params Controller[] controllers) {             var window = application.CreateWindow(TemplateContext.View, controllers, false);             window.SetView(viewFactory());             return window;         }          public static Window CreatePopupWindow(this XafApplication application,bool isMain=true,params Controller[] controllers)              => application.CreateWindow(TemplateContext.PopupWindow, controllers, isMain);     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static IModelDetailView FindModelDetailView(this DevExpress.ExpressApp.XafApplication application, System.Type objectType) => (IModelDetailView) application             .Model.Views[application.FindDetailViewId(objectType)];     } }using DevExpress.ExpressApp.Model;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static IModelListView FindModelListView(this DevExpress.ExpressApp.XafApplication application, System.Type objectType) => (IModelListView) application             .Model.Views[application.FindListViewId(objectType)];     } }using System; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static string FindViewId(this XafApplication application,             ViewType viewType, Type objectType){             if (viewType == ViewType.DetailView){                 return application.FindDetailViewId(objectType);             }             if (viewType == ViewType.ListView){                 return application.FindListViewId(objectType);             }              throw new NotImplementedException();         }     } }using System; using System.Collections.Concurrent; using System.Collections.Generic; using System.ComponentModel; using System.Linq; using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public enum Platform{         Agnostic,         Win,         Web,         Mobile,         Blazor     }      public static partial class XafApplicationExtensions{                  private static ConcurrentBag<Type> _securedTypes;         static XafApplicationExtensions() => Init();          private static void Init(){             _securedTypes=new ConcurrentBag<Type>();             var assemblies = AppDomain.CurrentDomain.GetAssemblies();             var systemWebAssembly = assemblies.FirstOrDefault(assembly => assembly.GetName().Name == "System.Web");             var httpContextType = systemWebAssembly?.Types().FirstOrDefault(_ => _.Name == "HttpContext");             IsHosted = httpContextType?.GetPropertyValue("Current") != null;                      }          public static bool IsHosted{ get; set; }          public static Platform GetPlatform(this IEnumerable<ModuleBase> moduleBases){             var modules = moduleBases as ModuleBase[] ?? moduleBases.ToArray();             var application = modules.Select(_ => _.Application).FirstOrDefault(_ => _!=null);             if (application != null){                 return application.GetPlatform();             }             var webPlatformString = "Xaf.Platform.Web";             var winPlatformString = "Xaf.Platform.Win";             var mobilePlatformString = "Xaf.Platform.Mobile";              if (CheckPlatform(modules, webPlatformString, winPlatformString, mobilePlatformString))                 return Platform.Web;             if (CheckPlatform(modules, winPlatformString, webPlatformString, mobilePlatformString))                 return Platform.Win;             if (CheckPlatform(modules, mobilePlatformString, webPlatformString, winPlatformString))                 return Platform.Mobile;             return Platform.Agnostic;         }          private static bool CheckPlatform(ModuleBase[] modules, params string[] platformStrings){             if (CheckPlatformCore(modules, platformStrings[0])){                 if (!CheckPlatformCore(modules, platformStrings[1]) &&                     !CheckPlatformCore(modules, platformStrings[2])) return true;                 throw new NotSupportedException("Cannot load modules from different platforms");             }             return false;         }          private static bool CheckPlatformCore(ModuleBase[] moduleBases, string platformString) =>             moduleBases.Any(@base => {                 var typeInfo = XafTypesInfo.Instance.FindTypeInfo(@base.GetType());                 var attribute = typeInfo.FindAttribute<ToolboxItemFilterAttribute>();                  return attribute != null && attribute.FilterString == platformString;             });          public static Platform GetPlatform(this XafApplication application){             var appNames = new[]{"WinApplication","WebApplication","BlazorApplication"};             var baseType = application.GetType().BaseType;             while (baseType?.Namespace != null && (!appNames.Contains(baseType.Name)&&!baseType.Namespace.StartsWith("DevExpress.ExpressApp"))){                 baseType = baseType.BaseType;             }              return baseType?.Name switch{ 	            "WinApplication" => Platform.Win, 	            "ServerApplication" => Platform.Win, 	            "WebApplication" => Platform.Web, 	            "BlazorApplication" => Platform.Blazor, 	            _ => throw new NotImplementedException(application.GetType().FullName)             };         }     } }using System; using Fasterflect; using Xpand.Extensions.XAF.AppDomainExtensions; using static System.AppDomain; using static DevExpress.Persistent.Base.Tracing;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static void HandleException(this DevExpress.ExpressApp.XafApplication application, Exception exception){              try {                 var platform = application.GetPlatform();                 switch (platform) {                     case Platform.Win:                         application.CallMethod("HandleException", exception);                         break;                     case Platform.Web:                         CurrentDomain.XAF().ErrorHandling().CallMethod("SetPageError", exception);                         break;                     default:                         application.GetPropertyValue("ExceptionService").CallMethod("HandleException", exception);                         break;                 }                 Tracer.LogError(exception);             }             catch (Exception e){                 Tracer.LogError(e);                 throw exception;             }         }     } }using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.XafApplicationExtensions { 	public static partial class XafApplicationExtensions { 		static readonly MemberGetter IsDisposedGetter = typeof(XafApplication).DelegateForGetPropertyValue("IsDisposed"); 		public static bool IsDisposed(this XafApplication application)  			=> (bool)IsDisposedGetter(application); 	} }using DevExpress.ExpressApp; using DevExpress.Persistent.Base;  namespace Xpand.Extensions.XAF.XafApplicationExtensions {     public static partial class XafApplicationExtensions {         public static readonly string ApplicationMarker = typeof(XafApplicationExtensions).Assembly.GetName().Name;         public static bool IsInternal(this XafApplication application)              => ValueManager.GetValueManager<bool>(ApplicationMarker).Value;     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.ExpressApp; using Fasterflect;  namespace Xpand.Extensions.XAF.XafApplicationExtensions{     public static partial class XafApplicationExtensions{         public static IEnumerable<IObjectSpaceProvider> ObjectSpaceProviders(this XafApplication application, params Type[] objectTypes)              => objectTypes.Select(application.GetObjectSpaceProvider).Distinct();         public static IList<IObjectSpaceProvider> ObjectSpaceProviders(this XafApplication application)              => ((IList<IObjectSpaceProvider>)application.CallMethod("GetOrCreateObjectSpaceProviderContainer").GetFieldValue("_objectSpaceProviders"));     } }using System.Collections.Generic; using System.Linq; using DevExpress.Data.Filtering; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.XafApplicationExtensions {     public static partial class XafApplicationExtensions {         public static IEnumerable<IList<T>> ReloadObjects<T>(this IEnumerable<T[]> source, XafApplication application)             => source.Select(application.ReloadObjects);                  public static IList<T> ReloadObjects<T>(this XafApplication application, params T[] objects) {             var objectSpace = application.CreateObjectSpace();             var keys = objects.Select(arg => objectSpace.GetKeyValue(arg)).ToArray();             return objectSpace.GetObjects<T>(new InOperator($"{objectSpace.GetKeyPropertyName(typeof(T))}",keys));         }     } }using System.Collections.Generic; using System.Diagnostics; using System.Linq; using DevExpress.ExpressApp; using Fasterflect; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.XafApplicationExtensions {     public static partial class XafApplicationExtensions {         public static IEnumerable<TraceSource> TraceSources(this XafApplication application)             => application.Modules.SelectMany(m => m.GetType().Properties(Flags.StaticPublic)                 .Where(info => info.PropertyType == typeof(TraceSource))                 .Select(info => info.GetValue(null))).Cast<TraceSource>();          public static IEnumerable<TraceSource> SourceLevel(this IEnumerable<TraceSource> sources,SourceLevels sourceLevel)              => sources.Execute(source => source.Switch.Level=sourceLevel);     } }using System; using System.Collections.Generic; using System.Data; using System.Data.SqlClient; using System.Linq; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.DC.Xpo; using DevExpress.ExpressApp.Model.Core; using DevExpress.Xpo; using DevExpress.Xpo.DB; using DevExpress.Xpo.Helpers; using DevExpress.Xpo.Metadata; using DevExpress.Xpo.Providers; using Fasterflect; using Swordfish.NET.Collections.Auxiliary; using Xpand.Extensions.AppDomainExtensions; using Xpand.Extensions.ObjectExtensions; using Xpand.Extensions.StringExtensions; using Xpand.Extensions.XAF.TypesInfoExtensions; using Xpand.Extensions.XAF.Xpo.Attributes; using Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions;  namespace Xpand.Extensions.XAF.Xpo {     public interface IXpoAttributeValue {         string Value { get; }     }           public static class XpoExtensions {         internal static void CustomizeTypesInfo(ITypesInfo typesInfo) {             CreateXpAttributeValueAttributes();             RuntimeAssociationAttributes(typesInfo);         }          private static void RuntimeAssociationAttributes(this ITypesInfo typesInfo)              => typesInfo.PersistentTypes.AttributedMembers<RuntimeAssociationAttribute>().ToArray()                 .Select(t => (t.attribute, memberInfo: t.memberInfo.Owner.QueryXPClassInfo().FindMember(t.memberInfo.Name)))                 .ForEach(t => {                     var providedAssociationAttribute = (RuntimeAssociationAttribute)t.memberInfo.FindAttributeInfo(typeof(RuntimeAssociationAttribute));                     var customMemberInfo = typesInfo.CreateMemberInfo(t.memberInfo, providedAssociationAttribute, t.memberInfo.GetAssociationAttribute(providedAssociationAttribute));                     t.memberInfo.AddExtraAttributes(providedAssociationAttribute, customMemberInfo);                 });          private static void CreateXpAttributeValueAttributes(){             new[]{ nameof(SingleObjectAttribute), nameof(PropertyConcatAttribute) }.ToArray().ForEach(attributeName => {                 var lastObjectAttributeType =                     AppDomain.CurrentDomain.GetAssemblyType($"Xpand.Extensions.XAF.Xpo.Attributes.{attributeName}");                 lastObjectAttributeType?.Method("Configure", Flags.StaticAnyVisibility).Call(null);             });         }          public static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn,             Type typeOfCollection, string associationName)              => typeInfo.CreateCollection( typeToCreateOn, typeOfCollection, associationName, true);                  static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn, Type typeOfCollection, string associationName,  bool refreshTypesInfo,                                                           string propertyName, bool isManyToMany)              => typeInfo.CreateCollection( typeToCreateOn, typeOfCollection, associationName, propertyName, refreshTypesInfo, isManyToMany);          public static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn, Type typeOfCollection, string associationName,  bool refreshTypesInfo,                                                           string propertyName)              => typeInfo.CreateCollection( typeToCreateOn, typeOfCollection, associationName,  propertyName, refreshTypesInfo, false);          public static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn, Type typeOfCollection, string associationName,  bool refreshTypesInfo) {             return CreateCollection(typeInfo, typeToCreateOn, typeOfCollection, associationName,  refreshTypesInfo, typeOfCollection.Name + "s");         }          public static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn, Type typeOfCollection, string associationName,  string collectionName)              => typeInfo.CreateCollection( typeToCreateOn, typeOfCollection, associationName,  collectionName, true);          static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn, Type typeOfCollection, string associationName,  string collectionName, bool refreshTypesInfo,                                                           bool isManyToMany) {             XPMemberInfo member = null;             if (TypeIsRegister(typeInfo, typeToCreateOn)) {                 XPClassInfo xpClassInfo = typeInfo.FindTypeInfo(typeToCreateOn).QueryXPClassInfo();                 member = xpClassInfo.FindMember(collectionName) ??                          xpClassInfo.CreateMember(collectionName, typeof(XPCollection), true);                 if (member.FindAttributeInfo(typeof(AssociationAttribute))==null)                     member.AddAttribute(new AssociationAttribute(associationName, typeOfCollection){                         UseAssociationNameAsIntermediateTableName = isManyToMany                     });                 if (refreshTypesInfo)                     typeInfo.RefreshInfo(typeToCreateOn);             }             return member;          }          public static XPMemberInfo CreateCollection(this ITypesInfo typeInfo, Type typeToCreateOn,             Type typeOfCollection, string associationName, string collectionName, bool refreshTypesInfo)              => typeInfo.CreateCollection(typeToCreateOn, typeOfCollection, associationName, collectionName, refreshTypesInfo, false);          public static List<XPMemberInfo> CreateBothPartMembers(this ITypesInfo typesInfo, Type typeToCreateOn, Type otherPartType)              => typesInfo.CreateBothPartMembers( typeToCreateOn, otherPartType,  false);          public static List<XPMemberInfo> CreateBothPartMembers(this ITypesInfo typesInfo, Type typeToCreateOn, Type otherPartMember,  bool isManyToMany)              => typesInfo.CreateBothPartMembers( typeToCreateOn, otherPartMember, isManyToMany, Guid.NewGuid().ToString());          public static List<XPMemberInfo> CreateBothPartMembers(this ITypesInfo typesInfo, Type typeToCreateOn, Type otherPartMember, bool isManyToMany, string association,                                                                      string createOnPropertyName, string otherPartPropertyName) {             var infos = new List<XPMemberInfo>();             var member = isManyToMany ? CreateCollection(typesInfo, typeToCreateOn, otherPartMember, association, false, createOnPropertyName, true)                                             : CreateMember(typesInfo, typeToCreateOn, otherPartMember, association,  createOnPropertyName, false);              if (member != null) {                 infos.Add(member);                 member = isManyToMany ? typesInfo.CreateCollection( otherPartMember, typeToCreateOn, association, false, otherPartPropertyName, true)                              : typesInfo.CreateCollection( typeToCreateOn, otherPartMember, association, false, otherPartPropertyName);                  if (member != null)                     infos.Add(member);             }              typesInfo.RefreshInfo(typeToCreateOn);             typesInfo.RefreshInfo(otherPartMember);             return infos;          }          public static XPMemberInfo CreateMember(this ITypesInfo typesInfo, Type typeToCreateOn, Type typeOfMember, string associationName)              => typesInfo.CreateMember( typeToCreateOn, typeOfMember, associationName,  true);          public static XPMemberInfo CreateMember(this ITypesInfo typesInfo, Type typeToCreateOn, Type typeOfMember, string associationName,  bool refreshTypesInfo)             => typesInfo.CreateMember( typeToCreateOn, typeOfMember, associationName,  typeOfMember.Name, refreshTypesInfo);          public static XPMemberInfo CreateMember(this ITypesInfo typesInfo, Type typeToCreateOn, Type typeOfMember, string associationName,  string propertyName)              => typesInfo.CreateMember( typeToCreateOn, typeOfMember, associationName,  propertyName, true);          private static bool TypeIsRegister(ITypesInfo typeInfo, Type typeToCreateOn)              => XafTypesInfo.Instance.FindTypeInfo(typeToCreateOn).IsDomainComponent ||                typeInfo.PersistentTypes.FirstOrDefault(info => info.Type == typeToCreateOn) != null;          public static XPMemberInfo CreateMember(this ITypesInfo typesInfo, Type typeToCreateOn, Type typeOfMember, string associationName,  string propertyName, bool refreshTypesInfo) {             XPMemberInfo member = null;             if (TypeIsRegister(typesInfo, typeToCreateOn)) {                 XPClassInfo xpClassInfo = typesInfo.FindTypeInfo(typeToCreateOn).QueryXPClassInfo();                 member = xpClassInfo.FindMember(propertyName);                 if (member == null) {                     member = xpClassInfo.CreateMember(propertyName, typeOfMember,                         new AssociationAttribute(associationName, typeOfMember));                     if (refreshTypesInfo)                         typesInfo.RefreshInfo(typeToCreateOn);                 }             }             return member;         }          public static List<XPMemberInfo> CreateBothPartMembers(this ITypesInfo typesInfo, Type typeToCreateOn, Type otherPartMember,  bool isManyToMany, string association) {              var infos = new List<XPMemberInfo>();             var member = isManyToMany ? CreateCollection(typesInfo, typeToCreateOn, otherPartMember, association,  false)                                             : CreateMember(typesInfo, otherPartMember, typeToCreateOn, association,  false);              if (member != null) {                 infos.Add(member);                 member = isManyToMany ? CreateCollection(typesInfo, otherPartMember, typeToCreateOn, association, false)                              : CreateCollection(typesInfo, typeToCreateOn, otherPartMember, association, false);                  if (member != null)                     infos.Add(member);             }              typesInfo.RefreshInfo(typeToCreateOn);             typesInfo.RefreshInfo(otherPartMember);              return infos;         }          public static XPClassInfo FindDCXPClassInfo(this ITypeInfo typeInfo) {             var xpoTypeInfoSource = ((XpoTypeInfoSource) ((TypeInfo) typeInfo).Source);             if (DesignerOnlyCalculator.IsRunTime) {                 var generatedEntityType = xpoTypeInfoSource.GetGeneratedEntityType(typeInfo.Type);                 return generatedEntityType == null ? null : xpoTypeInfoSource.XPDictionary.GetClassInfo(generatedEntityType);             }             var className = typeInfo.Name + "BaseDCDesignTimeClass";             var xpClassInfo = xpoTypeInfoSource.XPDictionary.QueryClassInfo("", className);             return xpClassInfo ?? new XPDataObjectClassInfo(xpoTypeInfoSource.XPDictionary, className);         }                  public static XPClassInfo QueryXPClassInfo(this ITypeInfo typeInfo){             var typeInfoSource = ((TypeInfo)typeInfo).Source as XpoTypeInfoSource;             return typeInfoSource?.XPDictionary.QueryClassInfo(typeInfo.Type);         }                  internal static IMemberInfo[] Configure<T>() where T : Attribute,IXpoAttributeValue              => XafTypesInfo.Instance.PersistentTypes.SelectMany(info => info.Members)                 .Select(info => {                     var attribute = info.FindAttribute<T>();                     if (attribute != null) {                         info.AddAttribute(new PersistentAliasAttribute(attribute.Value));                     }                     return info;                 }).ToArray();         public static void FireChanged(this IXPReceiveOnChangedFromArbitrarySource source, string propertyName)              => source.FireChanged(propertyName);          public static void SetCriteria<T>(this XPBaseCollection collection, Expression<Func<T, bool>> lambda)              => collection.Criteria = CriteriaOperator.FromLambda(lambda);                  public static void SetFilter<T>(this XPBaseCollection collection, Expression<Func<T, bool>> lambda)              => collection.Filter = CriteriaOperator.FromLambda(lambda);          public static IDbConnection Connection(this UnitOfWork unitOfWork){             var dataLayer = unitOfWork.DataLayer;             var connectionProvider = ((BaseDataLayer)dataLayer).ConnectionProvider;             if (connectionProvider is DataCacheNode){                 return (IDbConnection)((DataCacheRoot)connectionProvider.GetPropertyValue("Nested"))                     .GetPropertyValue("Nested").GetPropertyValue("Connection");             }              if (connectionProvider is DataStorePool pool){                 var connectionProviderSql = (ConnectionProviderSql)pool.AcquireReadProvider();                 var dbConnection = connectionProviderSql.Connection;                 pool.ReleaseReadProvider(connectionProviderSql);                 return dbConnection;             }              return connectionProvider is not STASafeDataStore ? connectionProvider is ConnectionProviderSql provider ? provider.Connection : null                 : connectionProvider.GetFieldValue("DataStore").Cast<ConnectionProviderSql>().Connection;         }                  public static SqlConnection NewSQLConnection(this XafApplication application,Type objectType=null) {             objectType ??= application.TypesInfo.PersistentTypes.First(info => info.IsPersistent).Type;             using var objectSpace = application.CreateObjectSpace(objectType);             var dbConnection = objectSpace.Connection();             if (dbConnection!=null) {                 var sqlConnection = new SqlConnection(dbConnection.ConnectionString);                 sqlConnection.Open();                 return sqlConnection;             }             return null;         }          public static void XpoMigrateDatabase(this XafApplication application, string connectionString=null) {             var provider = XpoDefault.GetConnectionProvider(connectionString??application.ConnectionString, AutoCreateOption.DatabaseAndSchema);             if (provider is IUpdateSchemaSqlFormatter sqlFormatter&&((ConnectionProviderSql)provider).Connection.DbExists()) {                 var sql = sqlFormatter.FormatUpdateSchemaScript(((IDataStoreSchemaMigrationProvider)provider)                     .CompareSchema(new ReflectionDictionary().GetDataStoreSchema(application.TypesInfo.PersistentTypes                         .Where(info => info.IsPersistent).Select(info => info.Type).ToArray()), new SchemaMigrationOptions()));                 if (!sql.IsNullOrEmpty()) {                     var command = ((ConnectionProviderSql)provider).Connection.CreateCommand();                     command.CommandText = sql;                     command.ExecuteNonQuery();                 }                 }         }      } }using System; using System.Collections; using System.Collections.Generic; using DevExpress.ExpressApp.DC; using Xpand.Extensions.LinqExtensions;  namespace Xpand.Extensions.XAF.Xpo.Attributes{     [AttributeUsage(AttributeTargets.Property)]     public class PropertyConcatAttribute:Attribute,IXpoAttributeValue {         public string Value { get; }          public PropertyConcatAttribute(string[] names,string separator=".") => Value = $"Concat({LinqExtensions.LinqExtensions.Join((IEnumerable)names, $",'{separator}',")})";                  public static IMemberInfo[] Configure()              => XpoExtensions.Configure<PropertyConcatAttribute>();      } }using System; using System.Collections.Generic; using System.Reflection; using DevExpress.ExpressApp.DC; using DevExpress.Xpo; using DevExpress.Xpo.Metadata; using AggregatedAttribute = DevExpress.Xpo.AggregatedAttribute;  namespace Xpand.Extensions.XAF.Xpo.Attributes {     public enum RuntimeRelationType {         ManyToMany,         OneToMany     }      [AttributeUsage(AttributeTargets.Property)]     public class RuntimeAssociationAttribute : Attribute {         public RuntimeAssociationAttribute(string associationName, RuntimeRelationType runtimeRelationType)             : this(associationName, null, runtimeRelationType, null) {         }         public RuntimeAssociationAttribute(string associationName)             : this(associationName, null,RuntimeRelationType.OneToMany, null) {         }           public RuntimeAssociationAttribute(string associationName, string providedPropertyName, RuntimeRelationType runtimeRelationType,             string attributesFactory="") {             AssociationName = associationName;             RelationType = runtimeRelationType;             AttributesFactoryProperty = attributesFactory;             ProvidedPropertyName = providedPropertyName;         }          public string AssociationName { get; }          public string AttributesFactoryProperty { get; }          public string ProvidedPropertyName { get; }           public RuntimeRelationType RelationType { get; }          public bool IsAggregated { get; set; }     }      internal static class RuntimeAssociationExtensions {         internal static void AddExtraAttributes(this XPMemberInfo memberInfo, RuntimeAssociationAttribute providedAssociationAttribute, XPMemberInfo customMemberInfo) {             if (!(string.IsNullOrEmpty(providedAssociationAttribute.AttributesFactoryProperty)))                 foreach (var attribute in memberInfo.Owner.GetAttributes(providedAssociationAttribute.AttributesFactoryProperty)) {                     customMemberInfo.AddAttribute(attribute);                 }         }                   internal static AssociationAttribute GetAssociationAttribute(this XPMemberInfo memberInfo, RuntimeAssociationAttribute providedAssociationAttribute) {             var associationAttribute = memberInfo.FindAttributeInfo(typeof(AssociationAttribute)) as AssociationAttribute;             if (associationAttribute == null && !string.IsNullOrEmpty(providedAssociationAttribute.AssociationName))                 associationAttribute = new AssociationAttribute(providedAssociationAttribute.AssociationName);             else if (associationAttribute == null)                 throw new NullReferenceException(memberInfo + " has no association attribute");             return associationAttribute;         }          static IEnumerable<Attribute> GetAttributes(this XPClassInfo owner,string attributesFactoryProperty) {             PropertyInfo memberInfo = owner.ClassType.GetProperty(attributesFactoryProperty);             return memberInfo != null ? (IEnumerable<Attribute>)memberInfo.GetValue(null, null) : new List<Attribute>();         }          internal static XPMemberInfo CreateMemberInfo(this ITypesInfo typesInfo, XPMemberInfo memberInfo, RuntimeAssociationAttribute runtimeAssociationAttribute, AssociationAttribute associationAttribute) {             var typeToCreateOn = GetTypeToCreateOn(memberInfo, associationAttribute);             if (typeToCreateOn == null)                 throw new NotImplementedException();             XPMemberInfo member;             if (!(memberInfo.IsNonAssociationList) || (memberInfo.IsNonAssociationList && runtimeAssociationAttribute.RelationType == RuntimeRelationType.ManyToMany)) {                 member = typesInfo.CreateCollection(typeToCreateOn, memberInfo.Owner.ClassType, associationAttribute.Name,                     runtimeAssociationAttribute.ProvidedPropertyName ?? memberInfo.Owner.ClassType.Name + "s", false);                 if (runtimeAssociationAttribute.IsAggregated) {                     member.AddAttribute(new AggregatedAttribute());                 }             } else {                 member = typesInfo.CreateMember(typeToCreateOn, memberInfo.Owner.ClassType, associationAttribute.Name,                     runtimeAssociationAttribute.ProvidedPropertyName ?? memberInfo.Owner.ClassType.Name, false);             }              if (!string.IsNullOrEmpty(runtimeAssociationAttribute.AssociationName) && !memberInfo.HasAttribute(typeof(AssociationAttribute)))                 memberInfo.AddAttribute(new AssociationAttribute(runtimeAssociationAttribute.AssociationName));             typesInfo.RefreshInfo(typeToCreateOn);             typesInfo.RefreshInfo(memberInfo.Owner.ClassType);              return member;         }          private static Type GetTypeToCreateOn(XPMemberInfo memberInfo, AssociationAttribute associationAttribute) {             return !memberInfo.MemberType.IsGenericType                        ? (string.IsNullOrEmpty(associationAttribute.ElementTypeName)                               ? memberInfo.MemberType                               : Type.GetType(associationAttribute.ElementTypeName))                        : memberInfo.MemberType.GetGenericArguments()[0];         }         } }using System; using DevExpress.Data.Filtering; using DevExpress.ExpressApp.DC;  namespace Xpand.Extensions.XAF.Xpo.Attributes{     [AttributeUsage(AttributeTargets.Property)]     public class SingleObjectAttribute:Attribute, IXpoAttributeValue {         public string Value { get; }          public SingleObjectAttribute(string collectionName,string collectionPropertyName,Aggregate aggregate=Aggregate.Max) {             Value = $"{collectionName}[{collectionPropertyName}=^.{collectionName}.{aggregate}({collectionPropertyName})].Single()";         }          public static IMemberInfo[] Configure()              => XpoExtensions.Configure<SingleObjectAttribute>();     } }using DevExpress.Xpo; using Fasterflect;  namespace Xpand.Extensions.XAF.Xpo.BaseObjects {     public static class BaseObjectExtensions {         public static void OnChanged(this PersistentBase persistentBase, string memberName)              => persistentBase.CallMethod(nameof(OnChanged), memberName);         public static bool IsDisposed(this IXPInvalidateableObject obj)              => obj.IsInvalidated;     } }using System.Diagnostics.CodeAnalysis; using DevExpress.Persistent.Base; using DevExpress.Xpo; using Xpand.Extensions.XAF.Xpo.BaseObjects;  // ReSharper disable once CheckNamespace namespace Xpand.XAF.Persistent.BaseImpl{     [NonPersistent]     public abstract class CustomBaseObject : XPCustomBaseObject {                          [Persistent(nameof(Oid)), Key(true), VisibleInListView(false), VisibleInDetailView(false), VisibleInLookupListView(false), MemberDesignTimeVisibility(false)]         private long _oid=0 ;         [PersistentAlias(nameof(_oid)), VisibleInListView(false), VisibleInDetailView(false), VisibleInLookupListView(false)]         [SuppressMessage("ReSharper", "ConvertToAutoProperty")]         public long Oid => _oid;                  protected CustomBaseObject(Session session):base(session){                      }       }  }using System; using System.ComponentModel; using DevExpress.ExpressApp.DC; using DevExpress.Persistent.Base.General; using DevExpress.Xpo; using Xpand.Extensions.XAF.Attributes; using Xpand.XAF.Persistent.BaseImpl;  namespace Xpand.Extensions.XAF.Xpo.BaseObjects {     [DefaultProperty(nameof(NotificationMessage))]     public class ErrorEvent:CustomBaseObject,ISupportNotifications{         public ErrorEvent(Session session) : base(session){         }          string _notificationMessage;          [Size(SizeAttribute.Unlimited)][XafDisplayName("Msg")]         public string NotificationMessage{             get => _notificationMessage;             set => SetPropertyValue(nameof(NotificationMessage), ref _notificationMessage, value);         }          bool _isPostponed;         [InvisibleInAllViews]         public bool IsPostponed{             get => _isPostponed;             set => SetPropertyValue(nameof(IsPostponed), ref _isPostponed, value);         }         [InvisibleInAllViews]         public object UniqueId => Oid;          DateTime? _alarmTime;         [InvisibleInAllViews]         public DateTime? AlarmTime{             get => _alarmTime;             set => SetPropertyValue(nameof(AlarmTime), ref _alarmTime, value);         }     } }using System; using System.ComponentModel; using System.IO; using DevExpress.ExpressApp; using DevExpress.Persistent.Base; using DevExpress.Persistent.Validation; using DevExpress.Xpo; using Xpand.XAF.Persistent.BaseImpl;  namespace Xpand.Extensions.XAF.Xpo.BaseObjects {     [DefaultProperty("FileName")]     public class FileLinkObject : CustomBaseObject, IFileData, IEmptyCheckable, ISupportFullName {         public FileLinkObject(Session session) : base(session) { }         #region IFileData Members         [Size(260), Custom("AllowEdit", "False")]         public string FileName {             get => GetPropertyValue<string>();             set => SetPropertyValue("FileName", value);          }         void IFileData.Clear() {             Size = 0;             FileName = string.Empty;         }                  void IFileData.LoadFromStream(string fileName, Stream source) {             Size = (int)source.Length;             FileName = fileName;         }         void IFileData.SaveToStream(Stream destination) {             try {                 if (destination == null)                     OpenFileWithDefaultProgram(FullName);                 else                     CopyFileToStream(FullName, destination);             } catch (Exception exc) {                 throw new UserFriendlyException(exc);             }         }          static void CopyFileToStream(string sourceFileName, Stream destination) {             if (string.IsNullOrEmpty(sourceFileName) || destination == null) return;             using Stream source = File.OpenRead(sourceFileName);             source.CopyTo(destination);         }         static void OpenFileWithDefaultProgram(string sourceFileName) {             System.Diagnostics.Process process = new System.Diagnostics.Process();             process.StartInfo.UseShellExecute = true;             process.StartInfo.FileName = sourceFileName;             process.Start();         }          [Persistent]         public int Size {             get => GetPropertyValue<int>();             private set => SetPropertyValue("Size", value);         }         #endregion         #region IEmptyCheckable Members         public bool IsEmpty => !File.Exists(FullName);          #endregion         #region ISupportFullName Members         [Size(260), Custom("AllowEdit", "False")]         public string FullName {             get => GetPropertyValue<string>();             set => SetPropertyValue("FullName", value);         }         #endregion     } }using System; using System.Collections.Generic; using System.ComponentModel; using System.Runtime.CompilerServices; using DevExpress.ExpressApp; using DevExpress.ExpressApp.DC; using DevExpress.Xpo; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.BaseObjects {     [NonPersistent]     public abstract class XPCustomBaseObject: XPCustomObject,IObjectSpaceLink{ 	    protected XPCustomBaseObject() { 	    }  	    protected XPCustomBaseObject(Session session, XPClassInfo classInfo) : base(session, classInfo) { 	    }         protected void SetPropertyValue<T>(ref T oldValue, T newValue,[CallerMemberName]string caller=null)              => base.SetPropertyValue(caller, ref oldValue, newValue); 	    protected T GetSafe<T>(Func<T> func) => !IsLoading && !IsSaving ? func() : default;         protected override void OnSaving() {             if (TruncateStrings)                 DoTruncateStrings();             base.OnSaving();         }          public override string ToString() {             if (!_isDefaultPropertyAttributeInit) {                 if (ClassInfo.FindAttributeInfo(typeof(DefaultPropertyAttribute)) is DefaultPropertyAttribute attrib) {                     _defaultPropertyMemberInfo = ClassInfo.FindMember(attrib.Name);                 }                 _isDefaultPropertyAttributeInit = true;             }             object obj = _defaultPropertyMemberInfo?.GetValue(this);             if (obj != null) {                 return obj.ToString();             }             if (!_isDefaultPropertyAttributeInit) {                 string defaultPropertyName = string.Empty;                 var xafDefaultPropertyAttribute = XafTypesInfo.Instance.FindTypeInfo(GetType()).FindAttribute<XafDefaultPropertyAttribute>();                 if (xafDefaultPropertyAttribute != null) {                     defaultPropertyName = xafDefaultPropertyAttribute.Name;                 } else {                     var defaultPropertyAttribute = XafTypesInfo.Instance.FindTypeInfo(GetType()).FindAttribute<DefaultPropertyAttribute>();                     if (defaultPropertyAttribute != null) {                         defaultPropertyName = defaultPropertyAttribute.Name;                     }                 }                 if (!string.IsNullOrEmpty(defaultPropertyName)) {                     _defaultPropertyMemberInfo = ClassInfo.FindMember(defaultPropertyName);                 }                 _isDefaultPropertyAttributeInit = true;             }             obj = _defaultPropertyMemberInfo?.GetValue(this);             return obj?.ToString() ?? base.ToString();         }          [Browsable(false)]         [MemberDesignTimeVisibility(false)]         public bool IsNewObject => Session.IsNewObject(this);          [Obsolete("Use XpandUnitOfWork instead")]         [NonPersistent]         public HashSet<string> ChangedProperties { get; set; }          protected override void TriggerObjectChanged(ObjectChangeEventArgs args) {             if (!CancelTriggerObjectChanged)                 base.TriggerObjectChanged(args);         }          [Browsable(false)]         [NonPersistent]         [MemberDesignTimeVisibility(false)]         public bool CancelTriggerObjectChanged { get; set; }          [Browsable(false)]         [NonPersistent]         [MemberDesignTimeVisibility(false)]         public bool TruncateStrings { get; set; }          private void DoTruncateStrings() {             foreach (XPMemberInfo xpMemberInfo in ClassInfo.PersistentProperties) {                 if (xpMemberInfo.MemberType == typeof(string)) {                     if (xpMemberInfo.GetValue(this) is string value) {                         value = TruncateValue(xpMemberInfo, value);                         xpMemberInfo.SetValue(this, value);                     }                 }             }         }         string TruncateValue(XPMemberInfo xpMemberInfo, string value) {             if (xpMemberInfo.HasAttribute(typeof(SizeAttribute))) {                 int size = ((SizeAttribute)xpMemberInfo.GetAttributeInfo(typeof(SizeAttribute))).Size;                 if (size > -1 && value.Length > size)                     value = value.Substring(0, size - 1);             } else if (value.Length > 99)                 value = value.Substring(0, 99);             return value;         }          private bool _isDefaultPropertyAttributeInit;         private XPMemberInfo _defaultPropertyMemberInfo;          protected XPCustomBaseObject(Session session):base(session) {                      }          [Browsable(false)]         public IObjectSpace ObjectSpace{ get; set; }     } }using System; using DevExpress.ExpressApp.Xpo; using DevExpress.Xpo.DB; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.Xpo.ConnectionProviders {     public class CachedDataStoreProvider : ConnectionStringDataStoreProvider, IXpoDataStoreProvider {         static CachedDataStoreProvider() {             Factory = () => default;             CreateStore = () => default;             CustomCreateUpdatingStore = () => default;         }          private static readonly Lazy<CachedDataStoreProvider> Lazy = new(()              => Factory() ?? new CachedDataStoreProvider(StaticConnectionString));          public static string StaticConnectionString { get; set; }          public static Func<CachedDataStoreProvider> Factory { get; set; }          private static IDisposable[] _rootDisposableObjects;         private static DataCacheRoot _root;          public static CachedDataStoreProvider Instance => Lazy.Value;          public CachedDataStoreProvider(string connectionString) : base(connectionString) {         }          public static readonly Func<(bool allowUpdateSchema, IDisposable[] rootDisposables, IDataStore dataStore)> CustomCreateUpdatingStore;          public static readonly Func<(IDisposable[] rootDisposables, IDataStore dataStore)> CreateStore;          public new IDataStore CreateWorkingStore(out IDisposable[] disposableObjects)              => ((IXpoDataStoreProvider) this).CreateWorkingStore(out disposableObjects);          IDataStore IXpoDataStoreProvider.CreateUpdatingStore(bool allowUpdateSchema,             out IDisposable[] disposableObjects) {             var store = CustomCreateUpdatingStore();             if (store.IsDefaultValue()) {                 return base.CreateUpdatingStore(allowUpdateSchema, out disposableObjects);             }              disposableObjects = store.rootDisposables;             return store.dataStore;         }          IDataStore IXpoDataStoreProvider.CreateWorkingStore(out IDisposable[] disposableObjects) {             if (_root == null) {                 var tuple = CreateStore();                 IDataStore baseDataStore;                 if (tuple.IsDefaultValue()) {                     baseDataStore = base.CreateWorkingStore(out _rootDisposableObjects);                 }                 else {                     baseDataStore = tuple.dataStore;                     _rootDisposableObjects = tuple.rootDisposables;                 }                  _root = new DataCacheRoot(baseDataStore);             }              disposableObjects = Array.Empty<IDisposable>();             return new DataCacheNode(_root);         }          public static void ResetDataCacheRoot() {             _root = null;             if (_rootDisposableObjects != null) {                 foreach (var disposableObject in _rootDisposableObjects) disposableObject.Dispose();                 _rootDisposableObjects = null;             }         }     } }using System; using System.Data; using System.Data.SqlClient; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static bool DbExist(this XafApplication application) {             var builder = new SqlConnectionStringBuilder(application.ConnectionString);             var initialCatalog = "Initial catalog";             var databaseName = builder[initialCatalog].ToString();             builder.Remove(initialCatalog);             using var sqlConnection = new SqlConnection(builder.ConnectionString);             return sqlConnection.DbExists(databaseName);         }          public static bool DbExist(this IObjectSpaceProvider objectSpaceProvider) {             using var objectSpace = objectSpaceProvider.CreateUpdatingObjectSpace(true);             var dbConnection = objectSpace.Connection();             return dbConnection.DbExists( objectSpace.Database);         }          public static bool DbExists(this IDbConnection dbConnection, string databaseName=null){             if (dbConnection.State != ConnectionState.Open) {                 dbConnection.Open();             }             using var dbCommand = dbConnection.CreateCommand();             dbCommand.CommandText = $"SELECT db_id('{databaseName??dbConnection.Database}')";             return dbCommand.ExecuteScalar() != DBNull.Value;         }     } }using System.Data; using System.Data.SqlClient; using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions{     public static partial class ObjectSpaceExtensions{         public static void DeleteAllData(this IObjectSpaceProvider objectSpaceProvider) {             using var objectSpace = objectSpaceProvider.CreateUpdatingObjectSpace(true);             objectSpace.Connection().DeleteAllData();             objectSpaceProvider.UpdateSchema();         }          public static void DeleteAllData(this XafApplication application) {             if (!application.DbExist()) return;             using var sqlConnection = new SqlConnection(application.ConnectionString);             sqlConnection.DeleteAllData();         }          public static void DeleteAllData(this IDbConnection dbConnection) {             if (dbConnection.State != ConnectionState.Open) {                 dbConnection.Open();             }             using var dbCommand = dbConnection.CreateCommand();             dbCommand.CommandText = @"         EXEC sp_MSForEachTable 'ALTER TABLE ? NOCHECK CONSTRAINT all'         EXEC sp_MSForEachTable '             IF OBJECTPROPERTY(object_id(''?''), ''TableHasIdentity'') = 1             BEGIN                 DBCC CHECKIDENT (''?'', RESEED, 0)             END             DELETE FROM ?'         EXEC sp_MSForEachTable 'ALTER TABLE ? WITH CHECK CHECK CONSTRAINT all' ";             dbCommand.ExecuteNonQuery();         }     } }using DevExpress.ExpressApp;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static bool DropDatabase(this IObjectSpaceProvider objectSpaceProvider) {             if (!objectSpaceProvider.DbExist()) return false;             using var objectSpace = objectSpaceProvider.CreateUpdatingObjectSpace(true);             using var dbCommand = objectSpace.Connection().CreateCommand();             dbCommand.CommandText =                 $"ALTER DATABASE [{objectSpace.Database}] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;DROP DATABASE [{objectSpace.Database}]";             dbCommand.ExecuteNonQuery();             return true;         }     } }using System; using System.Linq.Expressions; using DevExpress.Data.Filtering; using DevExpress.Xpo; using DevExpress.Xpo.Metadata; using Xpand.Extensions.ExpressionExtensions;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         public static object Evaluate(this Session session, Type objectType, string field,             Aggregate aggregate, CriteriaOperator filter = null)             => session.Evaluate(objectType, CriteriaOperator.Parse($"{aggregate}({field})"), filter);                  public static object Evaluate(this Session session, XPClassInfo classInfo, string field,             Aggregate aggregate, CriteriaOperator filter = null)             => session.Evaluate(classInfo, CriteriaOperator.Parse($"{aggregate}({field})"), filter);                  public static object Evaluate<T>(this Session session,  Expression<Func<T,object>> field,             Aggregate aggregate, Func<Expression<Func<T, bool>>> filter = null) {             filter ??= () => arg => true;             return session.Evaluate(typeof(T), CriteriaOperator.Parse($"{aggregate}({field.MemberExpressionName()})"), CriteriaOperator.FromLambda(filter()));         }     } }using System; using System.Data; using DevExpress.ExpressApp.DC; using DevExpress.ExpressApp.DC.Xpo; using DevExpress.ExpressApp.Xpo; using DevExpress.Xpo; using DevExpress.Xpo.Metadata; using DevExpress.Xpo.Metadata.Helpers;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions{     public class FastObjectSpaceProvider:XPObjectSpaceProvider{         public FastObjectSpaceProvider(IXpoDataStoreProvider dataStoreProvider, bool threadSafe, bool useSeparateDataLayers = false) : base(dataStoreProvider, threadSafe, useSeparateDataLayers){         }          public FastObjectSpaceProvider(string connectionString, IDbConnection connection, bool threadSafe, bool useSeparateDataLayers = false) : base(connectionString, connection, threadSafe, useSeparateDataLayers){         }          public FastObjectSpaceProvider(IXpoDataStoreProvider dataStoreProvider, ITypesInfo typesInfo, XpoTypeInfoSource xpoTypeInfoSource, bool threadSafe, bool useSeparateDataLayers = false) : base(dataStoreProvider, typesInfo, xpoTypeInfoSource, threadSafe, useSeparateDataLayers){         }          public FastObjectSpaceProvider(IXpoDataStoreProvider dataStoreProvider) : base(dataStoreProvider){         }          public FastObjectSpaceProvider(string connectionString, IDbConnection connection) : base(connectionString, connection){         }          public FastObjectSpaceProvider(IDbConnection connection) : base(connection){         }          public FastObjectSpaceProvider(string connectionString) : base(connectionString){         }          public FastObjectSpaceProvider(IXpoDataStoreProvider dataStoreProvider, ITypesInfo typesInfo, XpoTypeInfoSource xpoTypeInfoSource) : base(dataStoreProvider, typesInfo, xpoTypeInfoSource){         }          protected override UnitOfWork CreateUnitOfWork(IDataLayer dataLayer) => new FastUnitOfWork(dataLayer);     }          public class FastUnitOfWork : UnitOfWork {         public FastUnitOfWork() {         }          public FastUnitOfWork(XPDictionary dictionary) : base(dictionary)              => TrackPropertiesModifications = true;          public FastUnitOfWork(IDataLayer layer)             : this(layer,Array.Empty<IDisposable>()){         }         public FastUnitOfWork(IDataLayer layer, IDisposable[] disposeOnDisconnect) : base(layer, disposeOnDisconnect)              => TrackPropertiesModifications = true;          public FastUnitOfWork(IObjectLayer layer)             : this(layer, Array.Empty<IDisposable>()) {         }                  public FastUnitOfWork(IObjectLayer layer, params IDisposable[] disposeOnDisconnect)             : base(layer, disposeOnDisconnect) =>             TrackPropertiesModifications = true;          protected override MemberInfoCollection GetPropertiesListForUpdateInsert(object theObject, bool isUpdate, bool addDelayedReference){             var defaultMembers = base.GetPropertiesListForUpdateInsert(theObject, isUpdate, addDelayedReference);             if (TrackPropertiesModifications && isUpdate){                 var members = new MemberInfoCollection(GetClassInfo(theObject));                 foreach (var mi in base.GetPropertiesListForUpdateInsert(theObject, true, addDelayedReference))                     if (mi is ServiceField || mi.GetModified(theObject))                         members.Add(mi);                 return members;             }                      return defaultMembers;         }      }  }namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions {     public static partial class ObjectSpaceExtensions {         //          // public static Task CommitChangesAsync(this IObjectSpace objectSpace) =>         //     ((IObjectSpaceAsync) objectSpace).CommitChangesAsync();     } }using System.Data; using System.Diagnostics; using System.Linq; using DevExpress.ExpressApp; using DevExpress.ExpressApp.Xpo; using DevExpress.Xpo; using Fasterflect; using Xpand.Extensions.ObjectExtensions;  namespace Xpand.Extensions.XAF.Xpo.ObjectSpaceExtensions{     public static partial class ObjectSpaceExtensions{         [DebuggerStepThrough]         public static IXpoDataStoreProvider DataStoreProvider(this IObjectSpaceProvider objectSpaceProvider)              => (IXpoDataStoreProvider) objectSpaceProvider.GetPropertyValue("DataStoreProvider");                      [DebuggerStepThrough]         public static UnitOfWork UnitOfWork(this IObjectSpace objectSpace)              => (UnitOfWork)(objectSpace is XPObjectSpace xpObjectSpace ? xpObjectSpace.Session                 : (UnitOfWork)objectSpace.Cast<CompositeObjectSpace>().AdditionalObjectSpaces.OfType<XPObjectSpace>().FirstOrDefault()?.Session);                  [DebuggerStepThrough]         public static UnitOfWork Session(this IObjectSpace objectSpace)              => objectSpace.UnitOfWork();          [DebuggerStepThrough]         public static IDbConnection Connection(this IObjectSpace objectSpace) => objectSpace.UnitOfWork().Connection();     } }using System.Reflection; using System.Runtime.CompilerServices; using System.Runtime.InteropServices; using System.Security;  // General Information about an assembly is controlled through the following  // set of attributes. Change these attribute values to modify the information // associated with an assembly. [assembly: AssemblyTitle("Xpand.Extensions.XAF.Xpo")] [assembly: AssemblyMetadata("Platform","Core")] [assembly: AssemblyDescription("")] [assembly: AssemblyConfiguration("")] [assembly: AssemblyCompany("")] [assembly: AssemblyProduct("Xpand.Extensions.XAF.Xpo")] [assembly: AssemblyCopyright("Copyright eXpandFramework  2018")] [assembly: AssemblyTrademark("")] [assembly: AssemblyCulture("")]  // Setting ComVisible to false makes the types in this assembly not visible  // to COM components.  If you need to access a type in this assembly from  // COM, set the ComVisible attribute to true on that type. [assembly: ComVisible(false)]  // Version information for an assembly consists of the following four values: // //      Major Version //      Minor Version  //      Build Number //      Revision // // You can specify all the values or you can default the Build and Revision Numbers  // by using the '*' as shown below: [assembly: AssemblyVersion(AssemblyInfoVersion.Version)] [assembly: AssemblyFileVersion(AssemblyInfoVersion.Version)] //[assembly:AllowPartiallyTrustedCallers] //[assembly: SecurityTransparent()]using DevExpress.Xpo;  namespace Xpand.Extensions.XAF.Xpo.SessionExtensions {     public static partial class SessionExtensions {         public static void Close(this Session session){             session.Disconnect();             session.Dispose();         }      } }using System; using System.Linq; using System.Linq.Expressions; using DevExpress.Xpo; using Fasterflect;  namespace Xpand.Extensions.XAF.Xpo.SessionExtensions {     public static partial class SessionExtensions {         public static T EnsureObject<T>(this Session session, Expression<Func<T, bool>> criteriaExpression,             Action<T> initialize,bool inTransaction=false) {             var query = session.Query<T>();             if (inTransaction) {                 query = query.InTransaction();             }             var ensureObject = query.FirstOrDefault(criteriaExpression);             if (ensureObject != null) {                 return ensureObject;             }              ensureObject = (T)typeof(T).CreateInstance(session);             initialize(ensureObject);             return ensureObject;         }     } }using System; using DevExpress.Xpo; using Xpand.Extensions.Reactive.Conditional; using Xpand.Extensions.Reactive.Transform;  namespace Xpand.Extensions.XAF.Xpo.SessionExtensions {     public static partial class SessionExtensions {         public static IObservable<ObjectManipulationEventArgs> WhenObjectSaving(this Session session)              => session.WhenEvent<ObjectManipulationEventArgs>(nameof(Session.ObjectSaving)).TakeUntilDisposed(session);          public static IObservable<TSession> WhenAfterRollbackTransaction<TSession>(this TSession session) where TSession:Session              => session.WhenEvent(nameof(Session.AfterRollbackTransaction)).To(session).TakeUntilDisposed(session);          public static IObservable<TSession> WhenFailedCommitTransaction<TSession>(this TSession session) where TSession:Session              => session.WhenEvent(nameof(Session.FailedCommitTransaction)).To(session).TakeUntilDisposed(session);                  public static IObservable<TSession> WhenAfterCommitTransaction<TSession>(this TSession session) where TSession : Session             => session.WhenEvent(nameof(Session.AfterCommitTransaction)).TakeUntilDisposed(session).To(session);                  public static IObservable<TSession> WhenObjectsSaved<TSession>(this TSession session) where TSession:Session              => session.WhenEvent(nameof(Session.ObjectsSaved)).To(session).TakeUntilDisposed(session);     } }using DevExpress.ExpressApp; using DevExpress.ExpressApp.Xpo; using DevExpress.Xpo.Helpers;  namespace Xpand.Extensions.XAF.Xpo.SessionProviderExtensions {     public static class SessionProviderExtensions {         public static IObjectSpace ObjectSpace(this ISessionProvider provider)              => XPObjectSpace.FindObjectSpaceByObject(provider);     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {          public class BooleanToDecimalValueConverter : ValueConverter {         public override Type StorageType => typeof(decimal);          public override object ConvertToStorageType(object value) => value == null ? null : (object)Convert.ToDecimal(value);          public override object ConvertFromStorageType(object value) => value == null ? null : (object)Convert.ToBoolean(value);     } }using System; using System.Drawing; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class ColorValueConverter : ValueConverter {         public override Type StorageType => typeof(Int32);          public override object ConvertToStorageType(object value) {             if(!(value is Color)) return null;             Color color = (Color)value;             return color.IsEmpty ? -1 : color.ToArgb();         }         public override object ConvertFromStorageType(object value) {             if(!(value is Int32)) return null;             Int32 argbCode = Convert.ToInt32(value);             return argbCode == -1 ? Color.Empty : Color.FromArgb(argbCode);         }     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class DateTimeOffsetConverter : ValueConverter {         public override object ConvertFromStorageType(object value) => value;          public override object ConvertToStorageType(object value) => value is DateTimeOffset dto ? dto.ToString() : value;          public override Type StorageType => typeof(string);     } }using System; using System.Collections.Generic; using System.Linq; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class DictionaryValueConverter : ValueConverter{         private const string KeyDelimiter = "";         private const string Delimiter = "";         public override Type StorageType => typeof(string);          public override object ConvertToStorageType(object value){             var s = ((Dictionary<string, string>)value)?.Aggregate<KeyValuePair<string, string>, string>(null,                 (current, o) => current + o.Key + KeyDelimiter + o.Value + Delimiter);              return s?.TrimEnd(Delimiter.ToCharArray());         }          public override object ConvertFromStorageType(object value){             if (value == null) return null;             var split = value.ToString().Split(Delimiter.ToCharArray());             return value.ToString().IndexOf(KeyDelimiter, StringComparison.Ordinal) > -1                 ? split.Select(s => s.Split(KeyDelimiter.ToCharArray())).ToDictionary(                     strings => strings[0].TrimStart('['),                     strings => strings.Length == 1 ? null : strings[1].Trim().TrimEnd(']'))                 : new Dictionary<string, string>();         }     } }using System; using System.Diagnostics.CodeAnalysis; using System.Drawing; using System.Drawing.Imaging; using System.IO; using DevExpress.Xpo.Metadata; using Xpand.Extensions.StreamExtensions;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class ImageCompressionValueConverter : ValueConverter{         #region Properties          public override Type StorageType => typeof (byte[]);          #endregion          [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public override object ConvertToStorageType(object value){             if (value != null && !(value is Image)){                 throw new ArgumentException();             }             if (value == null){                 return null;             }             var ms = new MemoryStream();             ((Image) value).Save(ms, ImageFormat.Jpeg);             return ms.GZip();         }          public override object ConvertFromStorageType(object value) {             if (value != null && !(value is byte[])){                 throw new ArgumentException();             }              return value == null || ((byte[]) value).Length == 0 ? value : new MemoryStream((byte[]) value).UnGzip();         }     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class NullValueConverter : ValueConverter {         public override object ConvertToStorageType(object value) => null;          public override object ConvertFromStorageType(object value) => null;          public override Type StorageType => typeof(string);     } }using System; using DevExpress.Xpo.Metadata; using Xpand.Extensions.XAF.NonPersistentObjects;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class ObjectStringValueConverter:ValueConverter {         public override object ConvertToStorageType(object value)              => value is ObjectString objectString ? objectString.Name : null;          public override object ConvertFromStorageType(object value)              => new ObjectString((string) value);          public override Type StorageType { get; } = typeof(string);     } }using System; using DevExpress.Xpo.Metadata; using Xpand.Extensions.AppDomainExtensions;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class ObjectTypeValueConverter:ValueConverter {         public override object ConvertToStorageType(object value)              => value is NonPersistentObjects.ObjectType objectType ? objectType.Type?.FullName : null;          public override object ConvertFromStorageType(object value) {             var fullName = $"{value}";             return !string.IsNullOrEmpty(fullName) ? new NonPersistentObjects.ObjectType(AppDomain.CurrentDomain.GetAssemblyType(fullName)) : null;         }          public override Type StorageType { get; } = typeof(string);     } }using System; using System.Diagnostics.CodeAnalysis; using System.Drawing; using System.Drawing.Imaging; using System.IO; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class PictureValueConverter : ValueConverter {         public override Type StorageType => typeof(byte[]);          [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public override object ConvertToStorageType(object value) {             if (value == null) {                 return null;             }              var m = new MemoryStream();             ((Image) value).Save(m, ImageFormat.Jpeg);             return m.GetBuffer();         }          [SuppressMessage("Interoperability", "CA1416:Validate platform compatibility")]         public override object ConvertFromStorageType(object value) {             if (value == null) {                 return null;             }              var m = new MemoryStream((byte[]) value);             return new Bitmap(m);         }     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class SqlDateTimeOverFlowValueConverter : ValueConverter {         public override Type StorageType => typeof(DateTime);          public override object ConvertToStorageType(object value) {             if (value is not DateTime dateTimeValue) return value;             var minValue = new DateTime(1753, 1, 1);             var maxValue = new DateTime(9999, 12, 31);             return dateTimeValue >= minValue ? dateTimeValue > maxValue ? maxValue : value                 : minValue.AddTicks(dateTimeValue.TimeOfDay.Ticks);          }          public override object ConvertFromStorageType(object value)              => value != null && (DateTime)value == new DateTime(1753, 1, 1) ? DateTime.MinValue : value;     }     public class SqlDateTimeOffSetOverFlowValueConverter : ValueConverter {         public override Type StorageType => typeof(DateTime);          public override object ConvertToStorageType(object value) {             if (value != null) {                 var dateTime = new DateTimeOffset(new DateTime(1753, 1, 1));                 if (dateTime > (DateTimeOffset)value) {                     var time = ((DateTimeOffset)value).TimeOfDay;                     DateTimeOffset storageType = dateTime.AddTicks(time.Ticks);                     return storageType.DateTime;                 }                 dateTime = new DateTimeOffset(new DateTime(9999, 12, 31));                 return dateTime < (DateTimeOffset)value ? dateTime.DateTime : ((DateTimeOffset)value).DateTime;             }             return null;         }          public override object ConvertFromStorageType(object value) => value != null ? new DateTimeOffset((DateTime)value) : null;     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {      public class StringValueConverter : ValueConverter {         public override Type StorageType => typeof(string);          public override object ConvertToStorageType(object value) => value?.ToString();          public override object ConvertFromStorageType(object value) => value?.ToString();     } }using System; using DevExpress.Xpo.Metadata; using Xpand.Extensions.Numeric;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class TimeSpanSecondsValueConverter:ValueConverter {         public override object ConvertToStorageType(object value)              => ((TimeSpan?)value)?.TotalSeconds.Round() ?? 0;          public override object ConvertFromStorageType(object value) => TimeSpan.FromSeconds(((long)(value ?? 0L)));          public override Type StorageType => typeof(long);      } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class TimeSpanTicksValueConverter:ValueConverter {         public override object ConvertToStorageType(object value) => ((TimeSpan?)value)?.Ticks ?? 0;          public override object ConvertFromStorageType(object value) => TimeSpan.FromTicks(((long)(value??0L)));          public override Type StorageType => typeof(long);     } }using System; using System.Xml; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class TimeSpanValueToXmlConverter : ValueConverter {         public override object ConvertFromStorageType(object value) => value == null ? TimeSpan.Zero : XmlConvert.ToTimeSpan((String)value);          public override object ConvertToStorageType(object value) => value == null ? null : XmlConvert.ToString((TimeSpan)value);         public override Type StorageType => typeof(String);     } }using System; using DevExpress.Persistent.Base; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class TypeValueConverter : ValueConverter {         public override Type StorageType => typeof (string);          public override object ConvertFromStorageType(object value) {             if (value == null)                 return null;              try {                 return ReflectionHelper.GetType(value.ToString());             }             catch (TypeWasNotFoundException) {             }              return null;         }          public override object ConvertToStorageType(object value) {             return ((Type) value)?.FullName;         }     } }using System; using DevExpress.Xpo.Metadata;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters{     public class UriValueConverter : ValueConverter {         public override Type StorageType => typeof(string);          public override object ConvertFromStorageType(object value) => value == null ? null : new Uri(value.ToString());          public override object ConvertToStorageType(object value) => value?.ToString();     } }using System;  namespace Xpand.Extensions.XAF.Xpo.ValueConverters {     public class XpandUtcDateTimeConverter : DevExpress.Xpo.Metadata.UtcDateTimeConverter {         public override object ConvertToStorageType(object value) {             object convertToStorageType = base.ConvertToStorageType(value);             return new SqlDateTimeOverFlowValueConverter().ConvertToStorageType(convertToStorageType);         }         public override object ConvertFromStorageType(object value) {             object fromStorageType = new SqlDateTimeOverFlowValueConverter().ConvertFromStorageType(value);             object convertFromStorageType = base.ConvertFromStorageType(fromStorageType);             return convertFromStorageType != null && ((DateTime)convertFromStorageType).Date == new DateTime(0001, 1, 1) ? null : convertFromStorageType;         }     } }
